"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(action-browser)/./node_modules/ai/rsc/dist/rsc-server.mjs":
/*!*************************************************!*\
  !*** ./node_modules/ai/rsc/dist/rsc-server.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_4___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $$RSC_SERVER_ACTION_0: () => (/* binding */ $$RSC_SERVER_ACTION_0),\n/* harmony export */   createAI: () => (/* binding */ createAI),\n/* harmony export */   createStreamableUI: () => (/* binding */ createStreamableUI),\n/* harmony export */   createStreamableValue: () => (/* binding */ createStreamableValue),\n/* harmony export */   getAIState: () => (/* binding */ getAIState),\n/* harmony export */   getMutableAIState: () => (/* binding */ getMutableAIState),\n/* harmony export */   render: () => (/* binding */ render),\n/* harmony export */   streamUI: () => (/* binding */ streamUI)\n/* harmony export */ });\n/* harmony import */ var private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! private-next-rsc-server-reference */ \"(action-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/server-reference.js\");\n/* harmony import */ var private_next_rsc_action_encryption__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! private-next-rsc-action-encryption */ \"(action-browser)/./node_modules/next/dist/server/app-render/encryption.js\");\n/* harmony import */ var jsondiffpatch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! jsondiffpatch */ \"(action-browser)/./node_modules/jsondiffpatch/lib/index.js\");\n/* harmony import */ var async_hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! async_hooks */ \"async_hooks\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ \"(action-browser)/./node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js\");\n/* harmony import */ var _rsc_shared_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rsc-shared.mjs */ \"(action-browser)/./node_modules/ai/rsc/dist/rsc-shared.mjs\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react/jsx-runtime */ \"(action-browser)/./node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-jsx-runtime.js\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(action-browser)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ai-sdk/provider */ \"(action-browser)/./node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! zod */ \"(action-browser)/./node_modules/zod/dist/esm/index.js\");\n/* harmony import */ var _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ai-sdk/ui-utils */ \"(action-browser)/./node_modules/@ai-sdk/ui-utils/dist/index.mjs\");\n/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! zod-to-json-schema */ \"(action-browser)/./node_modules/zod-to-json-schema/dist/esm/index.js\");\n/* harmony import */ var eventsource_parser__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! eventsource-parser */ \"(action-browser)/./node_modules/eventsource-parser/dist/index.js\");\n// rsc/ai-state.tsx\n/* __next_internal_action_entry_do_not_use__ {\"7f6527b7c1fff0772406239d03c3b11bc4834212ef\":\"$$RSC_SERVER_ACTION_0\"} */ \n\n\n\n// util/create-resolvable-promise.ts\nfunction createResolvablePromise() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    return {\n        promise,\n        resolve,\n        reject\n    };\n}\n// util/is-function.ts\nvar isFunction = (value)=>typeof value === \"function\";\n// rsc/ai-state.tsx\nvar asyncAIStateStorage = new async_hooks__WEBPACK_IMPORTED_MODULE_2__.AsyncLocalStorage();\nfunction getAIStateStoreOrThrow(message) {\n    const store = asyncAIStateStorage.getStore();\n    if (!store) {\n        throw new Error(message);\n    }\n    return store;\n}\nfunction withAIState({ state: state1, options }, fn) {\n    return asyncAIStateStorage.run({\n        currentState: JSON.parse(JSON.stringify(state1)),\n        // deep clone object\n        originalState: state1,\n        sealed: false,\n        options\n    }, fn);\n}\nfunction getAIStateDeltaPromise() {\n    const store = getAIStateStoreOrThrow(\"Internal error occurred.\");\n    return store.mutationDeltaPromise;\n}\nfunction sealMutableAIState() {\n    const store = getAIStateStoreOrThrow(\"Internal error occurred.\");\n    store.sealed = true;\n}\nfunction getAIState(...args) {\n    const store = getAIStateStoreOrThrow(\"`getAIState` must be called within an AI Action.\");\n    if (args.length > 0) {\n        const key = args[0];\n        if (typeof store.currentState !== \"object\") {\n            throw new Error(`You can't get the \"${String(key)}\" field from the AI state because it's not an object.`);\n        }\n        return store.currentState[key];\n    }\n    return store.currentState;\n}\nfunction getMutableAIState(...args) {\n    const store = getAIStateStoreOrThrow(\"`getMutableAIState` must be called within an AI Action.\");\n    if (store.sealed) {\n        throw new Error(\"`getMutableAIState` must be called before returning from an AI Action. Please move it to the top level of the Action's function body.\");\n    }\n    if (!store.mutationDeltaPromise) {\n        const { promise, resolve } = createResolvablePromise();\n        store.mutationDeltaPromise = promise;\n        store.mutationDeltaResolve = resolve;\n    }\n    function doUpdate(newState, done) {\n        var _a9, _b;\n        if (args.length > 0) {\n            if (typeof store.currentState !== \"object\") {\n                const key = args[0];\n                throw new Error(`You can't modify the \"${String(key)}\" field of the AI state because it's not an object.`);\n            }\n        }\n        if (isFunction(newState)) {\n            if (args.length > 0) {\n                store.currentState[args[0]] = newState(store.currentState[args[0]]);\n            } else {\n                store.currentState = newState(store.currentState);\n            }\n        } else {\n            if (args.length > 0) {\n                store.currentState[args[0]] = newState;\n            } else {\n                store.currentState = newState;\n            }\n        }\n        (_b = (_a9 = store.options).onSetAIState) == null ? void 0 : _b.call(_a9, {\n            key: args.length > 0 ? args[0] : void 0,\n            state: store.currentState,\n            done\n        });\n    }\n    const mutableState = {\n        get: ()=>{\n            if (args.length > 0) {\n                const key = args[0];\n                if (typeof store.currentState !== \"object\") {\n                    throw new Error(`You can't get the \"${String(key)}\" field from the AI state because it's not an object.`);\n                }\n                return store.currentState[key];\n            }\n            return store.currentState;\n        },\n        update: function update(newAIState) {\n            doUpdate(newAIState, false);\n        },\n        done: function done(...doneArgs) {\n            if (doneArgs.length > 0) {\n                doUpdate(doneArgs[0], true);\n            }\n            const delta = jsondiffpatch__WEBPACK_IMPORTED_MODULE_3__.diff(store.originalState, store.currentState);\n            store.mutationDeltaResolve(delta);\n        }\n    };\n    return mutableState;\n}\n// rsc/provider.tsx\n\n\n\nconst $$RSC_SERVER_ACTION_0 = async function innerAction({ action, options }, state1, ...args) {\n    return await withAIState({\n        state: state1,\n        options\n    }, async ()=>{\n        const result = await action(...args);\n        sealMutableAIState();\n        return [\n            getAIStateDeltaPromise(),\n            result\n        ];\n    });\n};\nvar innerAction = (0,private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__.registerServerReference)($$RSC_SERVER_ACTION_0, \"7f6527b7c1fff0772406239d03c3b11bc4834212ef\", null);\nfunction wrapAction(action, options) {\n    return innerAction.bind(null, {\n        action,\n        options\n    });\n}\nfunction createAI({ actions, initialAIState, initialUIState, onSetAIState, onGetUIState }) {\n    const wrappedActions = {};\n    for(const name9 in actions){\n        wrappedActions[name9] = wrapAction(actions[name9], {\n            onSetAIState\n        });\n    }\n    const wrappedSyncUIState = onGetUIState ? wrapAction(onGetUIState, {}) : void 0;\n    const AI = async (props)=>{\n        var _a9, _b;\n        if (\"useState\" in /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_4___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_4___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_4__, 2)))) {\n            throw new Error(\"This component can only be used inside Server Components.\");\n        }\n        let uiState = (_a9 = props.initialUIState) != null ? _a9 : initialUIState;\n        let aiState = (_b = props.initialAIState) != null ? _b : initialAIState;\n        let aiStateDelta = void 0;\n        if (wrappedSyncUIState) {\n            const [newAIStateDelta, newUIState] = await wrappedSyncUIState(aiState);\n            if (newUIState !== void 0) {\n                aiStateDelta = newAIStateDelta;\n                uiState = newUIState;\n            }\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_rsc_shared_mjs__WEBPACK_IMPORTED_MODULE_6__.InternalAIProvider, {\n            wrappedActions,\n            wrappedSyncUIState,\n            initialUIState: uiState,\n            initialAIState: aiState,\n            initialAIStatePatch: aiStateDelta,\n            children: props.children\n        });\n    };\n    return AI;\n}\n// rsc/stream-ui/stream-ui.tsx\n\n// util/download-error.ts\n\nvar name = \"AI_DownloadError\";\nvar marker = `vercel.ai.error.${name}`;\nvar symbol = Symbol.for(marker);\nvar _a;\nvar DownloadError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError {\n    constructor({ url, statusCode, statusText, cause, message = cause == null ? `Failed to download ${url}: ${statusCode} ${statusText}` : `Failed to download ${url}: ${cause}` }){\n        super({\n            name,\n            message,\n            cause\n        });\n        this[_a] = true;\n        this.url = url;\n        this.statusCode = statusCode;\n        this.statusText = statusText;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError.hasMarker(error, marker);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isDownloadError(error) {\n        return error instanceof Error && error.name === name && typeof error.url === \"string\" && (error.statusCode == null || typeof error.statusCode === \"number\") && (error.statusText == null || typeof error.statusText === \"string\");\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            url: this.url,\n            statusCode: this.statusCode,\n            statusText: this.statusText,\n            cause: this.cause\n        };\n    }\n};\n_a = symbol;\n// util/download.ts\nasync function download({ url, fetchImplementation = fetch }) {\n    var _a9;\n    const urlText = url.toString();\n    try {\n        const response = await fetchImplementation(urlText);\n        if (!response.ok) {\n            throw new DownloadError({\n                url: urlText,\n                statusCode: response.status,\n                statusText: response.statusText\n            });\n        }\n        return {\n            data: new Uint8Array(await response.arrayBuffer()),\n            mimeType: (_a9 = response.headers.get(\"content-type\")) != null ? _a9 : void 0\n        };\n    } catch (error) {\n        if (DownloadError.isInstance(error)) {\n            throw error;\n        }\n        throw new DownloadError({\n            url: urlText,\n            cause: error\n        });\n    }\n}\n// core/util/detect-image-mimetype.ts\nvar mimeTypeSignatures = [\n    {\n        mimeType: \"image/gif\",\n        bytes: [\n            71,\n            73,\n            70\n        ]\n    },\n    {\n        mimeType: \"image/png\",\n        bytes: [\n            137,\n            80,\n            78,\n            71\n        ]\n    },\n    {\n        mimeType: \"image/jpeg\",\n        bytes: [\n            255,\n            216\n        ]\n    },\n    {\n        mimeType: \"image/webp\",\n        bytes: [\n            82,\n            73,\n            70,\n            70\n        ]\n    }\n];\nfunction detectImageMimeType(image) {\n    for (const { bytes, mimeType } of mimeTypeSignatures){\n        if (image.length >= bytes.length && bytes.every((byte, index)=>image[index] === byte)) {\n            return mimeType;\n        }\n    }\n    return void 0;\n}\n// core/prompt/data-content.ts\n\n// core/prompt/invalid-data-content-error.ts\n\nvar name2 = \"AI_InvalidDataContentError\";\nvar marker2 = `vercel.ai.error.${name2}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar InvalidDataContentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError {\n    constructor({ content, cause, message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.` }){\n        super({\n            name: name2,\n            message,\n            cause\n        });\n        this[_a2] = true;\n        this.content = content;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError.hasMarker(error, marker2);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidDataContentError(error) {\n        return error instanceof Error && error.name === name2 && error.content != null;\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            cause: this.cause,\n            content: this.content\n        };\n    }\n};\n_a2 = symbol2;\n// core/prompt/data-content.ts\n\nvar dataContentSchema = zod__WEBPACK_IMPORTED_MODULE_8__.z.union([\n    zod__WEBPACK_IMPORTED_MODULE_8__.z.string(),\n    zod__WEBPACK_IMPORTED_MODULE_8__.z[\"instanceof\"](Uint8Array),\n    zod__WEBPACK_IMPORTED_MODULE_8__.z[\"instanceof\"](ArrayBuffer),\n    zod__WEBPACK_IMPORTED_MODULE_8__.z.custom(// Buffer might not be available in some environments such as CloudFlare:\n    (value)=>{\n        var _a9, _b;\n        return (_b = (_a9 = globalThis.Buffer) == null ? void 0 : _a9.isBuffer(value)) != null ? _b : false;\n    }, {\n        message: \"Must be a Buffer\"\n    })\n]);\nfunction convertDataContentToBase64String(content) {\n    if (typeof content === \"string\") {\n        return content;\n    }\n    if (content instanceof ArrayBuffer) {\n        return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_9__.convertUint8ArrayToBase64)(new Uint8Array(content));\n    }\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_9__.convertUint8ArrayToBase64)(content);\n}\nfunction convertDataContentToUint8Array(content) {\n    if (content instanceof Uint8Array) {\n        return content;\n    }\n    if (typeof content === \"string\") {\n        try {\n            return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_9__.convertBase64ToUint8Array)(content);\n        } catch (error) {\n            throw new InvalidDataContentError({\n                message: \"Invalid data content. Content string is not a base64-encoded media.\",\n                content,\n                cause: error\n            });\n        }\n    }\n    if (content instanceof ArrayBuffer) {\n        return new Uint8Array(content);\n    }\n    throw new InvalidDataContentError({\n        content\n    });\n}\nfunction convertUint8ArrayToText(uint8Array) {\n    try {\n        return new TextDecoder().decode(uint8Array);\n    } catch (error) {\n        throw new Error(\"Error decoding Uint8Array to text\");\n    }\n}\n// core/prompt/invalid-message-role-error.ts\n\nvar name3 = \"AI_InvalidMessageRoleError\";\nvar marker3 = `vercel.ai.error.${name3}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar InvalidMessageRoleError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError {\n    constructor({ role, message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".` }){\n        super({\n            name: name3,\n            message\n        });\n        this[_a3] = true;\n        this.role = role;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError.hasMarker(error, marker3);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidMessageRoleError(error) {\n        return error instanceof Error && error.name === name3 && typeof error.role === \"string\";\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            role: this.role\n        };\n    }\n};\n_a3 = symbol3;\n// core/prompt/split-data-url.ts\nfunction splitDataUrl(dataUrl) {\n    try {\n        const [header, base64Content] = dataUrl.split(\",\");\n        return {\n            mimeType: header.split(\";\")[0].split(\":\")[1],\n            base64Content\n        };\n    } catch (error) {\n        return {\n            mimeType: void 0,\n            base64Content: void 0\n        };\n    }\n}\n// core/prompt/convert-to-language-model-prompt.ts\nasync function convertToLanguageModelPrompt({ prompt, modelSupportsImageUrls = true, modelSupportsUrl = ()=>false, downloadImplementation = download }) {\n    const downloadedAssets = await downloadAssets(prompt.messages, downloadImplementation, modelSupportsImageUrls, modelSupportsUrl);\n    return [\n        ...prompt.system != null ? [\n            {\n                role: \"system\",\n                content: prompt.system\n            }\n        ] : [],\n        ...prompt.messages.map((message)=>convertToLanguageModelMessage(message, downloadedAssets))\n    ];\n}\nfunction convertToLanguageModelMessage(message, downloadedAssets) {\n    const role = message.role;\n    switch(role){\n        case \"system\":\n            {\n                return {\n                    role: \"system\",\n                    content: message.content,\n                    providerMetadata: message.experimental_providerMetadata\n                };\n            }\n        case \"user\":\n            {\n                if (typeof message.content === \"string\") {\n                    return {\n                        role: \"user\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: message.content\n                            }\n                        ],\n                        providerMetadata: message.experimental_providerMetadata\n                    };\n                }\n                return {\n                    role: \"user\",\n                    content: message.content.map((part)=>convertPartToLanguageModelPart(part, downloadedAssets)).filter((part)=>part.type !== \"text\" || part.text !== \"\"),\n                    providerMetadata: message.experimental_providerMetadata\n                };\n            }\n        case \"assistant\":\n            {\n                if (typeof message.content === \"string\") {\n                    return {\n                        role: \"assistant\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: message.content\n                            }\n                        ],\n                        providerMetadata: message.experimental_providerMetadata\n                    };\n                }\n                return {\n                    role: \"assistant\",\n                    content: message.content.filter(// remove empty text parts:\n                    (part)=>part.type !== \"text\" || part.text !== \"\").map((part)=>{\n                        const { experimental_providerMetadata, ...rest } = part;\n                        return {\n                            ...rest,\n                            providerMetadata: experimental_providerMetadata\n                        };\n                    }),\n                    providerMetadata: message.experimental_providerMetadata\n                };\n            }\n        case \"tool\":\n            {\n                return {\n                    role: \"tool\",\n                    content: message.content.map((part)=>({\n                            type: \"tool-result\",\n                            toolCallId: part.toolCallId,\n                            toolName: part.toolName,\n                            result: part.result,\n                            content: part.experimental_content,\n                            isError: part.isError,\n                            providerMetadata: part.experimental_providerMetadata\n                        })),\n                    providerMetadata: message.experimental_providerMetadata\n                };\n            }\n        default:\n            {\n                const _exhaustiveCheck = role;\n                throw new InvalidMessageRoleError({\n                    role: _exhaustiveCheck\n                });\n            }\n    }\n}\nasync function downloadAssets(messages, downloadImplementation, modelSupportsImageUrls, modelSupportsUrl) {\n    const urls = messages.filter((message)=>message.role === \"user\").map((message)=>message.content).filter((content)=>Array.isArray(content)).flat().filter((part)=>part.type === \"image\" || part.type === \"file\").filter((part)=>!(part.type === \"image\" && modelSupportsImageUrls === true)).map((part)=>part.type === \"image\" ? part.image : part.data).map((part)=>// support string urls:\n        typeof part === \"string\" && (part.startsWith(\"http:\") || part.startsWith(\"https:\")) ? new URL(part) : part).filter((image)=>image instanceof URL).filter((url)=>!modelSupportsUrl(url));\n    const downloadedImages = await Promise.all(urls.map(async (url)=>({\n            url,\n            data: await downloadImplementation({\n                url\n            })\n        })));\n    return Object.fromEntries(downloadedImages.map(({ url, data })=>[\n            url.toString(),\n            data\n        ]));\n}\nfunction convertPartToLanguageModelPart(part, downloadedAssets) {\n    if (part.type === \"text\") {\n        return {\n            type: \"text\",\n            text: part.text,\n            providerMetadata: part.experimental_providerMetadata\n        };\n    }\n    let mimeType = part.mimeType;\n    let data;\n    let content;\n    let normalizedData;\n    const type = part.type;\n    switch(type){\n        case \"image\":\n            data = part.image;\n            break;\n        case \"file\":\n            data = part.data;\n            break;\n        default:\n            throw new Error(`Unsupported part type: ${type}`);\n    }\n    try {\n        content = typeof data === \"string\" ? new URL(data) : data;\n    } catch (error) {\n        content = data;\n    }\n    if (content instanceof URL) {\n        if (content.protocol === \"data:\") {\n            const { mimeType: dataUrlMimeType, base64Content } = splitDataUrl(content.toString());\n            if (dataUrlMimeType == null || base64Content == null) {\n                throw new Error(`Invalid data URL format in part ${type}`);\n            }\n            mimeType = dataUrlMimeType;\n            normalizedData = convertDataContentToUint8Array(base64Content);\n        } else {\n            const downloadedFile = downloadedAssets[content.toString()];\n            if (downloadedFile) {\n                normalizedData = downloadedFile.data;\n                mimeType != null ? mimeType : mimeType = downloadedFile.mimeType;\n            } else {\n                normalizedData = content;\n            }\n        }\n    } else {\n        normalizedData = convertDataContentToUint8Array(content);\n    }\n    switch(type){\n        case \"image\":\n            if (mimeType == null && normalizedData instanceof Uint8Array) {\n                mimeType = detectImageMimeType(normalizedData);\n            }\n            return {\n                type: \"image\",\n                image: normalizedData,\n                mimeType,\n                providerMetadata: part.experimental_providerMetadata\n            };\n        case \"file\":\n            if (mimeType == null) {\n                throw new Error(`Mime type is missing for file part`);\n            }\n            return {\n                type: \"file\",\n                data: normalizedData instanceof Uint8Array ? convertDataContentToBase64String(normalizedData) : normalizedData,\n                mimeType,\n                providerMetadata: part.experimental_providerMetadata\n            };\n    }\n}\n// errors/invalid-argument-error.ts\n\nvar name4 = \"AI_InvalidArgumentError\";\nvar marker4 = `vercel.ai.error.${name4}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidArgumentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError {\n    constructor({ parameter, value, message }){\n        super({\n            name: name4,\n            message: `Invalid argument for parameter ${parameter}: ${message}`\n        });\n        this[_a4] = true;\n        this.parameter = parameter;\n        this.value = value;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError.hasMarker(error, marker4);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidArgumentError(error) {\n        return error instanceof Error && error.name === name4 && typeof error.parameter === \"string\" && typeof error.value === \"string\";\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            parameter: this.parameter,\n            value: this.value\n        };\n    }\n};\n_a4 = symbol4;\n// core/prompt/prepare-call-settings.ts\nfunction prepareCallSettings({ maxTokens, temperature, topP, topK, presencePenalty, frequencyPenalty, stopSequences, seed, maxRetries }) {\n    if (maxTokens != null) {\n        if (!Number.isInteger(maxTokens)) {\n            throw new InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be an integer\"\n            });\n        }\n        if (maxTokens < 1) {\n            throw new InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be >= 1\"\n            });\n        }\n    }\n    if (temperature != null) {\n        if (typeof temperature !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"temperature\",\n                value: temperature,\n                message: \"temperature must be a number\"\n            });\n        }\n    }\n    if (topP != null) {\n        if (typeof topP !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"topP\",\n                value: topP,\n                message: \"topP must be a number\"\n            });\n        }\n    }\n    if (topK != null) {\n        if (typeof topK !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"topK\",\n                value: topK,\n                message: \"topK must be a number\"\n            });\n        }\n    }\n    if (presencePenalty != null) {\n        if (typeof presencePenalty !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"presencePenalty\",\n                value: presencePenalty,\n                message: \"presencePenalty must be a number\"\n            });\n        }\n    }\n    if (frequencyPenalty != null) {\n        if (typeof frequencyPenalty !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"frequencyPenalty\",\n                value: frequencyPenalty,\n                message: \"frequencyPenalty must be a number\"\n            });\n        }\n    }\n    if (seed != null) {\n        if (!Number.isInteger(seed)) {\n            throw new InvalidArgumentError({\n                parameter: \"seed\",\n                value: seed,\n                message: \"seed must be an integer\"\n            });\n        }\n    }\n    if (maxRetries != null) {\n        if (!Number.isInteger(maxRetries)) {\n            throw new InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be an integer\"\n            });\n        }\n        if (maxRetries < 0) {\n            throw new InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be >= 0\"\n            });\n        }\n    }\n    return {\n        maxTokens,\n        temperature: temperature != null ? temperature : 0,\n        topP,\n        topK,\n        presencePenalty,\n        frequencyPenalty,\n        stopSequences: stopSequences != null && stopSequences.length > 0 ? stopSequences : void 0,\n        seed,\n        maxRetries: maxRetries != null ? maxRetries : 2\n    };\n}\n// core/prompt/prepare-tools-and-tool-choice.ts\n\n// core/util/is-non-empty-object.ts\nfunction isNonEmptyObject(object) {\n    return object != null && Object.keys(object).length > 0;\n}\n// core/prompt/prepare-tools-and-tool-choice.ts\nfunction prepareToolsAndToolChoice({ tools, toolChoice, activeTools }) {\n    if (!isNonEmptyObject(tools)) {\n        return {\n            tools: void 0,\n            toolChoice: void 0\n        };\n    }\n    const filteredTools = activeTools != null ? Object.entries(tools).filter(([name9])=>activeTools.includes(name9)) : Object.entries(tools);\n    return {\n        tools: filteredTools.map(([name9, tool])=>{\n            const toolType = tool.type;\n            switch(toolType){\n                case void 0:\n                case \"function\":\n                    return {\n                        type: \"function\",\n                        name: name9,\n                        description: tool.description,\n                        parameters: (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_10__.asSchema)(tool.parameters).jsonSchema\n                    };\n                case \"provider-defined\":\n                    return {\n                        type: \"provider-defined\",\n                        name: name9,\n                        id: tool.id,\n                        args: tool.args\n                    };\n                default:\n                    {\n                        const exhaustiveCheck = toolType;\n                        throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);\n                    }\n            }\n        }),\n        toolChoice: toolChoice == null ? {\n            type: \"auto\"\n        } : typeof toolChoice === \"string\" ? {\n            type: toolChoice\n        } : {\n            type: \"tool\",\n            toolName: toolChoice.toolName\n        }\n    };\n}\n// core/prompt/standardize-prompt.ts\n\n\n\n// core/prompt/message.ts\n\n// core/types/provider-metadata.ts\n\n// core/types/json-value.ts\n\nvar jsonValueSchema = zod__WEBPACK_IMPORTED_MODULE_8__.z.lazy(()=>zod__WEBPACK_IMPORTED_MODULE_8__.z.union([\n        zod__WEBPACK_IMPORTED_MODULE_8__.z[\"null\"](),\n        zod__WEBPACK_IMPORTED_MODULE_8__.z.string(),\n        zod__WEBPACK_IMPORTED_MODULE_8__.z.number(),\n        zod__WEBPACK_IMPORTED_MODULE_8__.z.boolean(),\n        zod__WEBPACK_IMPORTED_MODULE_8__.z.record(zod__WEBPACK_IMPORTED_MODULE_8__.z.string(), jsonValueSchema),\n        zod__WEBPACK_IMPORTED_MODULE_8__.z.array(jsonValueSchema)\n    ]));\n// core/types/provider-metadata.ts\nvar providerMetadataSchema = zod__WEBPACK_IMPORTED_MODULE_8__.z.record(zod__WEBPACK_IMPORTED_MODULE_8__.z.string(), zod__WEBPACK_IMPORTED_MODULE_8__.z.record(zod__WEBPACK_IMPORTED_MODULE_8__.z.string(), jsonValueSchema));\n// core/prompt/content-part.ts\n\n// core/prompt/tool-result-content.ts\n\nvar toolResultContentSchema = zod__WEBPACK_IMPORTED_MODULE_8__.z.array(zod__WEBPACK_IMPORTED_MODULE_8__.z.union([\n    zod__WEBPACK_IMPORTED_MODULE_8__.z.object({\n        type: zod__WEBPACK_IMPORTED_MODULE_8__.z.literal(\"text\"),\n        text: zod__WEBPACK_IMPORTED_MODULE_8__.z.string()\n    }),\n    zod__WEBPACK_IMPORTED_MODULE_8__.z.object({\n        type: zod__WEBPACK_IMPORTED_MODULE_8__.z.literal(\"image\"),\n        data: zod__WEBPACK_IMPORTED_MODULE_8__.z.string(),\n        mimeType: zod__WEBPACK_IMPORTED_MODULE_8__.z.string().optional()\n    })\n]));\n// core/prompt/content-part.ts\nvar textPartSchema = zod__WEBPACK_IMPORTED_MODULE_8__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_8__.z.literal(\"text\"),\n    text: zod__WEBPACK_IMPORTED_MODULE_8__.z.string(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar imagePartSchema = zod__WEBPACK_IMPORTED_MODULE_8__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_8__.z.literal(\"image\"),\n    image: zod__WEBPACK_IMPORTED_MODULE_8__.z.union([\n        dataContentSchema,\n        zod__WEBPACK_IMPORTED_MODULE_8__.z[\"instanceof\"](URL)\n    ]),\n    mimeType: zod__WEBPACK_IMPORTED_MODULE_8__.z.string().optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar filePartSchema = zod__WEBPACK_IMPORTED_MODULE_8__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_8__.z.literal(\"file\"),\n    data: zod__WEBPACK_IMPORTED_MODULE_8__.z.union([\n        dataContentSchema,\n        zod__WEBPACK_IMPORTED_MODULE_8__.z[\"instanceof\"](URL)\n    ]),\n    mimeType: zod__WEBPACK_IMPORTED_MODULE_8__.z.string(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar toolCallPartSchema = zod__WEBPACK_IMPORTED_MODULE_8__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_8__.z.literal(\"tool-call\"),\n    toolCallId: zod__WEBPACK_IMPORTED_MODULE_8__.z.string(),\n    toolName: zod__WEBPACK_IMPORTED_MODULE_8__.z.string(),\n    args: zod__WEBPACK_IMPORTED_MODULE_8__.z.unknown()\n});\nvar toolResultPartSchema = zod__WEBPACK_IMPORTED_MODULE_8__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_8__.z.literal(\"tool-result\"),\n    toolCallId: zod__WEBPACK_IMPORTED_MODULE_8__.z.string(),\n    toolName: zod__WEBPACK_IMPORTED_MODULE_8__.z.string(),\n    result: zod__WEBPACK_IMPORTED_MODULE_8__.z.unknown(),\n    content: toolResultContentSchema.optional(),\n    isError: zod__WEBPACK_IMPORTED_MODULE_8__.z.boolean().optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\n// core/prompt/message.ts\nvar coreSystemMessageSchema = zod__WEBPACK_IMPORTED_MODULE_8__.z.object({\n    role: zod__WEBPACK_IMPORTED_MODULE_8__.z.literal(\"system\"),\n    content: zod__WEBPACK_IMPORTED_MODULE_8__.z.string(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreUserMessageSchema = zod__WEBPACK_IMPORTED_MODULE_8__.z.object({\n    role: zod__WEBPACK_IMPORTED_MODULE_8__.z.literal(\"user\"),\n    content: zod__WEBPACK_IMPORTED_MODULE_8__.z.union([\n        zod__WEBPACK_IMPORTED_MODULE_8__.z.string(),\n        zod__WEBPACK_IMPORTED_MODULE_8__.z.array(zod__WEBPACK_IMPORTED_MODULE_8__.z.union([\n            textPartSchema,\n            imagePartSchema,\n            filePartSchema\n        ]))\n    ]),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreAssistantMessageSchema = zod__WEBPACK_IMPORTED_MODULE_8__.z.object({\n    role: zod__WEBPACK_IMPORTED_MODULE_8__.z.literal(\"assistant\"),\n    content: zod__WEBPACK_IMPORTED_MODULE_8__.z.union([\n        zod__WEBPACK_IMPORTED_MODULE_8__.z.string(),\n        zod__WEBPACK_IMPORTED_MODULE_8__.z.array(zod__WEBPACK_IMPORTED_MODULE_8__.z.union([\n            textPartSchema,\n            toolCallPartSchema\n        ]))\n    ]),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreToolMessageSchema = zod__WEBPACK_IMPORTED_MODULE_8__.z.object({\n    role: zod__WEBPACK_IMPORTED_MODULE_8__.z.literal(\"tool\"),\n    content: zod__WEBPACK_IMPORTED_MODULE_8__.z.array(toolResultPartSchema),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreMessageSchema = zod__WEBPACK_IMPORTED_MODULE_8__.z.union([\n    coreSystemMessageSchema,\n    coreUserMessageSchema,\n    coreAssistantMessageSchema,\n    coreToolMessageSchema\n]);\n// core/prompt/detect-prompt-type.ts\nfunction detectPromptType(prompt) {\n    if (!Array.isArray(prompt)) {\n        return \"other\";\n    }\n    if (prompt.length === 0) {\n        return \"messages\";\n    }\n    const characteristics = prompt.map(detectSingleMessageCharacteristics);\n    if (characteristics.some((c)=>c === \"has-ui-specific-parts\")) {\n        return \"ui-messages\";\n    } else if (characteristics.every((c)=>c === \"has-core-specific-parts\" || c === \"message\")) {\n        return \"messages\";\n    } else {\n        return \"other\";\n    }\n}\nfunction detectSingleMessageCharacteristics(message) {\n    if (typeof message === \"object\" && message !== null && (message.role === \"function\" || // UI-only role\n    message.role === \"data\" || // UI-only role\n    \"toolInvocations\" in message || // UI-specific field\n    \"experimental_attachments\" in message)) {\n        return \"has-ui-specific-parts\";\n    } else if (typeof message === \"object\" && message !== null && \"content\" in message && (Array.isArray(message.content) || // Core messages can have array content\n    \"experimental_providerMetadata\" in message)) {\n        return \"has-core-specific-parts\";\n    } else if (typeof message === \"object\" && message !== null && \"role\" in message && \"content\" in message && typeof message.content === \"string\" && [\n        \"system\",\n        \"user\",\n        \"assistant\",\n        \"tool\"\n    ].includes(message.role)) {\n        return \"message\";\n    } else {\n        return \"other\";\n    }\n}\n// core/prompt/attachments-to-parts.ts\nfunction attachmentsToParts(attachments) {\n    var _a9, _b, _c;\n    const parts = [];\n    for (const attachment of attachments){\n        let url;\n        try {\n            url = new URL(attachment.url);\n        } catch (error) {\n            throw new Error(`Invalid URL: ${attachment.url}`);\n        }\n        switch(url.protocol){\n            case \"http:\":\n            case \"https:\":\n                {\n                    if ((_a9 = attachment.contentType) == null ? void 0 : _a9.startsWith(\"image/\")) {\n                        parts.push({\n                            type: \"image\",\n                            image: url\n                        });\n                    } else {\n                        if (!attachment.contentType) {\n                            throw new Error(\"If the attachment is not an image, it must specify a content type\");\n                        }\n                        parts.push({\n                            type: \"file\",\n                            data: url,\n                            mimeType: attachment.contentType\n                        });\n                    }\n                    break;\n                }\n            case \"data:\":\n                {\n                    let header;\n                    let base64Content;\n                    let mimeType;\n                    try {\n                        [header, base64Content] = attachment.url.split(\",\");\n                        mimeType = header.split(\";\")[0].split(\":\")[1];\n                    } catch (error) {\n                        throw new Error(`Error processing data URL: ${attachment.url}`);\n                    }\n                    if (mimeType == null || base64Content == null) {\n                        throw new Error(`Invalid data URL format: ${attachment.url}`);\n                    }\n                    if ((_b = attachment.contentType) == null ? void 0 : _b.startsWith(\"image/\")) {\n                        parts.push({\n                            type: \"image\",\n                            image: convertDataContentToUint8Array(base64Content)\n                        });\n                    } else if ((_c = attachment.contentType) == null ? void 0 : _c.startsWith(\"text/\")) {\n                        parts.push({\n                            type: \"text\",\n                            text: convertUint8ArrayToText(convertDataContentToUint8Array(base64Content))\n                        });\n                    } else {\n                        if (!attachment.contentType) {\n                            throw new Error(\"If the attachment is not an image or text, it must specify a content type\");\n                        }\n                        parts.push({\n                            type: \"file\",\n                            data: base64Content,\n                            mimeType: attachment.contentType\n                        });\n                    }\n                    break;\n                }\n            default:\n                {\n                    throw new Error(`Unsupported URL protocol: ${url.protocol}`);\n                }\n        }\n    }\n    return parts;\n}\n// core/prompt/message-conversion-error.ts\n\nvar name5 = \"AI_MessageConversionError\";\nvar marker5 = `vercel.ai.error.${name5}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar MessageConversionError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError {\n    constructor({ originalMessage, message }){\n        super({\n            name: name5,\n            message\n        });\n        this[_a5] = true;\n        this.originalMessage = originalMessage;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError.hasMarker(error, marker5);\n    }\n};\n_a5 = symbol5;\n// core/prompt/convert-to-core-messages.ts\nfunction convertToCoreMessages(messages, options) {\n    var _a9;\n    const tools = (_a9 = options == null ? void 0 : options.tools) != null ? _a9 : {};\n    const coreMessages = [];\n    for (const message of messages){\n        const { role, content, toolInvocations, experimental_attachments } = message;\n        switch(role){\n            case \"system\":\n                {\n                    coreMessages.push({\n                        role: \"system\",\n                        content\n                    });\n                    break;\n                }\n            case \"user\":\n                {\n                    coreMessages.push({\n                        role: \"user\",\n                        content: experimental_attachments ? [\n                            {\n                                type: \"text\",\n                                text: content\n                            },\n                            ...attachmentsToParts(experimental_attachments)\n                        ] : content\n                    });\n                    break;\n                }\n            case \"assistant\":\n                {\n                    if (toolInvocations == null) {\n                        coreMessages.push({\n                            role: \"assistant\",\n                            content\n                        });\n                        break;\n                    }\n                    coreMessages.push({\n                        role: \"assistant\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: content\n                            },\n                            ...toolInvocations.map(({ toolCallId, toolName, args })=>({\n                                    type: \"tool-call\",\n                                    toolCallId,\n                                    toolName,\n                                    args\n                                }))\n                        ]\n                    });\n                    coreMessages.push({\n                        role: \"tool\",\n                        content: toolInvocations.map((toolInvocation)=>{\n                            if (!(\"result\" in toolInvocation)) {\n                                throw new MessageConversionError({\n                                    originalMessage: message,\n                                    message: \"ToolInvocation must have a result: \" + JSON.stringify(toolInvocation)\n                                });\n                            }\n                            const { toolCallId, toolName, result } = toolInvocation;\n                            const tool = tools[toolName];\n                            return (tool == null ? void 0 : tool.experimental_toToolResultContent) != null ? {\n                                type: \"tool-result\",\n                                toolCallId,\n                                toolName,\n                                result: tool.experimental_toToolResultContent(result),\n                                experimental_content: tool.experimental_toToolResultContent(result)\n                            } : {\n                                type: \"tool-result\",\n                                toolCallId,\n                                toolName,\n                                result\n                            };\n                        })\n                    });\n                    break;\n                }\n            case \"function\":\n            case \"data\":\n            case \"tool\":\n                {\n                    break;\n                }\n            default:\n                {\n                    const _exhaustiveCheck = role;\n                    throw new MessageConversionError({\n                        originalMessage: message,\n                        message: `Unsupported role: ${_exhaustiveCheck}`\n                    });\n                }\n        }\n    }\n    return coreMessages;\n}\n// core/prompt/standardize-prompt.ts\nfunction standardizePrompt({ prompt, tools }) {\n    if (prompt.prompt == null && prompt.messages == null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidPromptError({\n            prompt,\n            message: \"prompt or messages must be defined\"\n        });\n    }\n    if (prompt.prompt != null && prompt.messages != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidPromptError({\n            prompt,\n            message: \"prompt and messages cannot be defined at the same time\"\n        });\n    }\n    if (prompt.system != null && typeof prompt.system !== \"string\") {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidPromptError({\n            prompt,\n            message: \"system must be a string\"\n        });\n    }\n    if (prompt.prompt != null) {\n        if (typeof prompt.prompt !== \"string\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidPromptError({\n                prompt,\n                message: \"prompt must be a string\"\n            });\n        }\n        return {\n            type: \"prompt\",\n            system: prompt.system,\n            messages: [\n                {\n                    role: \"user\",\n                    content: prompt.prompt\n                }\n            ]\n        };\n    }\n    if (prompt.messages != null) {\n        const promptType = detectPromptType(prompt.messages);\n        if (promptType === \"other\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidPromptError({\n                prompt,\n                message: \"messages must be an array of CoreMessage or UIMessage\"\n            });\n        }\n        const messages = promptType === \"ui-messages\" ? convertToCoreMessages(prompt.messages, {\n            tools\n        }) : prompt.messages;\n        const validationResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_9__.safeValidateTypes)({\n            value: messages,\n            schema: zod__WEBPACK_IMPORTED_MODULE_8__.z.array(coreMessageSchema)\n        });\n        if (!validationResult.success) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidPromptError({\n                prompt,\n                message: \"messages must be an array of CoreMessage or UIMessage\",\n                cause: validationResult.error\n            });\n        }\n        return {\n            type: \"messages\",\n            messages,\n            system: prompt.system\n        };\n    }\n    throw new Error(\"unreachable\");\n}\n// core/types/usage.ts\nfunction calculateLanguageModelUsage(usage) {\n    return {\n        promptTokens: usage.promptTokens,\n        completionTokens: usage.completionTokens,\n        totalTokens: usage.promptTokens + usage.completionTokens\n    };\n}\n// errors/invalid-tool-arguments-error.ts\n\nvar name6 = \"AI_InvalidToolArgumentsError\";\nvar marker6 = `vercel.ai.error.${name6}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar InvalidToolArgumentsError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError {\n    constructor({ toolArgs, toolName, cause, message = `Invalid arguments for tool ${toolName}: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.getErrorMessage)(cause)}` }){\n        super({\n            name: name6,\n            message,\n            cause\n        });\n        this[_a6] = true;\n        this.toolArgs = toolArgs;\n        this.toolName = toolName;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError.hasMarker(error, marker6);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidToolArgumentsError(error) {\n        return error instanceof Error && error.name === name6 && typeof error.toolName === \"string\" && typeof error.toolArgs === \"string\";\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            cause: this.cause,\n            stack: this.stack,\n            toolName: this.toolName,\n            toolArgs: this.toolArgs\n        };\n    }\n};\n_a6 = symbol6;\n// errors/no-such-tool-error.ts\n\nvar name7 = \"AI_NoSuchToolError\";\nvar marker7 = `vercel.ai.error.${name7}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar NoSuchToolError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError {\n    constructor({ toolName, availableTools = void 0, message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? \"No tools are available.\" : `Available tools: ${availableTools.join(\", \")}.`}` }){\n        super({\n            name: name7,\n            message\n        });\n        this[_a7] = true;\n        this.toolName = toolName;\n        this.availableTools = availableTools;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError.hasMarker(error, marker7);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isNoSuchToolError(error) {\n        return error instanceof Error && error.name === name7 && \"toolName\" in error && error.toolName != void 0 && typeof error.name === \"string\";\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            toolName: this.toolName,\n            availableTools: this.availableTools\n        };\n    }\n};\n_a7 = symbol7;\n// util/is-async-generator.ts\nfunction isAsyncGenerator(value) {\n    return value != null && typeof value === \"object\" && Symbol.asyncIterator in value;\n}\n// util/is-generator.ts\nfunction isGenerator(value) {\n    return value != null && typeof value === \"object\" && Symbol.iterator in value;\n}\n// util/retry-with-exponential-backoff.ts\n\n\n// util/delay.ts\nasync function delay(delayInMs) {\n    return delayInMs === void 0 ? Promise.resolve() : new Promise((resolve)=>setTimeout(resolve, delayInMs));\n}\n// util/retry-error.ts\n\nvar name8 = \"AI_RetryError\";\nvar marker8 = `vercel.ai.error.${name8}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar RetryError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError {\n    constructor({ message, reason, errors }){\n        super({\n            name: name8,\n            message\n        });\n        this[_a8] = true;\n        this.reason = reason;\n        this.errors = errors;\n        this.lastError = errors[errors.length - 1];\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError.hasMarker(error, marker8);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isRetryError(error) {\n        return error instanceof Error && error.name === name8 && typeof error.reason === \"string\" && Array.isArray(error.errors);\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            reason: this.reason,\n            lastError: this.lastError,\n            errors: this.errors\n        };\n    }\n};\n_a8 = symbol8;\n// util/retry-with-exponential-backoff.ts\nvar retryWithExponentialBackoff = ({ maxRetries = 2, initialDelayInMs = 2e3, backoffFactor = 2 } = {})=>async (f)=>_retryWithExponentialBackoff(f, {\n            maxRetries,\n            delayInMs: initialDelayInMs,\n            backoffFactor\n        });\nasync function _retryWithExponentialBackoff(f, { maxRetries, delayInMs, backoffFactor }, errors = []) {\n    try {\n        return await f();\n    } catch (error) {\n        if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_9__.isAbortError)(error)) {\n            throw error;\n        }\n        if (maxRetries === 0) {\n            throw error;\n        }\n        const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_9__.getErrorMessage)(error);\n        const newErrors = [\n            ...errors,\n            error\n        ];\n        const tryNumber = newErrors.length;\n        if (tryNumber > maxRetries) {\n            throw new RetryError({\n                message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n                reason: \"maxRetriesExceeded\",\n                errors: newErrors\n            });\n        }\n        if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.APICallError.isAPICallError(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n            await delay(delayInMs);\n            return _retryWithExponentialBackoff(f, {\n                maxRetries,\n                delayInMs: backoffFactor * delayInMs,\n                backoffFactor\n            }, newErrors);\n        }\n        if (tryNumber === 1) {\n            throw error;\n        }\n        throw new RetryError({\n            message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n            reason: \"errorNotRetryable\",\n            errors: newErrors\n        });\n    }\n}\n// util/constants.ts\nvar HANGING_STREAM_WARNING_TIME_MS = 15 * 1e3;\n// rsc/streamable-ui/create-suspended-chunk.tsx\n\n\nvar R = [\n    async ({ c: current, n: next })=>{\n        const chunk = await next;\n        if (chunk.done) {\n            return chunk.value;\n        }\n        if (chunk.append) {\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {\n                children: [\n                    current,\n                    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react__WEBPACK_IMPORTED_MODULE_4__.Suspense, {\n                        fallback: chunk.value,\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(R, {\n                            c: chunk.value,\n                            n: chunk.next\n                        })\n                    })\n                ]\n            });\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react__WEBPACK_IMPORTED_MODULE_4__.Suspense, {\n            fallback: chunk.value,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(R, {\n                c: chunk.value,\n                n: chunk.next\n            })\n        });\n    }\n][0];\nfunction createSuspendedChunk(initialValue) {\n    const { promise, resolve, reject } = createResolvablePromise();\n    return {\n        row: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react__WEBPACK_IMPORTED_MODULE_4__.Suspense, {\n            fallback: initialValue,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(R, {\n                c: initialValue,\n                n: promise\n            })\n        }),\n        resolve,\n        reject\n    };\n}\n// rsc/streamable-ui/create-streamable-ui.tsx\nfunction createStreamableUI(initialValue) {\n    let currentValue = initialValue;\n    let closed = false;\n    let { row, resolve, reject } = createSuspendedChunk(initialValue);\n    function assertStream(method) {\n        if (closed) {\n            throw new Error(method + \": UI stream is already closed.\");\n        }\n    }\n    let warningTimeout;\n    function warnUnclosedStream() {\n        if (true) {\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            warningTimeout = setTimeout(()=>{\n                console.warn(\"The streamable UI has been slow to update. This may be a bug or a performance issue or you forgot to call `.done()`.\");\n            }, HANGING_STREAM_WARNING_TIME_MS);\n        }\n    }\n    warnUnclosedStream();\n    const streamable2 = {\n        value: row,\n        update (value) {\n            assertStream(\".update()\");\n            if (value === currentValue) {\n                warnUnclosedStream();\n                return streamable2;\n            }\n            const resolvable = createResolvablePromise();\n            currentValue = value;\n            resolve({\n                value: currentValue,\n                done: false,\n                next: resolvable.promise\n            });\n            resolve = resolvable.resolve;\n            reject = resolvable.reject;\n            warnUnclosedStream();\n            return streamable2;\n        },\n        append (value) {\n            assertStream(\".append()\");\n            const resolvable = createResolvablePromise();\n            currentValue = value;\n            resolve({\n                value,\n                done: false,\n                append: true,\n                next: resolvable.promise\n            });\n            resolve = resolvable.resolve;\n            reject = resolvable.reject;\n            warnUnclosedStream();\n            return streamable2;\n        },\n        error (error) {\n            assertStream(\".error()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            reject(error);\n            return streamable2;\n        },\n        done (...args) {\n            assertStream(\".done()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            if (args.length) {\n                resolve({\n                    value: args[0],\n                    done: true\n                });\n                return streamable2;\n            }\n            resolve({\n                value: currentValue,\n                done: true\n            });\n            return streamable2;\n        }\n    };\n    return streamable2;\n}\n// rsc/stream-ui/stream-ui.tsx\nvar defaultTextRenderer = ({ content })=>content;\nasync function streamUI({ model, tools, toolChoice, system, prompt, messages, maxRetries, abortSignal, headers, initial, text, experimental_providerMetadata: providerMetadata, onFinish, ...settings }) {\n    if (typeof model === \"string\") {\n        throw new Error(\"`model` cannot be a string in `streamUI`. Use the actual model instance instead.\");\n    }\n    if (\"functions\" in settings) {\n        throw new Error(\"`functions` is not supported in `streamUI`, use `tools` instead.\");\n    }\n    if (\"provider\" in settings) {\n        throw new Error(\"`provider` is no longer needed in `streamUI`. Use `model` instead.\");\n    }\n    if (tools) {\n        for (const [name9, tool] of Object.entries(tools)){\n            if (\"render\" in tool) {\n                throw new Error(\"Tool definition in `streamUI` should not have `render` property. Use `generate` instead. Found in tool: \" + name9);\n            }\n        }\n    }\n    const ui = createStreamableUI(initial);\n    const textRender = text || defaultTextRenderer;\n    let finished;\n    let finishEvent = null;\n    async function render2({ args, renderer, streamableUI, isLastCall = false }) {\n        if (!renderer) return;\n        const renderFinished = createResolvablePromise();\n        finished = finished ? finished.then(()=>renderFinished.promise) : renderFinished.promise;\n        const rendererResult = renderer(...args);\n        if (isAsyncGenerator(rendererResult) || isGenerator(rendererResult)) {\n            while(true){\n                const { done, value } = await rendererResult.next();\n                const node = await value;\n                if (isLastCall && done) {\n                    streamableUI.done(node);\n                } else {\n                    streamableUI.update(node);\n                }\n                if (done) break;\n            }\n        } else {\n            const node = await rendererResult;\n            if (isLastCall) {\n                streamableUI.done(node);\n            } else {\n                streamableUI.update(node);\n            }\n        }\n        renderFinished.resolve(void 0);\n    }\n    const retry = retryWithExponentialBackoff({\n        maxRetries\n    });\n    const validatedPrompt = standardizePrompt({\n        prompt: {\n            system,\n            prompt,\n            messages\n        },\n        tools: void 0\n    });\n    const result = await retry(async ()=>model.doStream({\n            mode: {\n                type: \"regular\",\n                ...prepareToolsAndToolChoice({\n                    tools,\n                    toolChoice,\n                    activeTools: void 0\n                })\n            },\n            ...prepareCallSettings(settings),\n            inputFormat: validatedPrompt.type,\n            prompt: await convertToLanguageModelPrompt({\n                prompt: validatedPrompt,\n                modelSupportsImageUrls: model.supportsImageUrls,\n                modelSupportsUrl: model.supportsUrl\n            }),\n            providerMetadata,\n            abortSignal,\n            headers\n        }));\n    const [stream, forkedStream] = result.stream.tee();\n    (async ()=>{\n        try {\n            let content = \"\";\n            let hasToolCall = false;\n            const reader = forkedStream.getReader();\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) break;\n                switch(value.type){\n                    case \"text-delta\":\n                        {\n                            content += value.textDelta;\n                            render2({\n                                renderer: textRender,\n                                args: [\n                                    {\n                                        content,\n                                        done: false,\n                                        delta: value.textDelta\n                                    }\n                                ],\n                                streamableUI: ui\n                            });\n                            break;\n                        }\n                    case \"tool-call-delta\":\n                        {\n                            hasToolCall = true;\n                            break;\n                        }\n                    case \"tool-call\":\n                        {\n                            const toolName = value.toolName;\n                            if (!tools) {\n                                throw new NoSuchToolError({\n                                    toolName\n                                });\n                            }\n                            const tool = tools[toolName];\n                            if (!tool) {\n                                throw new NoSuchToolError({\n                                    toolName,\n                                    availableTools: Object.keys(tools)\n                                });\n                            }\n                            hasToolCall = true;\n                            const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_9__.safeParseJSON)({\n                                text: value.args,\n                                schema: tool.parameters\n                            });\n                            if (parseResult.success === false) {\n                                throw new InvalidToolArgumentsError({\n                                    toolName,\n                                    toolArgs: value.args,\n                                    cause: parseResult.error\n                                });\n                            }\n                            render2({\n                                renderer: tool.generate,\n                                args: [\n                                    parseResult.value,\n                                    {\n                                        toolName,\n                                        toolCallId: value.toolCallId\n                                    }\n                                ],\n                                streamableUI: ui,\n                                isLastCall: true\n                            });\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            throw value.error;\n                        }\n                    case \"finish\":\n                        {\n                            finishEvent = {\n                                finishReason: value.finishReason,\n                                usage: calculateLanguageModelUsage(value.usage),\n                                warnings: result.warnings,\n                                rawResponse: result.rawResponse\n                            };\n                            break;\n                        }\n                }\n            }\n            if (!hasToolCall) {\n                render2({\n                    renderer: textRender,\n                    args: [\n                        {\n                            content,\n                            done: true\n                        }\n                    ],\n                    streamableUI: ui,\n                    isLastCall: true\n                });\n            }\n            await finished;\n            if (finishEvent && onFinish) {\n                await onFinish({\n                    ...finishEvent,\n                    value: ui.value\n                });\n            }\n        } catch (error) {\n            ui.error(error);\n        }\n    })();\n    return {\n        ...result,\n        stream,\n        value: ui.value\n    };\n}\n// rsc/stream-ui/render.ts\n\n// streams/ai-stream.ts\n\nfunction createEventStreamTransformer(customParser) {\n    const textDecoder = new TextDecoder();\n    let eventSourceParser;\n    return new TransformStream({\n        async start (controller) {\n            eventSourceParser = (0,eventsource_parser__WEBPACK_IMPORTED_MODULE_12__.createParser)((event)=>{\n                if (\"data\" in event && event.type === \"event\" && event.data === \"[DONE]\" || // Replicate doesn't send [DONE] but does send a 'done' event\n                // @see https://replicate.com/docs/streaming\n                event.event === \"done\") {\n                    controller.terminate();\n                    return;\n                }\n                if (\"data\" in event) {\n                    const parsedMessage = customParser ? customParser(event.data, {\n                        event: event.event\n                    }) : event.data;\n                    if (parsedMessage) controller.enqueue(parsedMessage);\n                }\n            });\n        },\n        transform (chunk) {\n            eventSourceParser.feed(textDecoder.decode(chunk));\n        }\n    });\n}\nfunction createCallbacksTransformer(cb) {\n    const textEncoder = new TextEncoder();\n    let aggregatedResponse = \"\";\n    const callbacks = cb || {};\n    return new TransformStream({\n        async start () {\n            if (callbacks.onStart) await callbacks.onStart();\n        },\n        async transform (message, controller) {\n            const content = typeof message === \"string\" ? message : message.content;\n            controller.enqueue(textEncoder.encode(content));\n            aggregatedResponse += content;\n            if (callbacks.onToken) await callbacks.onToken(content);\n            if (callbacks.onText && typeof message === \"string\") {\n                await callbacks.onText(message);\n            }\n        },\n        async flush () {\n            const isOpenAICallbacks = isOfTypeOpenAIStreamCallbacks(callbacks);\n            if (callbacks.onCompletion) {\n                await callbacks.onCompletion(aggregatedResponse);\n            }\n            if (callbacks.onFinal && !isOpenAICallbacks) {\n                await callbacks.onFinal(aggregatedResponse);\n            }\n        }\n    });\n}\nfunction isOfTypeOpenAIStreamCallbacks(callbacks) {\n    return \"experimental_onFunctionCall\" in callbacks;\n}\nfunction trimStartOfStreamHelper() {\n    let isStreamStart = true;\n    return (text)=>{\n        if (isStreamStart) {\n            text = text.trimStart();\n            if (text) isStreamStart = false;\n        }\n        return text;\n    };\n}\nfunction AIStream(response, customParser, callbacks) {\n    if (!response.ok) {\n        if (response.body) {\n            const reader = response.body.getReader();\n            return new ReadableStream({\n                async start (controller) {\n                    const { done, value } = await reader.read();\n                    if (!done) {\n                        const errorText = new TextDecoder().decode(value);\n                        controller.error(new Error(`Response error: ${errorText}`));\n                    }\n                }\n            });\n        } else {\n            return new ReadableStream({\n                start (controller) {\n                    controller.error(new Error(\"Response error: No response body\"));\n                }\n            });\n        }\n    }\n    const responseBodyStream = response.body || createEmptyReadableStream();\n    return responseBodyStream.pipeThrough(createEventStreamTransformer(customParser)).pipeThrough(createCallbacksTransformer(callbacks));\n}\nfunction createEmptyReadableStream() {\n    return new ReadableStream({\n        start (controller) {\n            controller.close();\n        }\n    });\n}\nfunction readableFromAsyncIterable(iterable) {\n    let it = iterable[Symbol.asyncIterator]();\n    return new ReadableStream({\n        async pull (controller) {\n            const { done, value } = await it.next();\n            if (done) controller.close();\n            else controller.enqueue(value);\n        },\n        async cancel (reason) {\n            var _a9;\n            await ((_a9 = it.return) == null ? void 0 : _a9.call(it, reason));\n        }\n    });\n}\n// streams/stream-data.ts\n\nfunction createStreamDataTransformer() {\n    const encoder = new TextEncoder();\n    const decoder = new TextDecoder();\n    return new TransformStream({\n        transform: async (chunk, controller)=>{\n            const message = decoder.decode(chunk);\n            controller.enqueue(encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_10__.formatStreamPart)(\"text\", message)));\n        }\n    });\n}\n// streams/openai-stream.ts\n\nfunction parseOpenAIStream() {\n    const extract = chunkToText();\n    return (data)=>extract(JSON.parse(data));\n}\nasync function* streamable(stream) {\n    const extract = chunkToText();\n    for await (let chunk of stream){\n        if (\"promptFilterResults\" in chunk) {\n            chunk = {\n                id: chunk.id,\n                created: chunk.created.getDate(),\n                object: chunk.object,\n                // not exposed by Azure API\n                model: chunk.model,\n                // not exposed by Azure API\n                choices: chunk.choices.map((choice)=>{\n                    var _a9, _b, _c, _d, _e, _f, _g;\n                    return {\n                        delta: {\n                            content: (_a9 = choice.delta) == null ? void 0 : _a9.content,\n                            function_call: (_b = choice.delta) == null ? void 0 : _b.functionCall,\n                            role: (_c = choice.delta) == null ? void 0 : _c.role,\n                            tool_calls: ((_e = (_d = choice.delta) == null ? void 0 : _d.toolCalls) == null ? void 0 : _e.length) ? (_g = (_f = choice.delta) == null ? void 0 : _f.toolCalls) == null ? void 0 : _g.map((toolCall, index)=>({\n                                    index,\n                                    id: toolCall.id,\n                                    function: toolCall.function,\n                                    type: toolCall.type\n                                })) : void 0\n                        },\n                        finish_reason: choice.finishReason,\n                        index: choice.index\n                    };\n                })\n            };\n        }\n        const text = extract(chunk);\n        if (text) yield text;\n    }\n}\nfunction chunkToText() {\n    const trimStartOfStream = trimStartOfStreamHelper();\n    let isFunctionStreamingIn;\n    return (json)=>{\n        var _a9, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;\n        if (isChatCompletionChunk(json)) {\n            const delta = (_a9 = json.choices[0]) == null ? void 0 : _a9.delta;\n            if ((_b = delta.function_call) == null ? void 0 : _b.name) {\n                isFunctionStreamingIn = true;\n                return {\n                    isText: false,\n                    content: `{\"function_call\": {\"name\": \"${delta.function_call.name}\", \"arguments\": \"`\n                };\n            } else if ((_e = (_d = (_c = delta.tool_calls) == null ? void 0 : _c[0]) == null ? void 0 : _d.function) == null ? void 0 : _e.name) {\n                isFunctionStreamingIn = true;\n                const toolCall = delta.tool_calls[0];\n                if (toolCall.index === 0) {\n                    return {\n                        isText: false,\n                        content: `{\"tool_calls\":[ {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_f = toolCall.function) == null ? void 0 : _f.name}\", \"arguments\": \"`\n                    };\n                } else {\n                    return {\n                        isText: false,\n                        content: `\"}}, {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_g = toolCall.function) == null ? void 0 : _g.name}\", \"arguments\": \"`\n                    };\n                }\n            } else if ((_h = delta.function_call) == null ? void 0 : _h.arguments) {\n                return {\n                    isText: false,\n                    content: cleanupArguments((_i = delta.function_call) == null ? void 0 : _i.arguments)\n                };\n            } else if ((_l = (_k = (_j = delta.tool_calls) == null ? void 0 : _j[0]) == null ? void 0 : _k.function) == null ? void 0 : _l.arguments) {\n                return {\n                    isText: false,\n                    content: cleanupArguments((_o = (_n = (_m = delta.tool_calls) == null ? void 0 : _m[0]) == null ? void 0 : _n.function) == null ? void 0 : _o.arguments)\n                };\n            } else if (isFunctionStreamingIn && (((_p = json.choices[0]) == null ? void 0 : _p.finish_reason) === \"function_call\" || ((_q = json.choices[0]) == null ? void 0 : _q.finish_reason) === \"stop\")) {\n                isFunctionStreamingIn = false;\n                return {\n                    isText: false,\n                    content: '\"}}'\n                };\n            } else if (isFunctionStreamingIn && ((_r = json.choices[0]) == null ? void 0 : _r.finish_reason) === \"tool_calls\") {\n                isFunctionStreamingIn = false;\n                return {\n                    isText: false,\n                    content: '\"}}]}'\n                };\n            }\n        }\n        const text = trimStartOfStream(isChatCompletionChunk(json) && json.choices[0].delta.content ? json.choices[0].delta.content : isCompletion(json) ? json.choices[0].text : \"\");\n        return text;\n    };\n    function cleanupArguments(argumentChunk) {\n        let escapedPartialJson = argumentChunk.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\//g, \"\\\\/\").replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\f/g, \"\\\\f\");\n        return `${escapedPartialJson}`;\n    }\n}\nvar __internal__OpenAIFnMessagesSymbol = Symbol(\"internal_openai_fn_messages\");\nfunction isChatCompletionChunk(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"delta\" in data.choices[0];\n}\nfunction isCompletion(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"text\" in data.choices[0];\n}\nfunction OpenAIStream(res, callbacks) {\n    const cb = callbacks;\n    let stream;\n    if (Symbol.asyncIterator in res) {\n        stream = readableFromAsyncIterable(streamable(res)).pipeThrough(createCallbacksTransformer((cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        }));\n    } else {\n        stream = AIStream(res, parseOpenAIStream(), (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        });\n    }\n    if (cb && (cb.experimental_onFunctionCall || cb.experimental_onToolCall)) {\n        const functionCallTransformer = createFunctionCallTransformer(cb);\n        return stream.pipeThrough(functionCallTransformer);\n    } else {\n        return stream.pipeThrough(createStreamDataTransformer());\n    }\n}\nfunction createFunctionCallTransformer(callbacks) {\n    const textEncoder = new TextEncoder();\n    let isFirstChunk = true;\n    let aggregatedResponse = \"\";\n    let aggregatedFinalCompletionResponse = \"\";\n    let isFunctionStreamingIn = false;\n    let functionCallMessages = callbacks[__internal__OpenAIFnMessagesSymbol] || [];\n    const decode = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_10__.createChunkDecoder)();\n    return new TransformStream({\n        async transform (chunk, controller) {\n            const message = decode(chunk);\n            aggregatedFinalCompletionResponse += message;\n            const shouldHandleAsFunction = isFirstChunk && (message.startsWith('{\"function_call\":') || message.startsWith('{\"tool_calls\":'));\n            if (shouldHandleAsFunction) {\n                isFunctionStreamingIn = true;\n                aggregatedResponse += message;\n                isFirstChunk = false;\n                return;\n            }\n            if (!isFunctionStreamingIn) {\n                controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_10__.formatStreamPart)(\"text\", message)));\n                return;\n            } else {\n                aggregatedResponse += message;\n            }\n        },\n        async flush (controller) {\n            try {\n                if (!isFirstChunk && isFunctionStreamingIn && (callbacks.experimental_onFunctionCall || callbacks.experimental_onToolCall)) {\n                    isFunctionStreamingIn = false;\n                    const payload = JSON.parse(aggregatedResponse);\n                    let newFunctionCallMessages = [\n                        ...functionCallMessages\n                    ];\n                    let functionResponse = void 0;\n                    if (callbacks.experimental_onFunctionCall) {\n                        if (payload.function_call === void 0) {\n                            console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                        }\n                        const argumentsPayload = JSON.parse(payload.function_call.arguments);\n                        functionResponse = await callbacks.experimental_onFunctionCall({\n                            name: payload.function_call.name,\n                            arguments: argumentsPayload\n                        }, (result)=>{\n                            newFunctionCallMessages = [\n                                ...functionCallMessages,\n                                {\n                                    role: \"assistant\",\n                                    content: \"\",\n                                    function_call: payload.function_call\n                                },\n                                {\n                                    role: \"function\",\n                                    name: payload.function_call.name,\n                                    content: JSON.stringify(result)\n                                }\n                            ];\n                            return newFunctionCallMessages;\n                        });\n                    }\n                    if (callbacks.experimental_onToolCall) {\n                        const toolCalls = {\n                            tools: []\n                        };\n                        for (const tool of payload.tool_calls){\n                            toolCalls.tools.push({\n                                id: tool.id,\n                                type: \"function\",\n                                func: {\n                                    name: tool.function.name,\n                                    arguments: JSON.parse(tool.function.arguments)\n                                }\n                            });\n                        }\n                        let responseIndex = 0;\n                        try {\n                            functionResponse = await callbacks.experimental_onToolCall(toolCalls, (result)=>{\n                                if (result) {\n                                    const { tool_call_id, function_name, tool_call_result } = result;\n                                    newFunctionCallMessages = [\n                                        ...newFunctionCallMessages,\n                                        // Only append the assistant message if it's the first response\n                                        ...responseIndex === 0 ? [\n                                            {\n                                                role: \"assistant\",\n                                                content: \"\",\n                                                tool_calls: payload.tool_calls.map((tc)=>({\n                                                        id: tc.id,\n                                                        type: \"function\",\n                                                        function: {\n                                                            name: tc.function.name,\n                                                            // we send the arguments an object to the user, but as the API expects a string, we need to stringify it\n                                                            arguments: JSON.stringify(tc.function.arguments)\n                                                        }\n                                                    }))\n                                            }\n                                        ] : [],\n                                        // Append the function call result message\n                                        {\n                                            role: \"tool\",\n                                            tool_call_id,\n                                            name: function_name,\n                                            content: JSON.stringify(tool_call_result)\n                                        }\n                                    ];\n                                    responseIndex++;\n                                }\n                                return newFunctionCallMessages;\n                            });\n                        } catch (e) {\n                            console.error(\"Error calling experimental_onToolCall:\", e);\n                        }\n                    }\n                    if (!functionResponse) {\n                        controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_10__.formatStreamPart)(payload.function_call ? \"function_call\" : \"tool_calls\", // parse to prevent double-encoding:\n                        JSON.parse(aggregatedResponse))));\n                        return;\n                    } else if (typeof functionResponse === \"string\") {\n                        controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_10__.formatStreamPart)(\"text\", functionResponse)));\n                        aggregatedFinalCompletionResponse = functionResponse;\n                        return;\n                    }\n                    const filteredCallbacks = {\n                        ...callbacks,\n                        onStart: void 0\n                    };\n                    callbacks.onFinal = void 0;\n                    const openAIStream = OpenAIStream(functionResponse, {\n                        ...filteredCallbacks,\n                        [__internal__OpenAIFnMessagesSymbol]: newFunctionCallMessages\n                    });\n                    const reader = openAIStream.getReader();\n                    while(true){\n                        const { done, value } = await reader.read();\n                        if (done) {\n                            break;\n                        }\n                        controller.enqueue(value);\n                    }\n                }\n            } finally{\n                if (callbacks.onFinal && aggregatedFinalCompletionResponse) {\n                    await callbacks.onFinal(aggregatedFinalCompletionResponse);\n                }\n            }\n        }\n    });\n}\n// util/consume-stream.ts\nasync function consumeStream(stream) {\n    const reader = stream.getReader();\n    while(true){\n        const { done } = await reader.read();\n        if (done) break;\n    }\n}\n// rsc/stream-ui/render.ts\nfunction render(options) {\n    const ui = createStreamableUI(options.initial);\n    const text = options.text ? options.text : ({ content })=>content;\n    const functions = options.functions ? Object.entries(options.functions).map(([name9, { description, parameters }])=>{\n        return {\n            name: name9,\n            description,\n            parameters: (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(parameters)\n        };\n    }) : void 0;\n    const tools = options.tools ? Object.entries(options.tools).map(([name9, { description, parameters }])=>{\n        return {\n            type: \"function\",\n            function: {\n                name: name9,\n                description,\n                parameters: (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(parameters)\n            }\n        };\n    }) : void 0;\n    if (functions && tools) {\n        throw new Error(\"You can't have both functions and tools defined. Please choose one or the other.\");\n    }\n    let finished;\n    async function handleRender(args, renderer, res) {\n        if (!renderer) return;\n        const resolvable = createResolvablePromise();\n        if (finished) {\n            finished = finished.then(()=>resolvable.promise);\n        } else {\n            finished = resolvable.promise;\n        }\n        const value = renderer(args);\n        if (value instanceof Promise || value && typeof value === \"object\" && \"then\" in value && typeof value.then === \"function\") {\n            const node = await value;\n            res.update(node);\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.asyncIterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = await it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.iterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else {\n            res.update(value);\n            resolvable.resolve(void 0);\n        }\n    }\n    (async ()=>{\n        let hasFunction = false;\n        let content = \"\";\n        consumeStream(OpenAIStream(await options.provider.chat.completions.create({\n            model: options.model,\n            messages: options.messages,\n            temperature: options.temperature,\n            stream: true,\n            ...functions ? {\n                functions\n            } : {},\n            ...tools ? {\n                tools\n            } : {}\n        }), {\n            ...functions ? {\n                async experimental_onFunctionCall (functionCallPayload) {\n                    var _a9, _b;\n                    hasFunction = true;\n                    handleRender(functionCallPayload.arguments, (_b = (_a9 = options.functions) == null ? void 0 : _a9[functionCallPayload.name]) == null ? void 0 : _b.render, ui);\n                }\n            } : {},\n            ...tools ? {\n                async experimental_onToolCall (toolCallPayload) {\n                    var _a9, _b;\n                    hasFunction = true;\n                    for (const tool of toolCallPayload.tools){\n                        handleRender(tool.func.arguments, (_b = (_a9 = options.tools) == null ? void 0 : _a9[tool.func.name]) == null ? void 0 : _b.render, ui);\n                    }\n                }\n            } : {},\n            onText (chunk) {\n                content += chunk;\n                handleRender({\n                    content,\n                    done: false,\n                    delta: chunk\n                }, text, ui);\n            },\n            async onFinal () {\n                if (hasFunction) {\n                    await finished;\n                    ui.done();\n                    return;\n                }\n                handleRender({\n                    content,\n                    done: true\n                }, text, ui);\n                await finished;\n                ui.done();\n            }\n        }));\n    })();\n    return ui.value;\n}\n// rsc/streamable-value/streamable-value.ts\nvar STREAMABLE_VALUE_TYPE = Symbol.for(\"ui.streamable.value\");\n// rsc/streamable-value/create-streamable-value.ts\nvar STREAMABLE_VALUE_INTERNAL_LOCK = Symbol(\"streamable.value.lock\");\nfunction createStreamableValue(initialValue) {\n    const isReadableStream = initialValue instanceof ReadableStream || typeof initialValue === \"object\" && initialValue !== null && \"getReader\" in initialValue && typeof initialValue.getReader === \"function\" && \"locked\" in initialValue && typeof initialValue.locked === \"boolean\";\n    if (!isReadableStream) {\n        return createStreamableValueImpl(initialValue);\n    }\n    const streamableValue = createStreamableValueImpl();\n    streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = true;\n    (async ()=>{\n        try {\n            const reader = initialValue.getReader();\n            while(true){\n                const { value, done } = await reader.read();\n                if (done) {\n                    break;\n                }\n                streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n                if (typeof value === \"string\") {\n                    streamableValue.append(value);\n                } else {\n                    streamableValue.update(value);\n                }\n                streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = true;\n            }\n            streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n            streamableValue.done();\n        } catch (e) {\n            streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n            streamableValue.error(e);\n        }\n    })();\n    return streamableValue;\n}\nfunction createStreamableValueImpl(initialValue) {\n    let closed = false;\n    let locked = false;\n    let resolvable = createResolvablePromise();\n    let currentValue = initialValue;\n    let currentError;\n    let currentPromise = resolvable.promise;\n    let currentPatchValue;\n    function assertStream(method) {\n        if (closed) {\n            throw new Error(method + \": Value stream is already closed.\");\n        }\n        if (locked) {\n            throw new Error(method + \": Value stream is locked and cannot be updated.\");\n        }\n    }\n    let warningTimeout;\n    function warnUnclosedStream() {\n        if (true) {\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            warningTimeout = setTimeout(()=>{\n                console.warn(\"The streamable value has been slow to update. This may be a bug or a performance issue or you forgot to call `.done()`.\");\n            }, HANGING_STREAM_WARNING_TIME_MS);\n        }\n    }\n    warnUnclosedStream();\n    function createWrapped(initialChunk) {\n        let init;\n        if (currentError !== void 0) {\n            init = {\n                error: currentError\n            };\n        } else {\n            if (currentPatchValue && !initialChunk) {\n                init = {\n                    diff: currentPatchValue\n                };\n            } else {\n                init = {\n                    curr: currentValue\n                };\n            }\n        }\n        if (currentPromise) {\n            init.next = currentPromise;\n        }\n        if (initialChunk) {\n            init.type = STREAMABLE_VALUE_TYPE;\n        }\n        return init;\n    }\n    function updateValueStates(value) {\n        currentPatchValue = void 0;\n        if (typeof value === \"string\") {\n            if (typeof currentValue === \"string\") {\n                if (value.startsWith(currentValue)) {\n                    currentPatchValue = [\n                        0,\n                        value.slice(currentValue.length)\n                    ];\n                }\n            }\n        }\n        currentValue = value;\n    }\n    const streamable2 = {\n        set [STREAMABLE_VALUE_INTERNAL_LOCK] (state){\n            locked = state;\n        },\n        get value () {\n            return createWrapped(true);\n        },\n        update (value) {\n            assertStream(\".update()\");\n            const resolvePrevious = resolvable.resolve;\n            resolvable = createResolvablePromise();\n            updateValueStates(value);\n            currentPromise = resolvable.promise;\n            resolvePrevious(createWrapped());\n            warnUnclosedStream();\n            return streamable2;\n        },\n        append (value) {\n            assertStream(\".append()\");\n            if (typeof currentValue !== \"string\" && typeof currentValue !== \"undefined\") {\n                throw new Error(`.append(): The current value is not a string. Received: ${typeof currentValue}`);\n            }\n            if (typeof value !== \"string\") {\n                throw new Error(`.append(): The value is not a string. Received: ${typeof value}`);\n            }\n            const resolvePrevious = resolvable.resolve;\n            resolvable = createResolvablePromise();\n            if (typeof currentValue === \"string\") {\n                currentPatchValue = [\n                    0,\n                    value\n                ];\n                currentValue = currentValue + value;\n            } else {\n                currentPatchValue = void 0;\n                currentValue = value;\n            }\n            currentPromise = resolvable.promise;\n            resolvePrevious(createWrapped());\n            warnUnclosedStream();\n            return streamable2;\n        },\n        error (error) {\n            assertStream(\".error()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            currentError = error;\n            currentPromise = void 0;\n            resolvable.resolve({\n                error\n            });\n            return streamable2;\n        },\n        done (...args) {\n            assertStream(\".done()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            currentPromise = void 0;\n            if (args.length) {\n                updateValueStates(args[0]);\n                resolvable.resolve(createWrapped());\n                return streamable2;\n            }\n            resolvable.resolve({});\n            return streamable2;\n        }\n    };\n    return streamable2;\n}\n //# sourceMappingURL=rsc-server.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9haS9yc2MvZGlzdC9yc2Mtc2VydmVyLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ0c7O0FDUTNCLFNBQVMsMEJBSWQ7SUFDQSxJQUFJO0lBQ0osSUFBSTtJQUVKLE1BQU0sVUFBVSxJQUFJLFFBQVcsQ0FBQyxLQUFLO1FBQ25DLFVBQVU7UUFDVixTQUFTO0lBQ1gsQ0FBQztJQUVELE9BQU87UUFDTDtRQUNBO1FBQ0E7SUFDRjtBQUNGOztBQ3JCTyxJQUFNLGFBQWEsQ0FBQyxRQUN6QixPQUFPLFVBQVU7O0FGT25CLElBQU0sc0JBQXNCLElBQUksMERBQWlCLENBTzlDO1NBRU0sdUJBQXVCLFNBQWlCO0lBQy9DLE1BQU0sUUFBUSxvQkFBb0IsU0FBUztJQUMzQyxJQUFJLENBQUMsT0FBTztRQUNWLE1BQU0sSUFBSSxNQUFNLE9BQU87SUFDekI7SUFDQSxPQUFPO0FBQ1Q7QUFFTyxTQUFTLFlBQ2QsU0FBRSxRQUFPLFFBQVEsR0FDakIsSUFDRztJQUNILE9BQU8sb0JBQW9CLElBQ3pCO1FBQ0UsY0FBYyxLQUFLLE1BQU0sS0FBSyxVQUFVLEtBQUssQ0FBQztRQUFBO1FBQzlDLGVBQWU7UUFDZixRQUFRO1FBQ1I7SUFDRixHQUNBO0FBRUo7QUFFTyxTQUFTLHlCQUF5QjtJQUN2QyxNQUFNLFFBQVEsdUJBQXVCLDBCQUEwQjtJQUMvRCxPQUFPLE1BQU07QUFDZjtBQUtPLFNBQVMscUJBQXFCO0lBQ25DLE1BQU0sUUFBUSx1QkFBdUIsMEJBQTBCO0lBQy9ELE1BQU0sU0FBUztBQUNqQjtBQWdCQSxTQUFTLGNBQ0osTUFDSDtJQUNBLE1BQU0sUUFBUSx1QkFDWjtJQUdGLElBQUksS0FBSyxTQUFTLEdBQUc7UUFDbkIsTUFBTSxNQUFNLEtBQUssQ0FBQztRQUNsQixJQUFJLE9BQU8sTUFBTSxpQkFBaUIsVUFBVTtZQUMxQyxNQUFNLElBQUksTUFDUixzQkFBc0Is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T0FBTyxpQkFBaUIsWUFDeEIsT0FBTyxpQkFBaUIsYUFDeEI7Z0JBQ0EsTUFBTSxJQUFJLE1BQ1IsMkRBQTJELE9BQU8sWUFBWTtZQUVsRjtZQUNBLElBQUksT0FBTyxVQUFVLFVBQVU7Z0JBQzdCLE1BQU0sSUFBSSxNQUNSLG1EQUFtRCxPQUFPLEtBQUs7WUFFbkU7WUFFQSxNQUFNLGtCQUFrQixXQUFXO1lBQ25DLGFBQWEsd0JBQXdCO1lBRXJDLElBQUksT0FBTyxpQkFBaUIsVUFBVTtnQkFDcEMsb0JBQW9CO29CQUFDO29CQUFHLEtBQUs7aUJBQUE7Z0JBQzVCLGVBQTBCLGVBQWU7WUFDNUMsT0FBTztnQkFDTCxvQkFBb0I7Z0JBQ3BCLGVBQWU7WUFDakI7WUFFQSxpQkFBaUIsV0FBVztZQUM1QixnQkFBZ0IsY0FBYyxDQUFDO1lBRS9CLG1CQUFtQjtZQUVuQixPQUFPQTtRQUNUO1FBQ0EsT0FBTSxPQUFZO1lBQ2hCLGFBQWEsVUFBVTtZQUV2QixJQUFJLGdCQUFnQjtnQkFDbEIsYUFBYSxjQUFjO1lBQzdCO1lBQ0EsU0FBUztZQUNULGVBQWU7WUFDZixpQkFBaUI7WUFFakIsV0FBVyxRQUFRO2dCQUFFO1lBQU0sQ0FBQztZQUU1QixPQUFPQTtRQUNUO1FBQ0EsU0FBUSxNQUFnQjtZQUN0QixhQUFhLFNBQVM7WUFFdEIsSUFBSSxnQkFBZ0I7Z0JBQ2xCLGFBQWEsY0FBYztZQUM3QjtZQUNBLFNBQVM7WUFDVCxpQkFBaUI7WUFFakIsSUFBSSxLQUFLLFFBQVE7Z0JBQ2Ysa0JBQWtCLEtBQUssQ0FBQyxDQUFDO2dCQUN6QixXQUFXLFFBQVEsY0FBYyxDQUFDO2dCQUNsQyxPQUFPQTtZQUNUO1lBRUEsV0FBVyxRQUFRLENBQUMsQ0FBQztZQUVyQixPQUFPQTtRQUNUO0lBQ0Y7SUFFQSxPQUFPQTtBQUNUIiwic291cmNlcyI6WyIvVXNlcnMvbG9yZW56b3Jhc211c3Nlbi9Qcm9qZWN0cy9Hb29HbGVkYXRhbmV4dXMtYWkvYWktc3RhdGUudHN4IiwiL1VzZXJzL2xvcmVuem9yYXNtdXNzZW4vUHJvamVjdHMvdXRpbC9jcmVhdGUtcmVzb2x2YWJsZS1wcm9taXNlLnRzIiwiL1VzZXJzL2xvcmVuem9yYXNtdXNzZW4vUHJvamVjdHMvdXRpbC9pcy1mdW5jdGlvbi50cyIsIi9Vc2Vycy9sb3JlbnpvcmFzbXVzc2VuL1Byb2plY3RzL0dvb0dsZWRhdGFuZXh1cy1haS9wcm92aWRlci50c3giLCIvVXNlcnMvbG9yZW56b3Jhc211c3Nlbi9Qcm9qZWN0cy9Hb29HbGVkYXRhbmV4dXMtYWkvc3RyZWFtLXVpL3N0cmVhbS11aS50c3giLCIvVXNlcnMvbG9yZW56b3Jhc211c3Nlbi9Qcm9qZWN0cy91dGlsL2Rvd25sb2FkLWVycm9yLnRzIiwiL1VzZXJzL2xvcmVuem9yYXNtdXNzZW4vUHJvamVjdHMvdXRpbC9kb3dubG9hZC50cyIsIi9Vc2Vycy9sb3JlbnpvcmFzbXVzc2VuL1Byb2plY3RzL2NvcmUvdXRpbC9kZXRlY3QtaW1hZ2UtbWltZXR5cGUudHMiLCIvVXNlcnMvbG9yZW56b3Jhc211c3Nlbi9Qcm9qZWN0cy9jb3JlL3Byb21wdC9kYXRhLWNvbnRlbnQudHMiLCIvVXNlcnMvbG9yZW56b3Jhc211c3Nlbi9Qcm9qZWN0cy9jb3JlL3Byb21wdC9pbnZhbGlkLWRhdGEtY29udGVudC1lcnJvci50cyIsIi9Vc2Vycy9sb3JlbnpvcmFzbXVzc2VuL1Byb2plY3RzL2NvcmUvcHJvbXB0L2ludmFsaWQtbWVzc2FnZS1yb2xlLWVycm9yLnRzIiwiL1VzZXJzL2xvcmVuem9yYXNtdXNzZW4vUHJvamVjdHMvY29yZS9wcm9tcHQvc3BsaXQtZGF0YS11cmwudHMiLCIvVXNlcnMvbG9yZW56b3Jhc211c3Nlbi9Qcm9qZWN0cy9jb3JlL3Byb21wdC9jb252ZXJ0LXRvLWxhbmd1YWdlLW1vZGVsLXByb21wdC50cyIsIi9Vc2Vycy9sb3JlbnpvcmFzbXVzc2VuL1Byb2plY3RzL2Vycm9ycy9pbnZhbGlkLWFyZ3VtZW50LWVycm9yLnRzIiwiL1VzZXJzL2xvcmVuem9yYXNtdXNzZW4vUHJvamVjdHMvY29yZS9wcm9tcHQvcHJlcGFyZS1jYWxsLXNldHRpbmdzLnRzIiwiL1VzZXJzL2xvcmVuem9yYXNtdXNzZW4vUHJvamVjdHMvY29yZS9wcm9tcHQvcHJlcGFyZS10b29scy1hbmQtdG9vbC1jaG9pY2UudHMiLCIvVXNlcnMvbG9yZW56b3Jhc211c3Nlbi9Qcm9qZWN0cy9jb3JlL3V0aWwvaXMtbm9uLWVtcHR5LW9iamVjdC50cyIsIi9Vc2Vycy9sb3JlbnpvcmFzbXVzc2VuL1Byb2plY3RzL2NvcmUvcHJvbXB0L3N0YW5kYXJkaXplLXByb21wdC50cyIsIi9Vc2Vycy9sb3JlbnpvcmFzbXVzc2VuL1Byb2plY3RzL2NvcmUvcHJvbXB0L21lc3NhZ2UudHMiLCIvVXNlcnMvbG9yZW56b3Jhc211c3Nlbi9Qcm9qZWN0cy9jb3JlL3R5cGVzL3Byb3ZpZGVyLW1ldGFkYXRhLnRzIiwiL1VzZXJzL2xvcmVuem9yYXNtdXNzZW4vUHJvamVjdHMvY29yZS90eXBlcy9qc29uLXZhbHVlLnRzIiwiL1VzZXJzL2xvcmVuem9yYXNtdXNzZW4vUHJvamVjdHMvY29yZS9wcm9tcHQvY29udGVudC1wYXJ0LnRzIiwiL1VzZXJzL2xvcmVuem9yYXNtdXNzZW4vUHJvamVjdHMvY29yZS9wcm9tcHQvdG9vbC1yZXN1bHQtY29udGVudC50cyIsIi9Vc2Vycy9sb3JlbnpvcmFzbXVzc2VuL1Byb2plY3RzL2NvcmUvcHJvbXB0L2RldGVjdC1wcm9tcHQtdHlwZS50cyIsIi9Vc2Vycy9sb3JlbnpvcmFzbXVzc2VuL1Byb2plY3RzL2NvcmUvcHJvbXB0L2F0dGFjaG1lbnRzLXRvLXBhcnRzLnRzIiwiL1VzZXJzL2xvcmVuem9yYXNtdXNzZW4vUHJvamVjdHMvY29yZS9wcm9tcHQvbWVzc2FnZS1jb252ZXJzaW9uLWVycm9yLnRzIiwiL1VzZXJzL2xvcmVuem9yYXNtdXNzZW4vUHJvamVjdHMvY29yZS9wcm9tcHQvY29udmVydC10by1jb3JlLW1lc3NhZ2VzLnRzIiwiL1VzZXJzL2xvcmVuem9yYXNtdXNzZW4vUHJvamVjdHMvY29yZS90eXBlcy91c2FnZS50cyIsIi9Vc2Vycy9sb3JlbnpvcmFzbXVzc2VuL1Byb2plY3RzL2Vycm9ycy9pbnZhbGlkLXRvb2wtYXJndW1lbnRzLWVycm9yLnRzIiwiL1VzZXJzL2xvcmVuem9yYXNtdXNzZW4vUHJvamVjdHMvZXJyb3JzL25vLXN1Y2gtdG9vbC1lcnJvci50cyIsIi9Vc2Vycy9sb3JlbnpvcmFzbXVzc2VuL1Byb2plY3RzL3V0aWwvaXMtYXN5bmMtZ2VuZXJhdG9yLnRzIiwiL1VzZXJzL2xvcmVuem9yYXNtdXNzZW4vUHJvamVjdHMvdXRpbC9pcy1nZW5lcmF0b3IudHMiLCIvVXNlcnMvbG9yZW56b3Jhc211c3Nlbi9Qcm9qZWN0cy91dGlsL3JldHJ5LXdpdGgtZXhwb25lbnRpYWwtYmFja29mZi50cyIsIi9Vc2Vycy9sb3JlbnpvcmFzbXVzc2VuL1Byb2plY3RzL3V0aWwvZGVsYXkudHMiLCIvVXNlcnMvbG9yZW56b3Jhc211c3Nlbi9Qcm9qZWN0cy91dGlsL3JldHJ5LWVycm9yLnRzIiwiL1VzZXJzL2xvcmVuem9yYXNtdXNzZW4vUHJvamVjdHMvdXRpbC9jb25zdGFudHMudHMiLCIvVXNlcnMvbG9yZW56b3Jhc211c3Nlbi9Qcm9qZWN0cy9Hb29HbGVkYXRhbmV4dXMtYWkvc3RyZWFtYWJsZS11aS9jcmVhdGUtc3VzcGVuZGVkLWNodW5rLnRzeCIsIi9Vc2Vycy9sb3JlbnpvcmFzbXVzc2VuL1Byb2plY3RzL0dvb0dsZWRhdGFuZXh1cy1haS9zdHJlYW1hYmxlLXVpL2NyZWF0ZS1zdHJlYW1hYmxlLXVpLnRzeCIsIi9Vc2Vycy9sb3JlbnpvcmFzbXVzc2VuL1Byb2plY3RzL0dvb0dsZWRhdGFuZXh1cy1haS9zdHJlYW0tdWkvcmVuZGVyLnRzIiwiL1VzZXJzL2xvcmVuem9yYXNtdXNzZW4vUHJvamVjdHMvc3RyZWFtcy9haS1zdHJlYW0udHMiLCIvVXNlcnMvbG9yZW56b3Jhc211c3Nlbi9Qcm9qZWN0cy9zdHJlYW1zL3N0cmVhbS1kYXRhLnRzIiwiL1VzZXJzL2xvcmVuem9yYXNtdXNzZW4vUHJvamVjdHMvc3RyZWFtcy9vcGVuYWktc3RyZWFtLnRzIiwiL1VzZXJzL2xvcmVuem9yYXNtdXNzZW4vUHJvamVjdHMvdXRpbC9jb25zdW1lLXN0cmVhbS50cyIsIi9Vc2Vycy9sb3JlbnpvcmFzbXVzc2VuL1Byb2plY3RzL0dvb0dsZWRhdGFuZXh1cy1haS9zdHJlYW1hYmxlLXZhbHVlL3N0cmVhbWFibGUtdmFsdWUudHMiLCIvVXNlcnMvbG9yZW56b3Jhc211c3Nlbi9Qcm9qZWN0cy9Hb29HbGVkYXRhbmV4dXMtYWkvc3RyZWFtYWJsZS12YWx1ZS9jcmVhdGUtc3RyZWFtYWJsZS12YWx1ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBqc29uZGlmZnBhdGNoIGZyb20gJ2pzb25kaWZmcGF0Y2gnO1xuaW1wb3J0IHsgQXN5bmNMb2NhbFN0b3JhZ2UgfSBmcm9tICdub2RlOmFzeW5jX2hvb2tzJztcbmltcG9ydCB7IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlIH0gZnJvbSAnLi4vdXRpbC9jcmVhdGUtcmVzb2x2YWJsZS1wcm9taXNlJztcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuLi91dGlsL2lzLWZ1bmN0aW9uJztcbmltcG9ydCB0eXBlIHtcbiAgQUlQcm92aWRlcixcbiAgSW5mZXJBSVN0YXRlLFxuICBJbnRlcm5hbEFJU3RhdGVTdG9yYWdlT3B0aW9ucyxcbiAgTXV0YWJsZUFJU3RhdGUsXG4gIFZhbHVlT3JVcGRhdGVyLFxufSBmcm9tICcuL3R5cGVzJztcblxuLy8gSXQgaXMgcG9zc2libGUgdGhhdCBtdWx0aXBsZSBBSSByZXF1ZXN0cyBnZXQgaW4gY29uY3VycmVudGx5LCBmb3IgZGlmZmVyZW50XG4vLyBBSSBpbnN0YW5jZXMuIFNvIEFMUyBpcyBuZWNlc3NhcnkgaGVyZSBmb3IgYSBzaW1wbGVyIEFQSS5cbmNvbnN0IGFzeW5jQUlTdGF0ZVN0b3JhZ2UgPSBuZXcgQXN5bmNMb2NhbFN0b3JhZ2U8e1xuICBjdXJyZW50U3RhdGU6IGFueTtcbiAgb3JpZ2luYWxTdGF0ZTogYW55O1xuICBzZWFsZWQ6IGJvb2xlYW47XG4gIG9wdGlvbnM6IEludGVybmFsQUlTdGF0ZVN0b3JhZ2VPcHRpb25zO1xuICBtdXRhdGlvbkRlbHRhUHJvbWlzZT86IFByb21pc2U8YW55PjtcbiAgbXV0YXRpb25EZWx0YVJlc29sdmU/OiAodjogYW55KSA9PiB2b2lkO1xufT4oKTtcblxuZnVuY3Rpb24gZ2V0QUlTdGF0ZVN0b3JlT3JUaHJvdyhtZXNzYWdlOiBzdHJpbmcpIHtcbiAgY29uc3Qgc3RvcmUgPSBhc3luY0FJU3RhdGVTdG9yYWdlLmdldFN0b3JlKCk7XG4gIGlmICghc3RvcmUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgcmV0dXJuIHN0b3JlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2l0aEFJU3RhdGU8UywgVD4oXG4gIHsgc3RhdGUsIG9wdGlvbnMgfTogeyBzdGF0ZTogUzsgb3B0aW9uczogSW50ZXJuYWxBSVN0YXRlU3RvcmFnZU9wdGlvbnMgfSxcbiAgZm46ICgpID0+IFQsXG4pOiBUIHtcbiAgcmV0dXJuIGFzeW5jQUlTdGF0ZVN0b3JhZ2UucnVuKFxuICAgIHtcbiAgICAgIGN1cnJlbnRTdGF0ZTogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzdGF0ZSkpLCAvLyBkZWVwIGNsb25lIG9iamVjdFxuICAgICAgb3JpZ2luYWxTdGF0ZTogc3RhdGUsXG4gICAgICBzZWFsZWQ6IGZhbHNlLFxuICAgICAgb3B0aW9ucyxcbiAgICB9LFxuICAgIGZuLFxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QUlTdGF0ZURlbHRhUHJvbWlzZSgpIHtcbiAgY29uc3Qgc3RvcmUgPSBnZXRBSVN0YXRlU3RvcmVPclRocm93KCdJbnRlcm5hbCBlcnJvciBvY2N1cnJlZC4nKTtcbiAgcmV0dXJuIHN0b3JlLm11dGF0aW9uRGVsdGFQcm9taXNlO1xufVxuXG4vLyBJbnRlcm5hbCBtZXRob2QuIFRoaXMgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIEFJIEFjdGlvbiBoYXMgYmVlbiByZXR1cm5lZFxuLy8gYW5kIHlvdSBjYW4gbm8gbG9uZ2VyIGNhbGwgYGdldE11dGFibGVBSVN0YXRlKClgIGluc2lkZSBhbnkgYXN5bmMgY2FsbGJhY2tzXG4vLyBjcmVhdGVkIGJ5IHRoYXQgQWN0aW9uLlxuZXhwb3J0IGZ1bmN0aW9uIHNlYWxNdXRhYmxlQUlTdGF0ZSgpIHtcbiAgY29uc3Qgc3RvcmUgPSBnZXRBSVN0YXRlU3RvcmVPclRocm93KCdJbnRlcm5hbCBlcnJvciBvY2N1cnJlZC4nKTtcbiAgc3RvcmUuc2VhbGVkID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgQUkgc3RhdGUuXG4gKiBJZiBga2V5YCBpcyBwcm92aWRlZCwgaXQgd2lsbCByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQga2V5IGluIHRoZVxuICogQUkgc3RhdGUsIGlmIGl0J3MgYW4gb2JqZWN0LiBJZiBpdCdzIG5vdCBhbiBvYmplY3QsIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gKlxuICogQGV4YW1wbGUgY29uc3Qgc3RhdGUgPSBnZXRBSVN0YXRlKCkgLy8gR2V0IHRoZSBlbnRpcmUgQUkgc3RhdGVcbiAqIEBleGFtcGxlIGNvbnN0IGZpZWxkID0gZ2V0QUlTdGF0ZSgna2V5JykgLy8gR2V0IHRoZSB2YWx1ZSBvZiB0aGUga2V5XG4gKi9cbmZ1bmN0aW9uIGdldEFJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PigpOiBSZWFkb25seTxcbiAgSW5mZXJBSVN0YXRlPEFJLCBhbnk+XG4+O1xuZnVuY3Rpb24gZ2V0QUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KFxuICBrZXk6IGtleW9mIEluZmVyQUlTdGF0ZTxBSSwgYW55Pixcbik6IFJlYWRvbmx5PEluZmVyQUlTdGF0ZTxBSSwgYW55Plt0eXBlb2Yga2V5XT47XG5mdW5jdGlvbiBnZXRBSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oXG4gIC4uLmFyZ3M6IFtdIHwgW2tleToga2V5b2YgSW5mZXJBSVN0YXRlPEFJLCBhbnk+XVxuKSB7XG4gIGNvbnN0IHN0b3JlID0gZ2V0QUlTdGF0ZVN0b3JlT3JUaHJvdyhcbiAgICAnYGdldEFJU3RhdGVgIG11c3QgYmUgY2FsbGVkIHdpdGhpbiBhbiBBSSBBY3Rpb24uJyxcbiAgKTtcblxuICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3Qga2V5ID0gYXJnc1swXTtcbiAgICBpZiAodHlwZW9mIHN0b3JlLmN1cnJlbnRTdGF0ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFlvdSBjYW4ndCBnZXQgdGhlIFwiJHtTdHJpbmcoXG4gICAgICAgICAga2V5LFxuICAgICAgICApfVwiIGZpZWxkIGZyb20gdGhlIEFJIHN0YXRlIGJlY2F1c2UgaXQncyBub3QgYW4gb2JqZWN0LmAsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gc3RvcmUuY3VycmVudFN0YXRlW2tleSBhcyBrZXlvZiB0eXBlb2Ygc3RvcmUuY3VycmVudFN0YXRlXTtcbiAgfVxuXG4gIHJldHVybiBzdG9yZS5jdXJyZW50U3RhdGU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBtdXRhYmxlIEFJIHN0YXRlLiBOb3RlIHRoYXQgeW91IG11c3QgY2FsbCBgLmRvbmUoKWAgd2hlbiBmaW5pc2hpbmdcbiAqIHVwZGF0aW5nIHRoZSBBSSBzdGF0ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBjb25zdCBzdGF0ZSA9IGdldE11dGFibGVBSVN0YXRlKClcbiAqIHN0YXRlLnVwZGF0ZSh7IC4uLnN0YXRlLmdldCgpLCBrZXk6ICd2YWx1ZScgfSlcbiAqIHN0YXRlLnVwZGF0ZSgoY3VycmVudFN0YXRlKSA9PiAoeyAuLi5jdXJyZW50U3RhdGUsIGtleTogJ3ZhbHVlJyB9KSlcbiAqIHN0YXRlLmRvbmUoKVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogY29uc3Qgc3RhdGUgPSBnZXRNdXRhYmxlQUlTdGF0ZSgpXG4gKiBzdGF0ZS5kb25lKHsgLi4uc3RhdGUuZ2V0KCksIGtleTogJ3ZhbHVlJyB9KSAvLyBEb25lIHdpdGggYSBuZXcgc3RhdGVcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBnZXRNdXRhYmxlQUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KCk6IE11dGFibGVBSVN0YXRlPFxuICBJbmZlckFJU3RhdGU8QUksIGFueT5cbj47XG5mdW5jdGlvbiBnZXRNdXRhYmxlQUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KFxuICBrZXk6IGtleW9mIEluZmVyQUlTdGF0ZTxBSSwgYW55Pixcbik6IE11dGFibGVBSVN0YXRlPEluZmVyQUlTdGF0ZTxBSSwgYW55Plt0eXBlb2Yga2V5XT47XG5mdW5jdGlvbiBnZXRNdXRhYmxlQUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KFxuICAuLi5hcmdzOiBbXSB8IFtrZXk6IGtleW9mIEluZmVyQUlTdGF0ZTxBSSwgYW55Pl1cbikge1xuICB0eXBlIEFJU3RhdGUgPSBJbmZlckFJU3RhdGU8QUksIGFueT47XG4gIHR5cGUgQUlTdGF0ZVdpdGhLZXkgPSB0eXBlb2YgYXJncyBleHRlbmRzIFtrZXk6IGtleW9mIEFJU3RhdGVdXG4gICAgPyBBSVN0YXRlWyh0eXBlb2YgYXJncylbMF1dXG4gICAgOiBBSVN0YXRlO1xuICB0eXBlIE5ld1N0YXRlT3JVcGRhdGVyID0gVmFsdWVPclVwZGF0ZXI8QUlTdGF0ZVdpdGhLZXk+O1xuXG4gIGNvbnN0IHN0b3JlID0gZ2V0QUlTdGF0ZVN0b3JlT3JUaHJvdyhcbiAgICAnYGdldE11dGFibGVBSVN0YXRlYCBtdXN0IGJlIGNhbGxlZCB3aXRoaW4gYW4gQUkgQWN0aW9uLicsXG4gICk7XG5cbiAgaWYgKHN0b3JlLnNlYWxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiYGdldE11dGFibGVBSVN0YXRlYCBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgcmV0dXJuaW5nIGZyb20gYW4gQUkgQWN0aW9uLiBQbGVhc2UgbW92ZSBpdCB0byB0aGUgdG9wIGxldmVsIG9mIHRoZSBBY3Rpb24ncyBmdW5jdGlvbiBib2R5LlwiLFxuICAgICk7XG4gIH1cblxuICBpZiAoIXN0b3JlLm11dGF0aW9uRGVsdGFQcm9taXNlKSB7XG4gICAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlIH0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgIHN0b3JlLm11dGF0aW9uRGVsdGFQcm9taXNlID0gcHJvbWlzZTtcbiAgICBzdG9yZS5tdXRhdGlvbkRlbHRhUmVzb2x2ZSA9IHJlc29sdmU7XG4gIH1cblxuICBmdW5jdGlvbiBkb1VwZGF0ZShuZXdTdGF0ZTogTmV3U3RhdGVPclVwZGF0ZXIsIGRvbmU6IGJvb2xlYW4pIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIHN0b3JlLmN1cnJlbnRTdGF0ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYXJnc1swXTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBZb3UgY2FuJ3QgbW9kaWZ5IHRoZSBcIiR7U3RyaW5nKFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICl9XCIgZmllbGQgb2YgdGhlIEFJIHN0YXRlIGJlY2F1c2UgaXQncyBub3QgYW4gb2JqZWN0LmAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzRnVuY3Rpb24obmV3U3RhdGUpKSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHN0b3JlLmN1cnJlbnRTdGF0ZVthcmdzWzBdXSA9IG5ld1N0YXRlKHN0b3JlLmN1cnJlbnRTdGF0ZVthcmdzWzBdXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdG9yZS5jdXJyZW50U3RhdGUgPSBuZXdTdGF0ZShzdG9yZS5jdXJyZW50U3RhdGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHN0b3JlLmN1cnJlbnRTdGF0ZVthcmdzWzBdXSA9IG5ld1N0YXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RvcmUuY3VycmVudFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RvcmUub3B0aW9ucy5vblNldEFJU3RhdGU/Lih7XG4gICAgICBrZXk6IGFyZ3MubGVuZ3RoID4gMCA/IGFyZ3NbMF0gOiB1bmRlZmluZWQsXG4gICAgICBzdGF0ZTogc3RvcmUuY3VycmVudFN0YXRlLFxuICAgICAgZG9uZSxcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IG11dGFibGVTdGF0ZSA9IHtcbiAgICBnZXQ6ICgpID0+IHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYXJnc1swXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdG9yZS5jdXJyZW50U3RhdGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFlvdSBjYW4ndCBnZXQgdGhlIFwiJHtTdHJpbmcoXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICl9XCIgZmllbGQgZnJvbSB0aGUgQUkgc3RhdGUgYmVjYXVzZSBpdCdzIG5vdCBhbiBvYmplY3QuYCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdG9yZS5jdXJyZW50U3RhdGVba2V5XSBhcyBSZWFkb25seTxBSVN0YXRlV2l0aEtleT47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdG9yZS5jdXJyZW50U3RhdGUgYXMgUmVhZG9ubHk8QUlTdGF0ZT47XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShuZXdBSVN0YXRlOiBOZXdTdGF0ZU9yVXBkYXRlcikge1xuICAgICAgZG9VcGRhdGUobmV3QUlTdGF0ZSwgZmFsc2UpO1xuICAgIH0sXG4gICAgZG9uZTogZnVuY3Rpb24gZG9uZSguLi5kb25lQXJnczogW10gfCBbTmV3U3RhdGVPclVwZGF0ZXJdKSB7XG4gICAgICBpZiAoZG9uZUFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBkb1VwZGF0ZShkb25lQXJnc1swXSBhcyBOZXdTdGF0ZU9yVXBkYXRlciwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRlbHRhID0ganNvbmRpZmZwYXRjaC5kaWZmKHN0b3JlLm9yaWdpbmFsU3RhdGUsIHN0b3JlLmN1cnJlbnRTdGF0ZSk7XG4gICAgICBzdG9yZS5tdXRhdGlvbkRlbHRhUmVzb2x2ZSEoZGVsdGEpO1xuICAgIH0sXG4gIH07XG5cbiAgcmV0dXJuIG11dGFibGVTdGF0ZTtcbn1cblxuZXhwb3J0IHsgZ2V0QUlTdGF0ZSwgZ2V0TXV0YWJsZUFJU3RhdGUgfTtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIFByb21pc2Ugd2l0aCBleHRlcm5hbGx5IGFjY2Vzc2libGUgcmVzb2x2ZSBhbmQgcmVqZWN0IGZ1bmN0aW9ucy5cbiAqXG4gKiBAdGVtcGxhdGUgVCAtIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB0aGF0IHRoZSBQcm9taXNlIHdpbGwgcmVzb2x2ZSB0by5cbiAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nOlxuICogICAtIHByb21pc2U6IEEgUHJvbWlzZSB0aGF0IGNhbiBiZSByZXNvbHZlZCBvciByZWplY3RlZCBleHRlcm5hbGx5LlxuICogICAtIHJlc29sdmU6IEEgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgUHJvbWlzZSB3aXRoIGEgdmFsdWUgb2YgdHlwZSBULlxuICogICAtIHJlamVjdDogQSBmdW5jdGlvbiB0byByZWplY3QgdGhlIFByb21pc2Ugd2l0aCBhbiBlcnJvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlc29sdmFibGVQcm9taXNlPFQgPSBhbnk+KCk6IHtcbiAgcHJvbWlzZTogUHJvbWlzZTxUPjtcbiAgcmVzb2x2ZTogKHZhbHVlOiBUKSA9PiB2b2lkO1xuICByZWplY3Q6IChlcnJvcjogdW5rbm93bikgPT4gdm9pZDtcbn0ge1xuICBsZXQgcmVzb2x2ZTogKHZhbHVlOiBUKSA9PiB2b2lkO1xuICBsZXQgcmVqZWN0OiAoZXJyb3I6IHVua25vd24pID0+IHZvaWQ7XG5cbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlPFQ+KChyZXMsIHJlaikgPT4ge1xuICAgIHJlc29sdmUgPSByZXM7XG4gICAgcmVqZWN0ID0gcmVqO1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHByb21pc2UsXG4gICAgcmVzb2x2ZTogcmVzb2x2ZSEsXG4gICAgcmVqZWN0OiByZWplY3QhLFxuICB9O1xufVxuIiwiLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHt1bmtub3dufSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBjb25zdCBpc0Z1bmN0aW9uID0gKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgRnVuY3Rpb24gPT5cbiAgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuIiwiLy8gVGhpcyBmaWxlIHByb3ZpZGVzIHRoZSBBSSBjb250ZXh0IHRvIGFsbCBBSSBBY3Rpb25zIHZpYSBBc3luY0xvY2FsU3RvcmFnZS5cblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgSW50ZXJuYWxBSVByb3ZpZGVyIH0gZnJvbSAnLi9yc2Mtc2hhcmVkLm1qcyc7XG5pbXBvcnQge1xuICB3aXRoQUlTdGF0ZSxcbiAgZ2V0QUlTdGF0ZURlbHRhUHJvbWlzZSxcbiAgc2VhbE11dGFibGVBSVN0YXRlLFxufSBmcm9tICcuL2FpLXN0YXRlJztcbmltcG9ydCB0eXBlIHtcbiAgU2VydmVyV3JhcHBlZEFjdGlvbnMsXG4gIEFJQWN0aW9uLFxuICBBSUFjdGlvbnMsXG4gIEFJUHJvdmlkZXIsXG4gIEludGVybmFsQUlTdGF0ZVN0b3JhZ2VPcHRpb25zLFxuICBPblNldEFJU3RhdGUsXG4gIE9uR2V0VUlTdGF0ZSxcbn0gZnJvbSAnLi90eXBlcyc7XG5cbmFzeW5jIGZ1bmN0aW9uIGlubmVyQWN0aW9uPFQ+KFxuICB7XG4gICAgYWN0aW9uLFxuICAgIG9wdGlvbnMsXG4gIH06IHsgYWN0aW9uOiBBSUFjdGlvbjsgb3B0aW9uczogSW50ZXJuYWxBSVN0YXRlU3RvcmFnZU9wdGlvbnMgfSxcbiAgc3RhdGU6IFQsXG4gIC4uLmFyZ3M6IHVua25vd25bXVxuKSB7XG4gICd1c2Ugc2VydmVyJztcbiAgcmV0dXJuIGF3YWl0IHdpdGhBSVN0YXRlKFxuICAgIHtcbiAgICAgIHN0YXRlLFxuICAgICAgb3B0aW9ucyxcbiAgICB9LFxuICAgIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFjdGlvbiguLi5hcmdzKTtcbiAgICAgIHNlYWxNdXRhYmxlQUlTdGF0ZSgpO1xuICAgICAgcmV0dXJuIFtnZXRBSVN0YXRlRGVsdGFQcm9taXNlKCkgYXMgUHJvbWlzZTxUPiwgcmVzdWx0XTtcbiAgICB9LFxuICApO1xufVxuXG5mdW5jdGlvbiB3cmFwQWN0aW9uPFQgPSB1bmtub3duPihcbiAgYWN0aW9uOiBBSUFjdGlvbixcbiAgb3B0aW9uczogSW50ZXJuYWxBSVN0YXRlU3RvcmFnZU9wdGlvbnMsXG4pIHtcbiAgcmV0dXJuIGlubmVyQWN0aW9uLmJpbmQobnVsbCwgeyBhY3Rpb24sIG9wdGlvbnMgfSkgYXMgQUlBY3Rpb248VD47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBSTxcbiAgQUlTdGF0ZSA9IGFueSxcbiAgVUlTdGF0ZSA9IGFueSxcbiAgQWN0aW9ucyBleHRlbmRzIEFJQWN0aW9ucyA9IHt9LFxuPih7XG4gIGFjdGlvbnMsXG4gIGluaXRpYWxBSVN0YXRlLFxuICBpbml0aWFsVUlTdGF0ZSxcblxuICBvblNldEFJU3RhdGUsXG4gIG9uR2V0VUlTdGF0ZSxcbn06IHtcbiAgYWN0aW9uczogQWN0aW9ucztcbiAgaW5pdGlhbEFJU3RhdGU/OiBBSVN0YXRlO1xuICBpbml0aWFsVUlTdGF0ZT86IFVJU3RhdGU7XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW5ldmVyIHRoZSBBSSBzdGF0ZSBpcyB1cGRhdGVkIGJ5IGFuIEFjdGlvbi5cbiAgICogWW91IGNhbiB1c2UgdGhpcyB0byBwZXJzaXN0IHRoZSBBSSBzdGF0ZSB0byBhIGRhdGFiYXNlLCBvciB0byBzZW5kIGl0IHRvIGFcbiAgICogbG9nZ2luZyBzZXJ2aWNlLlxuICAgKi9cbiAgb25TZXRBSVN0YXRlPzogT25TZXRBSVN0YXRlPEFJU3RhdGU+O1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcmV0cmlldmUgdGhlIFVJIHN0YXRlIGJhc2VkIG9uIHRoZSBBSSBzdGF0ZS5cbiAgICogRm9yIGV4YW1wbGUsIHRvIHJlbmRlciB0aGUgaW5pdGlhbCBVSSBzdGF0ZSBiYXNlZCBvbiBhIGdpdmVuIEFJIHN0YXRlLCBvclxuICAgKiB0byBzeW5jIHRoZSBVSSBzdGF0ZSB3aGVuIHRoZSBhcHBsaWNhdGlvbiBpcyBhbHJlYWR5IGxvYWRlZC5cbiAgICpcbiAgICogSWYgcmV0dXJuaW5nIGB1bmRlZmluZWRgLCB0aGUgY2xpZW50IHNpZGUgVUkgc3RhdGUgd2lsbCBub3QgYmUgdXBkYXRlZC5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBtdXN0IGJlIGFubm90YXRlZCB3aXRoIHRoZSBgXCJ1c2Ugc2VydmVyXCJgIGRpcmVjdGl2ZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHN4XG4gICAqIG9uR2V0VUlTdGF0ZTogYXN5bmMgKCkgPT4ge1xuICAgKiAgICd1c2Ugc2VydmVyJztcbiAgICpcbiAgICogICBjb25zdCBjdXJyZW50QUlTdGF0ZSA9IGdldEFJU3RhdGUoKTtcbiAgICogICBjb25zdCBleHRlcm5hbEFJU3RhdGUgPSBhd2FpdCBsb2FkQUlTdGF0ZUZyb21EYXRhYmFzZSgpO1xuICAgKlxuICAgKiAgIGlmIChjdXJyZW50QUlTdGF0ZSA9PT0gZXh0ZXJuYWxBSVN0YXRlKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgKlxuICAgKiAgIC8vIFVwZGF0ZSBjdXJyZW50IEFJIHN0YXRlIGFuZCByZXR1cm4gdGhlIG5ldyBVSSBzdGF0ZVxuICAgKiAgIGNvbnN0IHN0YXRlID0gZ2V0TXV0YWJsZUFJU3RhdGUoKVxuICAgKiAgIHN0YXRlLmRvbmUoZXh0ZXJuYWxBSVN0YXRlKVxuICAgKlxuICAgKiAgIHJldHVybiA8ZGl2Pi4uLjwvZGl2PjtcbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIG9uR2V0VUlTdGF0ZT86IE9uR2V0VUlTdGF0ZTxVSVN0YXRlPjtcbn0pIHtcbiAgLy8gV3JhcCBhbGwgYWN0aW9ucyB3aXRoIG91ciBIb0MuXG4gIGNvbnN0IHdyYXBwZWRBY3Rpb25zOiBTZXJ2ZXJXcmFwcGVkQWN0aW9ucyA9IHt9O1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gYWN0aW9ucykge1xuICAgIHdyYXBwZWRBY3Rpb25zW25hbWVdID0gd3JhcEFjdGlvbihhY3Rpb25zW25hbWVdLCB7XG4gICAgICBvblNldEFJU3RhdGUsXG4gICAgfSk7XG4gIH1cblxuICBjb25zdCB3cmFwcGVkU3luY1VJU3RhdGUgPSBvbkdldFVJU3RhdGVcbiAgICA/IHdyYXBBY3Rpb24ob25HZXRVSVN0YXRlLCB7fSlcbiAgICA6IHVuZGVmaW5lZDtcblxuICBjb25zdCBBSTogQUlQcm92aWRlcjxBSVN0YXRlLCBVSVN0YXRlLCBBY3Rpb25zPiA9IGFzeW5jIHByb3BzID0+IHtcbiAgICBpZiAoJ3VzZVN0YXRlJyBpbiBSZWFjdCkge1xuICAgICAgLy8gVGhpcyBmaWxlIG11c3QgYmUgcnVubmluZyBvbiB0aGUgUmVhY3QgU2VydmVyIGxheWVyLlxuICAgICAgLy8gSWRlYWxseSB3ZSBzaG91bGQgYmUgdXNpbmcgYGltcG9ydCBcInNlcnZlci1vbmx5XCJgIGhlcmUgYnV0IHdlIGNhbiBoYXZlIGFcbiAgICAgIC8vIG1vcmUgY3VzdG9taXplZCBlcnJvciBtZXNzYWdlIHdpdGggdGhpcyBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1RoaXMgY29tcG9uZW50IGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIFNlcnZlciBDb21wb25lbnRzLicsXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCB1aVN0YXRlID0gcHJvcHMuaW5pdGlhbFVJU3RhdGUgPz8gaW5pdGlhbFVJU3RhdGU7XG4gICAgbGV0IGFpU3RhdGUgPSBwcm9wcy5pbml0aWFsQUlTdGF0ZSA/PyBpbml0aWFsQUlTdGF0ZTtcbiAgICBsZXQgYWlTdGF0ZURlbHRhID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKHdyYXBwZWRTeW5jVUlTdGF0ZSkge1xuICAgICAgY29uc3QgW25ld0FJU3RhdGVEZWx0YSwgbmV3VUlTdGF0ZV0gPSBhd2FpdCB3cmFwcGVkU3luY1VJU3RhdGUoYWlTdGF0ZSk7XG4gICAgICBpZiAobmV3VUlTdGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFpU3RhdGVEZWx0YSA9IG5ld0FJU3RhdGVEZWx0YTtcbiAgICAgICAgdWlTdGF0ZSA9IG5ld1VJU3RhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxJbnRlcm5hbEFJUHJvdmlkZXJcbiAgICAgICAgd3JhcHBlZEFjdGlvbnM9e3dyYXBwZWRBY3Rpb25zfVxuICAgICAgICB3cmFwcGVkU3luY1VJU3RhdGU9e3dyYXBwZWRTeW5jVUlTdGF0ZX1cbiAgICAgICAgaW5pdGlhbFVJU3RhdGU9e3VpU3RhdGV9XG4gICAgICAgIGluaXRpYWxBSVN0YXRlPXthaVN0YXRlfVxuICAgICAgICBpbml0aWFsQUlTdGF0ZVBhdGNoPXthaVN0YXRlRGVsdGF9XG4gICAgICA+XG4gICAgICAgIHtwcm9wcy5jaGlsZHJlbn1cbiAgICAgIDwvSW50ZXJuYWxBSVByb3ZpZGVyPlxuICAgICk7XG4gIH07XG5cbiAgcmV0dXJuIEFJO1xufVxuIiwiaW1wb3J0IHsgTGFuZ3VhZ2VNb2RlbFYxIH0gZnJvbSAnQGFpLXNkay9wcm92aWRlcic7XG5pbXBvcnQgeyBzYWZlUGFyc2VKU09OIH0gZnJvbSAnQGFpLXNkay9wcm92aWRlci11dGlscyc7XG5pbXBvcnQgeyBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB6IH0gZnJvbSAnem9kJztcbmltcG9ydCB7IENhbGxTZXR0aW5ncyB9IGZyb20gJy4uLy4uL2NvcmUvcHJvbXB0L2NhbGwtc2V0dGluZ3MnO1xuaW1wb3J0IHsgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCB9IGZyb20gJy4uLy4uL2NvcmUvcHJvbXB0L2NvbnZlcnQtdG8tbGFuZ3VhZ2UtbW9kZWwtcHJvbXB0JztcbmltcG9ydCB7IHByZXBhcmVDYWxsU2V0dGluZ3MgfSBmcm9tICcuLi8uLi9jb3JlL3Byb21wdC9wcmVwYXJlLWNhbGwtc2V0dGluZ3MnO1xuaW1wb3J0IHsgcHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZSB9IGZyb20gJy4uLy4uL2NvcmUvcHJvbXB0L3ByZXBhcmUtdG9vbHMtYW5kLXRvb2wtY2hvaWNlJztcbmltcG9ydCB7IFByb21wdCB9IGZyb20gJy4uLy4uL2NvcmUvcHJvbXB0L3Byb21wdCc7XG5pbXBvcnQgeyBzdGFuZGFyZGl6ZVByb21wdCB9IGZyb20gJy4uLy4uL2NvcmUvcHJvbXB0L3N0YW5kYXJkaXplLXByb21wdCc7XG5pbXBvcnQge1xuICBDYWxsV2FybmluZyxcbiAgQ29yZVRvb2xDaG9pY2UsXG4gIEZpbmlzaFJlYXNvbixcbiAgUHJvdmlkZXJNZXRhZGF0YSxcbn0gZnJvbSAnLi4vLi4vY29yZS90eXBlcyc7XG5pbXBvcnQge1xuICBMYW5ndWFnZU1vZGVsVXNhZ2UsXG4gIGNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZSxcbn0gZnJvbSAnLi4vLi4vY29yZS90eXBlcy91c2FnZSc7XG5pbXBvcnQgeyBJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yIH0gZnJvbSAnLi4vLi4vZXJyb3JzL2ludmFsaWQtdG9vbC1hcmd1bWVudHMtZXJyb3InO1xuaW1wb3J0IHsgTm9TdWNoVG9vbEVycm9yIH0gZnJvbSAnLi4vLi4vZXJyb3JzL25vLXN1Y2gtdG9vbC1lcnJvcic7XG5pbXBvcnQgeyBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSB9IGZyb20gJy4uLy4uL3V0aWwvY3JlYXRlLXJlc29sdmFibGUtcHJvbWlzZSc7XG5pbXBvcnQgeyBpc0FzeW5jR2VuZXJhdG9yIH0gZnJvbSAnLi4vLi4vdXRpbC9pcy1hc3luYy1nZW5lcmF0b3InO1xuaW1wb3J0IHsgaXNHZW5lcmF0b3IgfSBmcm9tICcuLi8uLi91dGlsL2lzLWdlbmVyYXRvcic7XG5pbXBvcnQgeyByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYgfSBmcm9tICcuLi8uLi91dGlsL3JldHJ5LXdpdGgtZXhwb25lbnRpYWwtYmFja29mZic7XG5pbXBvcnQgeyBjcmVhdGVTdHJlYW1hYmxlVUkgfSBmcm9tICcuLi9zdHJlYW1hYmxlLXVpL2NyZWF0ZS1zdHJlYW1hYmxlLXVpJztcblxudHlwZSBTdHJlYW1hYmxlID0gUmVhY3ROb2RlIHwgUHJvbWlzZTxSZWFjdE5vZGU+O1xuXG50eXBlIFJlbmRlcmVyPFQgZXh0ZW5kcyBBcnJheTxhbnk+PiA9IChcbiAgLi4uYXJnczogVFxuKSA9PlxuICB8IFN0cmVhbWFibGVcbiAgfCBHZW5lcmF0b3I8U3RyZWFtYWJsZSwgU3RyZWFtYWJsZSwgdm9pZD5cbiAgfCBBc3luY0dlbmVyYXRvcjxTdHJlYW1hYmxlLCBTdHJlYW1hYmxlLCB2b2lkPjtcblxudHlwZSBSZW5kZXJUb29sPFBBUkFNRVRFUlMgZXh0ZW5kcyB6LlpvZFR5cGVBbnkgPSBhbnk+ID0ge1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgcGFyYW1ldGVyczogUEFSQU1FVEVSUztcbiAgZ2VuZXJhdGU/OiBSZW5kZXJlcjxcbiAgICBbXG4gICAgICB6LmluZmVyPFBBUkFNRVRFUlM+LFxuICAgICAge1xuICAgICAgICB0b29sTmFtZTogc3RyaW5nO1xuICAgICAgICB0b29sQ2FsbElkOiBzdHJpbmc7XG4gICAgICB9LFxuICAgIF1cbiAgPjtcbn07XG5cbnR5cGUgUmVuZGVyVGV4dCA9IFJlbmRlcmVyPFxuICBbXG4gICAge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgZnVsbCB0ZXh0IGNvbnRlbnQgZnJvbSB0aGUgbW9kZWwgc28gZmFyLlxuICAgICAgICovXG4gICAgICBjb250ZW50OiBzdHJpbmc7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIG5ldyBhcHBlbmRlZCB0ZXh0IGNvbnRlbnQgZnJvbSB0aGUgbW9kZWwgc2luY2UgdGhlIGxhc3QgYHRleHRgIGNhbGwuXG4gICAgICAgKi9cbiAgICAgIGRlbHRhOiBzdHJpbmc7XG5cbiAgICAgIC8qKlxuICAgICAgICogV2hldGhlciB0aGUgbW9kZWwgaXMgZG9uZSBnZW5lcmF0aW5nIHRleHQuXG4gICAgICAgKiBJZiBgdHJ1ZWAsIHRoZSBgY29udGVudGAgd2lsbCBiZSB0aGUgZmluYWwgb3V0cHV0IGFuZCB0aGlzIGNhbGwgd2lsbCBiZSB0aGUgbGFzdC5cbiAgICAgICAqL1xuICAgICAgZG9uZTogYm9vbGVhbjtcbiAgICB9LFxuICBdXG4+O1xuXG50eXBlIFJlbmRlclJlc3VsdCA9IHtcbiAgdmFsdWU6IFJlYWN0Tm9kZTtcbn0gJiBBd2FpdGVkPFJldHVyblR5cGU8TGFuZ3VhZ2VNb2RlbFYxWydkb1N0cmVhbSddPj47XG5cbmNvbnN0IGRlZmF1bHRUZXh0UmVuZGVyZXI6IFJlbmRlclRleHQgPSAoeyBjb250ZW50IH06IHsgY29udGVudDogc3RyaW5nIH0pID0+XG4gIGNvbnRlbnQ7XG5cbi8qKlxuICogYHN0cmVhbVVJYCBpcyBhIGhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYSBzdHJlYW1hYmxlIFVJIGZyb20gTExNcy5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0cmVhbVVJPFxuICBUT09MUyBleHRlbmRzIHsgW25hbWU6IHN0cmluZ106IHouWm9kVHlwZUFueSB9ID0ge30sXG4+KHtcbiAgbW9kZWwsXG4gIHRvb2xzLFxuICB0b29sQ2hvaWNlLFxuICBzeXN0ZW0sXG4gIHByb21wdCxcbiAgbWVzc2FnZXMsXG4gIG1heFJldHJpZXMsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzLFxuICBpbml0aWFsLFxuICB0ZXh0LFxuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YSxcbiAgb25GaW5pc2gsXG4gIC4uLnNldHRpbmdzXG59OiBDYWxsU2V0dGluZ3MgJlxuICBQcm9tcHQgJiB7XG4gICAgLyoqXG4gICAgICogVGhlIGxhbmd1YWdlIG1vZGVsIHRvIHVzZS5cbiAgICAgKi9cbiAgICBtb2RlbDogTGFuZ3VhZ2VNb2RlbFYxO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRvb2xzIHRoYXQgdGhlIG1vZGVsIGNhbiBjYWxsLiBUaGUgbW9kZWwgbmVlZHMgdG8gc3VwcG9ydCBjYWxsaW5nIHRvb2xzLlxuICAgICAqL1xuICAgIHRvb2xzPzoge1xuICAgICAgW25hbWUgaW4ga2V5b2YgVE9PTFNdOiBSZW5kZXJUb29sPFRPT0xTW25hbWVdPjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRvb2wgY2hvaWNlIHN0cmF0ZWd5LiBEZWZhdWx0OiAnYXV0bycuXG4gICAgICovXG4gICAgdG9vbENob2ljZT86IENvcmVUb29sQ2hvaWNlPFRPT0xTPjtcblxuICAgIHRleHQ/OiBSZW5kZXJUZXh0O1xuICAgIGluaXRpYWw/OiBSZWFjdE5vZGU7XG5cbiAgICAvKipcbkFkZGl0aW9uYWwgcHJvdmlkZXItc3BlY2lmaWMgbWV0YWRhdGEuIFRoZXkgYXJlIHBhc3NlZCB0aHJvdWdoXG50byB0aGUgcHJvdmlkZXIgZnJvbSB0aGUgQUkgU0RLIGFuZCBlbmFibGUgcHJvdmlkZXItc3BlY2lmaWNcbmZ1bmN0aW9uYWxpdHkgdGhhdCBjYW4gYmUgZnVsbHkgZW5jYXBzdWxhdGVkIGluIHRoZSBwcm92aWRlci5cbiAqL1xuICAgIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhPzogUHJvdmlkZXJNZXRhZGF0YTtcblxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIExMTSByZXNwb25zZSBhbmQgdGhlIGZpbmFsIG9iamVjdCB2YWxpZGF0aW9uIGFyZSBmaW5pc2hlZC5cbiAgICAgKi9cbiAgICBvbkZpbmlzaD86IChldmVudDoge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgcmVhc29uIHdoeSB0aGUgZ2VuZXJhdGlvbiBmaW5pc2hlZC5cbiAgICAgICAqL1xuICAgICAgZmluaXNoUmVhc29uOiBGaW5pc2hSZWFzb247XG4gICAgICAvKipcbiAgICAgICAqIFRoZSB0b2tlbiB1c2FnZSBvZiB0aGUgZ2VuZXJhdGVkIHJlc3BvbnNlLlxuICAgICAgICovXG4gICAgICB1c2FnZTogTGFuZ3VhZ2VNb2RlbFVzYWdlO1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgZmluYWwgdWkgbm9kZSB0aGF0IHdhcyBnZW5lcmF0ZWQuXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBSZWFjdE5vZGU7XG4gICAgICAvKipcbiAgICAgICAqIFdhcm5pbmdzIGZyb20gdGhlIG1vZGVsIHByb3ZpZGVyIChlLmcuIHVuc3VwcG9ydGVkIHNldHRpbmdzKVxuICAgICAgICovXG4gICAgICB3YXJuaW5ncz86IENhbGxXYXJuaW5nW107XG4gICAgICAvKipcbiAgICAgICAqIE9wdGlvbmFsIHJhdyByZXNwb25zZSBkYXRhLlxuICAgICAgICovXG4gICAgICByYXdSZXNwb25zZT86IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc3BvbnNlIGhlYWRlcnMuXG4gICAgICAgICAqL1xuICAgICAgICBoZWFkZXJzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgICAgIH07XG4gICAgfSkgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQ7XG4gIH0pOiBQcm9taXNlPFJlbmRlclJlc3VsdD4ge1xuICAvLyBUT0RPOiBSZW1vdmUgdGhlc2UgZXJyb3JzIGFmdGVyIHRoZSBleHBlcmltZW50YWwgcGhhc2UuXG4gIGlmICh0eXBlb2YgbW9kZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2Btb2RlbGAgY2Fubm90IGJlIGEgc3RyaW5nIGluIGBzdHJlYW1VSWAuIFVzZSB0aGUgYWN0dWFsIG1vZGVsIGluc3RhbmNlIGluc3RlYWQuJyxcbiAgICApO1xuICB9XG4gIGlmICgnZnVuY3Rpb25zJyBpbiBzZXR0aW5ncykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdgZnVuY3Rpb25zYCBpcyBub3Qgc3VwcG9ydGVkIGluIGBzdHJlYW1VSWAsIHVzZSBgdG9vbHNgIGluc3RlYWQuJyxcbiAgICApO1xuICB9XG4gIGlmICgncHJvdmlkZXInIGluIHNldHRpbmdzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2Bwcm92aWRlcmAgaXMgbm8gbG9uZ2VyIG5lZWRlZCBpbiBgc3RyZWFtVUlgLiBVc2UgYG1vZGVsYCBpbnN0ZWFkLicsXG4gICAgKTtcbiAgfVxuICBpZiAodG9vbHMpIHtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCB0b29sXSBvZiBPYmplY3QuZW50cmllcyh0b29scykpIHtcbiAgICAgIGlmICgncmVuZGVyJyBpbiB0b29sKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnVG9vbCBkZWZpbml0aW9uIGluIGBzdHJlYW1VSWAgc2hvdWxkIG5vdCBoYXZlIGByZW5kZXJgIHByb3BlcnR5LiBVc2UgYGdlbmVyYXRlYCBpbnN0ZWFkLiBGb3VuZCBpbiB0b29sOiAnICtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgdWkgPSBjcmVhdGVTdHJlYW1hYmxlVUkoaW5pdGlhbCk7XG5cbiAgLy8gVGhlIGRlZmF1bHQgdGV4dCByZW5kZXJlciBqdXN0IHJldHVybnMgdGhlIGNvbnRlbnQgYXMgc3RyaW5nLlxuICBjb25zdCB0ZXh0UmVuZGVyID0gdGV4dCB8fCBkZWZhdWx0VGV4dFJlbmRlcmVyO1xuXG4gIGxldCBmaW5pc2hlZDogUHJvbWlzZTx2b2lkPiB8IHVuZGVmaW5lZDtcblxuICBsZXQgZmluaXNoRXZlbnQ6IHtcbiAgICBmaW5pc2hSZWFzb246IEZpbmlzaFJlYXNvbjtcbiAgICB1c2FnZTogTGFuZ3VhZ2VNb2RlbFVzYWdlO1xuICAgIHdhcm5pbmdzPzogQ2FsbFdhcm5pbmdbXTtcbiAgICByYXdSZXNwb25zZT86IHtcbiAgICAgIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAgIH07XG4gIH0gfCBudWxsID0gbnVsbDtcblxuICBhc3luYyBmdW5jdGlvbiByZW5kZXIoe1xuICAgIGFyZ3MsXG4gICAgcmVuZGVyZXIsXG4gICAgc3RyZWFtYWJsZVVJLFxuICAgIGlzTGFzdENhbGwgPSBmYWxzZSxcbiAgfToge1xuICAgIHJlbmRlcmVyOiB1bmRlZmluZWQgfCBSZW5kZXJlcjxhbnk+O1xuICAgIGFyZ3M6IFtwYXlsb2FkOiBhbnldIHwgW3BheWxvYWQ6IGFueSwgb3B0aW9uczogYW55XTtcbiAgICBzdHJlYW1hYmxlVUk6IFJldHVyblR5cGU8dHlwZW9mIGNyZWF0ZVN0cmVhbWFibGVVST47XG4gICAgaXNMYXN0Q2FsbD86IGJvb2xlYW47XG4gIH0pIHtcbiAgICBpZiAoIXJlbmRlcmVyKSByZXR1cm47XG5cbiAgICAvLyBjcmVhdGUgYSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aGVuIHRoZSByZW5kZXIgY2FsbCBpcyBmaW5pc2hlZC5cbiAgICAvLyBpdCBpcyBhcHBlbmRlZCB0byB0aGUgYGZpbmlzaGVkYCBwcm9taXNlIGNoYWluIHRvIGVuc3VyZSB0aGUgcmVuZGVyIGNhbGxcbiAgICAvLyBpcyBmaW5pc2hlZCBiZWZvcmUgdGhlIG5leHQgcmVuZGVyIGNhbGwgc3RhcnRzLlxuICAgIGNvbnN0IHJlbmRlckZpbmlzaGVkID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2U8dm9pZD4oKTtcbiAgICBmaW5pc2hlZCA9IGZpbmlzaGVkXG4gICAgICA/IGZpbmlzaGVkLnRoZW4oKCkgPT4gcmVuZGVyRmluaXNoZWQucHJvbWlzZSlcbiAgICAgIDogcmVuZGVyRmluaXNoZWQucHJvbWlzZTtcblxuICAgIGNvbnN0IHJlbmRlcmVyUmVzdWx0ID0gcmVuZGVyZXIoLi4uYXJncyk7XG5cbiAgICBpZiAoaXNBc3luY0dlbmVyYXRvcihyZW5kZXJlclJlc3VsdCkgfHwgaXNHZW5lcmF0b3IocmVuZGVyZXJSZXN1bHQpKSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZW5kZXJlclJlc3VsdC5uZXh0KCk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBhd2FpdCB2YWx1ZTtcblxuICAgICAgICBpZiAoaXNMYXN0Q2FsbCAmJiBkb25lKSB7XG4gICAgICAgICAgc3RyZWFtYWJsZVVJLmRvbmUobm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtYWJsZVVJLnVwZGF0ZShub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb25lKSBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgbm9kZSA9IGF3YWl0IHJlbmRlcmVyUmVzdWx0O1xuXG4gICAgICBpZiAoaXNMYXN0Q2FsbCkge1xuICAgICAgICBzdHJlYW1hYmxlVUkuZG9uZShub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbWFibGVVSS51cGRhdGUobm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVzb2x2ZSB0aGUgcHJvbWlzZSB0byBzaWduYWwgdGhhdCB0aGUgcmVuZGVyIGNhbGwgaXMgZmluaXNoZWRcbiAgICByZW5kZXJGaW5pc2hlZC5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gIH1cblxuICBjb25zdCByZXRyeSA9IHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZih7IG1heFJldHJpZXMgfSk7XG4gIGNvbnN0IHZhbGlkYXRlZFByb21wdCA9IHN0YW5kYXJkaXplUHJvbXB0KHtcbiAgICBwcm9tcHQ6IHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0sXG4gICAgdG9vbHM6IHVuZGVmaW5lZCwgLy8gc3RyZWFtVUkgdG9vbHMgZG9uJ3Qgc3VwcG9ydCBtdWx0aS1tb2RhbCB0b29sIHJlc3VsdCBjb252ZXJzaW9uXG4gIH0pO1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXRyeShhc3luYyAoKSA9PlxuICAgIG1vZGVsLmRvU3RyZWFtKHtcbiAgICAgIG1vZGU6IHtcbiAgICAgICAgdHlwZTogJ3JlZ3VsYXInLFxuICAgICAgICAuLi5wcmVwYXJlVG9vbHNBbmRUb29sQ2hvaWNlKHtcbiAgICAgICAgICB0b29scyxcbiAgICAgICAgICB0b29sQ2hvaWNlLFxuICAgICAgICAgIGFjdGl2ZVRvb2xzOiB1bmRlZmluZWQsXG4gICAgICAgIH0pLFxuICAgICAgfSxcbiAgICAgIC4uLnByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpLFxuICAgICAgaW5wdXRGb3JtYXQ6IHZhbGlkYXRlZFByb21wdC50eXBlLFxuICAgICAgcHJvbXB0OiBhd2FpdCBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgICAgICAgcHJvbXB0OiB2YWxpZGF0ZWRQcm9tcHQsXG4gICAgICAgIG1vZGVsU3VwcG9ydHNJbWFnZVVybHM6IG1vZGVsLnN1cHBvcnRzSW1hZ2VVcmxzLFxuICAgICAgICBtb2RlbFN1cHBvcnRzVXJsOiBtb2RlbC5zdXBwb3J0c1VybCxcbiAgICAgIH0pLFxuICAgICAgcHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgaGVhZGVycyxcbiAgICB9KSxcbiAgKTtcblxuICAvLyBGb3IgdGhlIHN0cmVhbSBhbmQgY29uc3VtZSBpdCBhc3luY2hyb25vdXNseTpcbiAgY29uc3QgW3N0cmVhbSwgZm9ya2VkU3RyZWFtXSA9IHJlc3VsdC5zdHJlYW0udGVlKCk7XG4gIChhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBjb250ZW50ID0gJyc7XG4gICAgICBsZXQgaGFzVG9vbENhbGwgPSBmYWxzZTtcblxuICAgICAgY29uc3QgcmVhZGVyID0gZm9ya2VkU3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpIGJyZWFrO1xuXG4gICAgICAgIHN3aXRjaCAodmFsdWUudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ3RleHQtZGVsdGEnOiB7XG4gICAgICAgICAgICBjb250ZW50ICs9IHZhbHVlLnRleHREZWx0YTtcbiAgICAgICAgICAgIHJlbmRlcih7XG4gICAgICAgICAgICAgIHJlbmRlcmVyOiB0ZXh0UmVuZGVyLFxuICAgICAgICAgICAgICBhcmdzOiBbeyBjb250ZW50LCBkb25lOiBmYWxzZSwgZGVsdGE6IHZhbHVlLnRleHREZWx0YSB9XSxcbiAgICAgICAgICAgICAgc3RyZWFtYWJsZVVJOiB1aSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAndG9vbC1jYWxsLWRlbHRhJzoge1xuICAgICAgICAgICAgaGFzVG9vbENhbGwgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAndG9vbC1jYWxsJzoge1xuICAgICAgICAgICAgY29uc3QgdG9vbE5hbWUgPSB2YWx1ZS50b29sTmFtZSBhcyBrZXlvZiBUT09MUyAmIHN0cmluZztcblxuICAgICAgICAgICAgaWYgKCF0b29scykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgTm9TdWNoVG9vbEVycm9yKHsgdG9vbE5hbWUgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHRvb2wgPSB0b29sc1t0b29sTmFtZV07XG4gICAgICAgICAgICBpZiAoIXRvb2wpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vU3VjaFRvb2xFcnJvcih7XG4gICAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlVG9vbHM6IE9iamVjdC5rZXlzKHRvb2xzKSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhhc1Rvb2xDYWxsID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gc2FmZVBhcnNlSlNPTih7XG4gICAgICAgICAgICAgIHRleHQ6IHZhbHVlLmFyZ3MsXG4gICAgICAgICAgICAgIHNjaGVtYTogdG9vbC5wYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChwYXJzZVJlc3VsdC5zdWNjZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvcih7XG4gICAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgdG9vbEFyZ3M6IHZhbHVlLmFyZ3MsXG4gICAgICAgICAgICAgICAgY2F1c2U6IHBhcnNlUmVzdWx0LmVycm9yLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVuZGVyKHtcbiAgICAgICAgICAgICAgcmVuZGVyZXI6IHRvb2wuZ2VuZXJhdGUsXG4gICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICBwYXJzZVJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHZhbHVlLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgc3RyZWFtYWJsZVVJOiB1aSxcbiAgICAgICAgICAgICAgaXNMYXN0Q2FsbDogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdlcnJvcic6IHtcbiAgICAgICAgICAgIHRocm93IHZhbHVlLmVycm9yO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2ZpbmlzaCc6IHtcbiAgICAgICAgICAgIGZpbmlzaEV2ZW50ID0ge1xuICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IHZhbHVlLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgdXNhZ2U6IGNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZSh2YWx1ZS51c2FnZSksXG4gICAgICAgICAgICAgIHdhcm5pbmdzOiByZXN1bHQud2FybmluZ3MsXG4gICAgICAgICAgICAgIHJhd1Jlc3BvbnNlOiByZXN1bHQucmF3UmVzcG9uc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFzVG9vbENhbGwpIHtcbiAgICAgICAgcmVuZGVyKHtcbiAgICAgICAgICByZW5kZXJlcjogdGV4dFJlbmRlcixcbiAgICAgICAgICBhcmdzOiBbeyBjb250ZW50LCBkb25lOiB0cnVlIH1dLFxuICAgICAgICAgIHN0cmVhbWFibGVVSTogdWksXG4gICAgICAgICAgaXNMYXN0Q2FsbDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IGZpbmlzaGVkO1xuXG4gICAgICBpZiAoZmluaXNoRXZlbnQgJiYgb25GaW5pc2gpIHtcbiAgICAgICAgYXdhaXQgb25GaW5pc2goe1xuICAgICAgICAgIC4uLmZpbmlzaEV2ZW50LFxuICAgICAgICAgIHZhbHVlOiB1aS52YWx1ZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIER1cmluZyB0aGUgc3RyZWFtIHJlbmRlcmluZywgd2UgZG9uJ3Qgd2FudCB0byB0aHJvdyB0aGUgZXJyb3IgdG8gdGhlXG4gICAgICAvLyBwYXJlbnQgc2NvcGUgYnV0IG9ubHkgbGV0IHRoZSBSZWFjdCdzIGVycm9yIGJvdW5kYXJ5IHRvIGNhdGNoIGl0LlxuICAgICAgdWkuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfSkoKTtcblxuICByZXR1cm4ge1xuICAgIC4uLnJlc3VsdCxcbiAgICBzdHJlYW0sXG4gICAgdmFsdWU6IHVpLnZhbHVlLFxuICB9O1xufVxuIiwiaW1wb3J0IHsgQUlTREtFcnJvciB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuXG5jb25zdCBuYW1lID0gJ0FJX0Rvd25sb2FkRXJyb3InO1xuY29uc3QgbWFya2VyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWV9YDtcbmNvbnN0IHN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyKTtcblxuZXhwb3J0IGNsYXNzIERvd25sb2FkRXJyb3IgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgcHJpdmF0ZSByZWFkb25seSBbc3ltYm9sXSA9IHRydWU7IC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuXG4gIHJlYWRvbmx5IHVybDogc3RyaW5nO1xuICByZWFkb25seSBzdGF0dXNDb2RlPzogbnVtYmVyO1xuICByZWFkb25seSBzdGF0dXNUZXh0Pzogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHtcbiAgICB1cmwsXG4gICAgc3RhdHVzQ29kZSxcbiAgICBzdGF0dXNUZXh0LFxuICAgIGNhdXNlLFxuICAgIG1lc3NhZ2UgPSBjYXVzZSA9PSBudWxsXG4gICAgICA/IGBGYWlsZWQgdG8gZG93bmxvYWQgJHt1cmx9OiAke3N0YXR1c0NvZGV9ICR7c3RhdHVzVGV4dH1gXG4gICAgICA6IGBGYWlsZWQgdG8gZG93bmxvYWQgJHt1cmx9OiAke2NhdXNlfWAsXG4gIH06IHtcbiAgICB1cmw6IHN0cmluZztcbiAgICBzdGF0dXNDb2RlPzogbnVtYmVyO1xuICAgIHN0YXR1c1RleHQ/OiBzdHJpbmc7XG4gICAgbWVzc2FnZT86IHN0cmluZztcbiAgICBjYXVzZT86IHVua25vd247XG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWUsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuXG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICB0aGlzLnN0YXR1c1RleHQgPSBzdGF0dXNUZXh0O1xuICB9XG5cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBEb3dubG9hZEVycm9yIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcik7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNEb3dubG9hZEVycm9yKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgRG93bmxvYWRFcnJvciB7XG4gICAgcmV0dXJuIChcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgIGVycm9yLm5hbWUgPT09IG5hbWUgJiZcbiAgICAgIHR5cGVvZiAoZXJyb3IgYXMgRG93bmxvYWRFcnJvcikudXJsID09PSAnc3RyaW5nJyAmJlxuICAgICAgKChlcnJvciBhcyBEb3dubG9hZEVycm9yKS5zdGF0dXNDb2RlID09IG51bGwgfHxcbiAgICAgICAgdHlwZW9mIChlcnJvciBhcyBEb3dubG9hZEVycm9yKS5zdGF0dXNDb2RlID09PSAnbnVtYmVyJykgJiZcbiAgICAgICgoZXJyb3IgYXMgRG93bmxvYWRFcnJvcikuc3RhdHVzVGV4dCA9PSBudWxsIHx8XG4gICAgICAgIHR5cGVvZiAoZXJyb3IgYXMgRG93bmxvYWRFcnJvcikuc3RhdHVzVGV4dCA9PT0gJ3N0cmluZycpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgIHN0YXR1c0NvZGU6IHRoaXMuc3RhdHVzQ29kZSxcbiAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgIGNhdXNlOiB0aGlzLmNhdXNlLFxuICAgIH07XG4gIH1cbn1cbiIsImltcG9ydCB7IERvd25sb2FkRXJyb3IgfSBmcm9tICcuL2Rvd25sb2FkLWVycm9yJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkKHtcbiAgdXJsLFxuICBmZXRjaEltcGxlbWVudGF0aW9uID0gZmV0Y2gsXG59OiB7XG4gIHVybDogVVJMO1xuICBmZXRjaEltcGxlbWVudGF0aW9uPzogdHlwZW9mIGZldGNoO1xufSk6IFByb21pc2U8e1xuICBkYXRhOiBVaW50OEFycmF5O1xuICBtaW1lVHlwZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xufT4ge1xuICBjb25zdCB1cmxUZXh0ID0gdXJsLnRvU3RyaW5nKCk7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaEltcGxlbWVudGF0aW9uKHVybFRleHQpO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IERvd25sb2FkRXJyb3Ioe1xuICAgICAgICB1cmw6IHVybFRleHQsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBuZXcgVWludDhBcnJheShhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpKSxcbiAgICAgIG1pbWVUeXBlOiByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykgPz8gdW5kZWZpbmVkLFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKERvd25sb2FkRXJyb3IuaXNJbnN0YW5jZShlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBEb3dubG9hZEVycm9yKHsgdXJsOiB1cmxUZXh0LCBjYXVzZTogZXJyb3IgfSk7XG4gIH1cbn1cbiIsImNvbnN0IG1pbWVUeXBlU2lnbmF0dXJlcyA9IFtcbiAgeyBtaW1lVHlwZTogJ2ltYWdlL2dpZicgYXMgY29uc3QsIGJ5dGVzOiBbMHg0NywgMHg0OSwgMHg0Nl0gfSxcbiAgeyBtaW1lVHlwZTogJ2ltYWdlL3BuZycgYXMgY29uc3QsIGJ5dGVzOiBbMHg4OSwgMHg1MCwgMHg0ZSwgMHg0N10gfSxcbiAgeyBtaW1lVHlwZTogJ2ltYWdlL2pwZWcnIGFzIGNvbnN0LCBieXRlczogWzB4ZmYsIDB4ZDhdIH0sXG4gIHsgbWltZVR5cGU6ICdpbWFnZS93ZWJwJyBhcyBjb25zdCwgYnl0ZXM6IFsweDUyLCAweDQ5LCAweDQ2LCAweDQ2XSB9LFxuXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdEltYWdlTWltZVR5cGUoXG4gIGltYWdlOiBVaW50OEFycmF5LFxuKTogJ2ltYWdlL2pwZWcnIHwgJ2ltYWdlL3BuZycgfCAnaW1hZ2UvZ2lmJyB8ICdpbWFnZS93ZWJwJyB8IHVuZGVmaW5lZCB7XG4gIGZvciAoY29uc3QgeyBieXRlcywgbWltZVR5cGUgfSBvZiBtaW1lVHlwZVNpZ25hdHVyZXMpIHtcbiAgICBpZiAoXG4gICAgICBpbWFnZS5sZW5ndGggPj0gYnl0ZXMubGVuZ3RoICYmXG4gICAgICBieXRlcy5ldmVyeSgoYnl0ZSwgaW5kZXgpID0+IGltYWdlW2luZGV4XSA9PT0gYnl0ZSlcbiAgICApIHtcbiAgICAgIHJldHVybiBtaW1lVHlwZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuIiwiaW1wb3J0IHtcbiAgY29udmVydEJhc2U2NFRvVWludDhBcnJheSxcbiAgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NCxcbn0gZnJvbSAnQGFpLXNkay9wcm92aWRlci11dGlscyc7XG5pbXBvcnQgeyBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvciB9IGZyb20gJy4vaW52YWxpZC1kYXRhLWNvbnRlbnQtZXJyb3InO1xuaW1wb3J0IHsgeiB9IGZyb20gJ3pvZCc7XG5cbi8qKlxuRGF0YSBjb250ZW50LiBDYW4gZWl0aGVyIGJlIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nLCBhIFVpbnQ4QXJyYXksIGFuIEFycmF5QnVmZmVyLCBvciBhIEJ1ZmZlci5cbiAqL1xuZXhwb3J0IHR5cGUgRGF0YUNvbnRlbnQgPSBzdHJpbmcgfCBVaW50OEFycmF5IHwgQXJyYXlCdWZmZXIgfCBCdWZmZXI7XG5cbi8qKlxuQGludGVybmFsXG4gKi9cbmV4cG9ydCBjb25zdCBkYXRhQ29udGVudFNjaGVtYTogei5ab2RUeXBlPERhdGFDb250ZW50PiA9IHoudW5pb24oW1xuICB6LnN0cmluZygpLFxuICB6Lmluc3RhbmNlb2YoVWludDhBcnJheSksXG4gIHouaW5zdGFuY2VvZihBcnJheUJ1ZmZlciksXG4gIHouY3VzdG9tKFxuICAgIC8vIEJ1ZmZlciBtaWdodCBub3QgYmUgYXZhaWxhYmxlIGluIHNvbWUgZW52aXJvbm1lbnRzIHN1Y2ggYXMgQ2xvdWRGbGFyZTpcbiAgICAodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBCdWZmZXIgPT5cbiAgICAgIGdsb2JhbFRoaXMuQnVmZmVyPy5pc0J1ZmZlcih2YWx1ZSkgPz8gZmFsc2UsXG4gICAgeyBtZXNzYWdlOiAnTXVzdCBiZSBhIEJ1ZmZlcicgfSxcbiAgKSxcbl0pO1xuXG4vKipcbkNvbnZlcnRzIGRhdGEgY29udGVudCB0byBhIGJhc2U2NC1lbmNvZGVkIHN0cmluZy5cblxuQHBhcmFtIGNvbnRlbnQgLSBEYXRhIGNvbnRlbnQgdG8gY29udmVydC5cbkByZXR1cm5zIEJhc2U2NC1lbmNvZGVkIHN0cmluZy5cbiovXG5leHBvcnQgZnVuY3Rpb24gY29udmVydERhdGFDb250ZW50VG9CYXNlNjRTdHJpbmcoY29udGVudDogRGF0YUNvbnRlbnQpOiBzdHJpbmcge1xuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQobmV3IFVpbnQ4QXJyYXkoY29udGVudCkpO1xuICB9XG5cbiAgcmV0dXJuIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQoY29udGVudCk7XG59XG5cbi8qKlxuQ29udmVydHMgZGF0YSBjb250ZW50IHRvIGEgVWludDhBcnJheS5cblxuQHBhcmFtIGNvbnRlbnQgLSBEYXRhIGNvbnRlbnQgdG8gY29udmVydC5cbkByZXR1cm5zIFVpbnQ4QXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoXG4gIGNvbnRlbnQ6IERhdGFDb250ZW50LFxuKTogVWludDhBcnJheSB7XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY29udmVydEJhc2U2NFRvVWludDhBcnJheShjb250ZW50KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWREYXRhQ29udGVudEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAnSW52YWxpZCBkYXRhIGNvbnRlbnQuIENvbnRlbnQgc3RyaW5nIGlzIG5vdCBhIGJhc2U2NC1lbmNvZGVkIG1lZGlhLicsXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoY29udGVudCk7XG4gIH1cblxuICB0aHJvdyBuZXcgSW52YWxpZERhdGFDb250ZW50RXJyb3IoeyBjb250ZW50IH0pO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgVWludDhBcnJheSB0byBhIHN0cmluZyBvZiB0ZXh0LlxuICpcbiAqIEBwYXJhbSB1aW50OEFycmF5IC0gVGhlIFVpbnQ4QXJyYXkgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFVpbnQ4QXJyYXlUb1RleHQodWludDhBcnJheTogVWludDhBcnJheSk6IHN0cmluZyB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZSh1aW50OEFycmF5KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGRlY29kaW5nIFVpbnQ4QXJyYXkgdG8gdGV4dCcpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBBSVNES0Vycm9yIH0gZnJvbSAnQGFpLXNkay9wcm92aWRlcic7XG5cbmNvbnN0IG5hbWUgPSAnQUlfSW52YWxpZERhdGFDb250ZW50RXJyb3InO1xuY29uc3QgbWFya2VyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWV9YDtcbmNvbnN0IHN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyKTtcblxuZXhwb3J0IGNsYXNzIEludmFsaWREYXRhQ29udGVudEVycm9yIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgW3N5bWJvbF0gPSB0cnVlOyAvLyB1c2VkIGluIGlzSW5zdGFuY2VcblxuICByZWFkb25seSBjb250ZW50OiB1bmtub3duO1xuXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb250ZW50LFxuICAgIGNhdXNlLFxuICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBkYXRhIGNvbnRlbnQuIEV4cGVjdGVkIGEgYmFzZTY0IHN0cmluZywgVWludDhBcnJheSwgQXJyYXlCdWZmZXIsIG9yIEJ1ZmZlciwgYnV0IGdvdCAke3R5cGVvZiBjb250ZW50fS5gLFxuICB9OiB7XG4gICAgY29udGVudDogdW5rbm93bjtcbiAgICBjYXVzZT86IHVua25vd247XG4gICAgbWVzc2FnZT86IHN0cmluZztcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZSwgbWVzc2FnZSwgY2F1c2UgfSk7XG5cbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICB9XG5cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvciB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzSW52YWxpZERhdGFDb250ZW50RXJyb3IoXG4gICAgZXJyb3I6IHVua25vd24sXG4gICk6IGVycm9yIGlzIEludmFsaWREYXRhQ29udGVudEVycm9yIHtcbiAgICByZXR1cm4gKFxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgZXJyb3IubmFtZSA9PT0gbmFtZSAmJlxuICAgICAgKGVycm9yIGFzIEludmFsaWREYXRhQ29udGVudEVycm9yKS5jb250ZW50ICE9IG51bGxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIGNhdXNlOiB0aGlzLmNhdXNlLFxuICAgICAgY29udGVudDogdGhpcy5jb250ZW50LFxuICAgIH07XG4gIH1cbn1cbiIsImltcG9ydCB7IEFJU0RLRXJyb3IgfSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyJztcblxuY29uc3QgbmFtZSA9ICdBSV9JbnZhbGlkTWVzc2FnZVJvbGVFcnJvcic7XG5jb25zdCBtYXJrZXIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZX1gO1xuY29uc3Qgc3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIpO1xuXG5leHBvcnQgY2xhc3MgSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgcHJpdmF0ZSByZWFkb25seSBbc3ltYm9sXSA9IHRydWU7IC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuXG4gIHJlYWRvbmx5IHJvbGU6IHN0cmluZztcblxuICBjb25zdHJ1Y3Rvcih7XG4gICAgcm9sZSxcbiAgICBtZXNzYWdlID0gYEludmFsaWQgbWVzc2FnZSByb2xlOiAnJHtyb2xlfScuIE11c3QgYmUgb25lIG9mOiBcInN5c3RlbVwiLCBcInVzZXJcIiwgXCJhc3Npc3RhbnRcIiwgXCJ0b29sXCIuYCxcbiAgfToge1xuICAgIHJvbGU6IHN0cmluZztcbiAgICBtZXNzYWdlPzogc3RyaW5nO1xuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lLCBtZXNzYWdlIH0pO1xuXG4gICAgdGhpcy5yb2xlID0gcm9sZTtcbiAgfVxuXG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3Ige1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc0ludmFsaWRNZXNzYWdlUm9sZUVycm9yKFxuICAgIGVycm9yOiB1bmtub3duLFxuICApOiBlcnJvciBpcyBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvciB7XG4gICAgcmV0dXJuIChcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgIGVycm9yLm5hbWUgPT09IG5hbWUgJiZcbiAgICAgIHR5cGVvZiAoZXJyb3IgYXMgSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IpLnJvbGUgPT09ICdzdHJpbmcnXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG5cbiAgICAgIHJvbGU6IHRoaXMucm9sZSxcbiAgICB9O1xuICB9XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gc3BsaXREYXRhVXJsKGRhdGFVcmw6IHN0cmluZyk6IHtcbiAgbWltZVR5cGU6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgYmFzZTY0Q29udGVudDogc3RyaW5nIHwgdW5kZWZpbmVkO1xufSB7XG4gIHRyeSB7XG4gICAgY29uc3QgW2hlYWRlciwgYmFzZTY0Q29udGVudF0gPSBkYXRhVXJsLnNwbGl0KCcsJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbWVUeXBlOiBoZWFkZXIuc3BsaXQoJzsnKVswXS5zcGxpdCgnOicpWzFdLFxuICAgICAgYmFzZTY0Q29udGVudCxcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBtaW1lVHlwZTogdW5kZWZpbmVkLFxuICAgICAgYmFzZTY0Q29udGVudDogdW5kZWZpbmVkLFxuICAgIH07XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIExhbmd1YWdlTW9kZWxWMUZpbGVQYXJ0LFxuICBMYW5ndWFnZU1vZGVsVjFJbWFnZVBhcnQsXG4gIExhbmd1YWdlTW9kZWxWMU1lc3NhZ2UsXG4gIExhbmd1YWdlTW9kZWxWMVByb21wdCxcbiAgTGFuZ3VhZ2VNb2RlbFYxVGV4dFBhcnQsXG59IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuaW1wb3J0IHsgZG93bmxvYWQgfSBmcm9tICcuLi8uLi91dGlsL2Rvd25sb2FkJztcbmltcG9ydCB7IENvcmVNZXNzYWdlIH0gZnJvbSAnLi4vcHJvbXB0L21lc3NhZ2UnO1xuaW1wb3J0IHsgZGV0ZWN0SW1hZ2VNaW1lVHlwZSB9IGZyb20gJy4uL3V0aWwvZGV0ZWN0LWltYWdlLW1pbWV0eXBlJztcbmltcG9ydCB7IEZpbGVQYXJ0LCBJbWFnZVBhcnQsIFRleHRQYXJ0IH0gZnJvbSAnLi9jb250ZW50LXBhcnQnO1xuaW1wb3J0IHtcbiAgY29udmVydERhdGFDb250ZW50VG9CYXNlNjRTdHJpbmcsXG4gIGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheSxcbiAgRGF0YUNvbnRlbnQsXG59IGZyb20gJy4vZGF0YS1jb250ZW50JztcbmltcG9ydCB7IEludmFsaWRNZXNzYWdlUm9sZUVycm9yIH0gZnJvbSAnLi9pbnZhbGlkLW1lc3NhZ2Utcm9sZS1lcnJvcic7XG5pbXBvcnQgeyBzcGxpdERhdGFVcmwgfSBmcm9tICcuL3NwbGl0LWRhdGEtdXJsJztcbmltcG9ydCB7IFN0YW5kYXJkaXplZFByb21wdCB9IGZyb20gJy4vc3RhbmRhcmRpemUtcHJvbXB0JztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICBwcm9tcHQsXG4gIG1vZGVsU3VwcG9ydHNJbWFnZVVybHMgPSB0cnVlLFxuICBtb2RlbFN1cHBvcnRzVXJsID0gKCkgPT4gZmFsc2UsXG4gIGRvd25sb2FkSW1wbGVtZW50YXRpb24gPSBkb3dubG9hZCxcbn06IHtcbiAgcHJvbXB0OiBTdGFuZGFyZGl6ZWRQcm9tcHQ7XG4gIG1vZGVsU3VwcG9ydHNJbWFnZVVybHM6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG4gIG1vZGVsU3VwcG9ydHNVcmw6IHVuZGVmaW5lZCB8ICgodXJsOiBVUkwpID0+IGJvb2xlYW4pO1xuICBkb3dubG9hZEltcGxlbWVudGF0aW9uPzogdHlwZW9mIGRvd25sb2FkO1xufSk6IFByb21pc2U8TGFuZ3VhZ2VNb2RlbFYxUHJvbXB0PiB7XG4gIGNvbnN0IGRvd25sb2FkZWRBc3NldHMgPSBhd2FpdCBkb3dubG9hZEFzc2V0cyhcbiAgICBwcm9tcHQubWVzc2FnZXMsXG4gICAgZG93bmxvYWRJbXBsZW1lbnRhdGlvbixcbiAgICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzLFxuICAgIG1vZGVsU3VwcG9ydHNVcmwsXG4gICk7XG5cbiAgcmV0dXJuIFtcbiAgICAuLi4ocHJvbXB0LnN5c3RlbSAhPSBudWxsXG4gICAgICA/IFt7IHJvbGU6ICdzeXN0ZW0nIGFzIGNvbnN0LCBjb250ZW50OiBwcm9tcHQuc3lzdGVtIH1dXG4gICAgICA6IFtdKSxcbiAgICAuLi5wcm9tcHQubWVzc2FnZXMubWFwKG1lc3NhZ2UgPT5cbiAgICAgIGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxNZXNzYWdlKG1lc3NhZ2UsIGRvd25sb2FkZWRBc3NldHMpLFxuICAgICksXG4gIF07XG59XG5cbi8qKlxuICogQ29udmVydCBhIENvcmVNZXNzYWdlIHRvIGEgTGFuZ3VhZ2VNb2RlbFYxTWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSBUaGUgQ29yZU1lc3NhZ2UgdG8gY29udmVydC5cbiAqIEBwYXJhbSBkb3dubG9hZGVkQXNzZXRzIEEgbWFwIG9mIFVSTHMgdG8gdGhlaXIgZG93bmxvYWRlZCBkYXRhLiBPbmx5XG4gKiAgIGF2YWlsYWJsZSBpZiB0aGUgbW9kZWwgZG9lcyBub3Qgc3VwcG9ydCBVUkxzLCBudWxsIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxNZXNzYWdlKFxuICBtZXNzYWdlOiBDb3JlTWVzc2FnZSxcbiAgZG93bmxvYWRlZEFzc2V0czogUmVjb3JkPFxuICAgIHN0cmluZyxcbiAgICB7IG1pbWVUeXBlOiBzdHJpbmcgfCB1bmRlZmluZWQ7IGRhdGE6IFVpbnQ4QXJyYXkgfVxuICA+LFxuKTogTGFuZ3VhZ2VNb2RlbFYxTWVzc2FnZSB7XG4gIGNvbnN0IHJvbGUgPSBtZXNzYWdlLnJvbGU7XG4gIHN3aXRjaCAocm9sZSkge1xuICAgIGNhc2UgJ3N5c3RlbSc6IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6ICdzeXN0ZW0nLFxuICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQsXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IG1lc3NhZ2UuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNhc2UgJ3VzZXInOiB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgY29udGVudDogW3sgdHlwZTogJ3RleHQnLCB0ZXh0OiBtZXNzYWdlLmNvbnRlbnQgfV0sXG4gICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbWVzc2FnZS5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnRcbiAgICAgICAgICAubWFwKHBhcnQgPT4gY29udmVydFBhcnRUb0xhbmd1YWdlTW9kZWxQYXJ0KHBhcnQsIGRvd25sb2FkZWRBc3NldHMpKVxuICAgICAgICAgIC8vIHJlbW92ZSBlbXB0eSB0ZXh0IHBhcnRzOlxuICAgICAgICAgIC5maWx0ZXIocGFydCA9PiBwYXJ0LnR5cGUgIT09ICd0ZXh0JyB8fCBwYXJ0LnRleHQgIT09ICcnKSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbWVzc2FnZS5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY2FzZSAnYXNzaXN0YW50Jzoge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgICAgY29udGVudDogW3sgdHlwZTogJ3RleHQnLCB0ZXh0OiBtZXNzYWdlLmNvbnRlbnQgfV0sXG4gICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbWVzc2FnZS5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudFxuICAgICAgICAgIC5maWx0ZXIoXG4gICAgICAgICAgICAvLyByZW1vdmUgZW1wdHkgdGV4dCBwYXJ0czpcbiAgICAgICAgICAgIHBhcnQgPT4gcGFydC50eXBlICE9PSAndGV4dCcgfHwgcGFydC50ZXh0ICE9PSAnJyxcbiAgICAgICAgICApXG4gICAgICAgICAgLm1hcChwYXJ0ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEsIC4uLnJlc3QgfSA9IHBhcnQ7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5yZXN0LFxuICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSksXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IG1lc3NhZ2UuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNhc2UgJ3Rvb2wnOiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiAndG9vbCcsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5tYXAocGFydCA9PiAoe1xuICAgICAgICAgIHR5cGU6ICd0b29sLXJlc3VsdCcsXG4gICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgIHJlc3VsdDogcGFydC5yZXN1bHQsXG4gICAgICAgICAgY29udGVudDogcGFydC5leHBlcmltZW50YWxfY29udGVudCxcbiAgICAgICAgICBpc0Vycm9yOiBwYXJ0LmlzRXJyb3IsXG4gICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgfSkpLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBtZXNzYWdlLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrOiBuZXZlciA9IHJvbGU7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IoeyByb2xlOiBfZXhoYXVzdGl2ZUNoZWNrIH0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERvd25sb2FkcyBpbWFnZXMgYW5kIGZpbGVzIGZyb20gVVJMcyBpbiB0aGUgbWVzc2FnZXMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkQXNzZXRzKFxuICBtZXNzYWdlczogQ29yZU1lc3NhZ2VbXSxcbiAgZG93bmxvYWRJbXBsZW1lbnRhdGlvbjogdHlwZW9mIGRvd25sb2FkLFxuICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzOiBib29sZWFuIHwgdW5kZWZpbmVkLFxuICBtb2RlbFN1cHBvcnRzVXJsOiAodXJsOiBVUkwpID0+IGJvb2xlYW4sXG4pOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIHsgbWltZVR5cGU6IHN0cmluZyB8IHVuZGVmaW5lZDsgZGF0YTogVWludDhBcnJheSB9Pj4ge1xuICBjb25zdCB1cmxzID0gbWVzc2FnZXNcbiAgICAuZmlsdGVyKG1lc3NhZ2UgPT4gbWVzc2FnZS5yb2xlID09PSAndXNlcicpXG4gICAgLm1hcChtZXNzYWdlID0+IG1lc3NhZ2UuY29udGVudClcbiAgICAuZmlsdGVyKChjb250ZW50KTogY29udGVudCBpcyBBcnJheTxUZXh0UGFydCB8IEltYWdlUGFydCB8IEZpbGVQYXJ0PiA9PlxuICAgICAgQXJyYXkuaXNBcnJheShjb250ZW50KSxcbiAgICApXG4gICAgLmZsYXQoKVxuICAgIC5maWx0ZXIoXG4gICAgICAocGFydCk6IHBhcnQgaXMgSW1hZ2VQYXJ0IHwgRmlsZVBhcnQgPT5cbiAgICAgICAgcGFydC50eXBlID09PSAnaW1hZ2UnIHx8IHBhcnQudHlwZSA9PT0gJ2ZpbGUnLFxuICAgIClcbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgb3V0IGltYWdlIHBhcnRzIGlmIHRoZSBtb2RlbCBzdXBwb3J0cyBpbWFnZSBVUkxzLCBiZWZvcmUgbGV0dGluZyBpdFxuICAgICAqIGRlY2lkZSBpZiBpdCBzdXBwb3J0cyBhIHBhcnRpY3VsYXIgVVJMLlxuICAgICAqL1xuICAgIC5maWx0ZXIoXG4gICAgICAocGFydCk6IHBhcnQgaXMgSW1hZ2VQYXJ0IHwgRmlsZVBhcnQgPT5cbiAgICAgICAgIShwYXJ0LnR5cGUgPT09ICdpbWFnZScgJiYgbW9kZWxTdXBwb3J0c0ltYWdlVXJscyA9PT0gdHJ1ZSksXG4gICAgKVxuICAgIC5tYXAocGFydCA9PiAocGFydC50eXBlID09PSAnaW1hZ2UnID8gcGFydC5pbWFnZSA6IHBhcnQuZGF0YSkpXG4gICAgLm1hcChwYXJ0ID0+XG4gICAgICAvLyBzdXBwb3J0IHN0cmluZyB1cmxzOlxuICAgICAgdHlwZW9mIHBhcnQgPT09ICdzdHJpbmcnICYmXG4gICAgICAocGFydC5zdGFydHNXaXRoKCdodHRwOicpIHx8IHBhcnQuc3RhcnRzV2l0aCgnaHR0cHM6JykpXG4gICAgICAgID8gbmV3IFVSTChwYXJ0KVxuICAgICAgICA6IHBhcnQsXG4gICAgKVxuICAgIC5maWx0ZXIoKGltYWdlKTogaW1hZ2UgaXMgVVJMID0+IGltYWdlIGluc3RhbmNlb2YgVVJMKVxuICAgIC8qKlxuICAgICAqIEZpbHRlciBvdXQgVVJMcyB0aGF0IHRoZSBtb2RlbCBzdXBwb3J0cyBuYXRpdmVseSwgc28gd2UgZG9uJ3QgZG93bmxvYWQgdGhlbS5cbiAgICAgKi9cbiAgICAuZmlsdGVyKHVybCA9PiAhbW9kZWxTdXBwb3J0c1VybCh1cmwpKTtcblxuICAvLyBkb3dubG9hZCBpbiBwYXJhbGxlbDpcbiAgY29uc3QgZG93bmxvYWRlZEltYWdlcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIHVybHMubWFwKGFzeW5jIHVybCA9PiAoe1xuICAgICAgdXJsLFxuICAgICAgZGF0YTogYXdhaXQgZG93bmxvYWRJbXBsZW1lbnRhdGlvbih7IHVybCB9KSxcbiAgICB9KSksXG4gICk7XG5cbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBkb3dubG9hZGVkSW1hZ2VzLm1hcCgoeyB1cmwsIGRhdGEgfSkgPT4gW3VybC50b1N0cmluZygpLCBkYXRhXSksXG4gICk7XG59XG5cbi8qKlxuICogQ29udmVydCBwYXJ0IG9mIGEgbWVzc2FnZSB0byBhIExhbmd1YWdlTW9kZWxWMVBhcnQuXG4gKiBAcGFyYW0gcGFydCBUaGUgcGFydCB0byBjb252ZXJ0LlxuICogQHBhcmFtIGRvd25sb2FkZWRBc3NldHMgQSBtYXAgb2YgVVJMcyB0byB0aGVpciBkb3dubG9hZGVkIGRhdGEuIE9ubHlcbiAqICBhdmFpbGFibGUgaWYgdGhlIG1vZGVsIGRvZXMgbm90IHN1cHBvcnQgVVJMcywgbnVsbCBvdGhlcndpc2UuXG4gKlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCBwYXJ0LlxuICovXG5mdW5jdGlvbiBjb252ZXJ0UGFydFRvTGFuZ3VhZ2VNb2RlbFBhcnQoXG4gIHBhcnQ6IFRleHRQYXJ0IHwgSW1hZ2VQYXJ0IHwgRmlsZVBhcnQsXG4gIGRvd25sb2FkZWRBc3NldHM6IFJlY29yZDxcbiAgICBzdHJpbmcsXG4gICAgeyBtaW1lVHlwZTogc3RyaW5nIHwgdW5kZWZpbmVkOyBkYXRhOiBVaW50OEFycmF5IH1cbiAgPixcbik6XG4gIHwgTGFuZ3VhZ2VNb2RlbFYxVGV4dFBhcnRcbiAgfCBMYW5ndWFnZU1vZGVsVjFJbWFnZVBhcnRcbiAgfCBMYW5ndWFnZU1vZGVsVjFGaWxlUGFydCB7XG4gIGlmIChwYXJ0LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAndGV4dCcsXG4gICAgICB0ZXh0OiBwYXJ0LnRleHQsXG4gICAgICBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhLFxuICAgIH07XG4gIH1cblxuICBsZXQgbWltZVR5cGU6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHBhcnQubWltZVR5cGU7XG4gIGxldCBkYXRhOiBEYXRhQ29udGVudCB8IFVSTDtcbiAgbGV0IGNvbnRlbnQ6IFVSTCB8IEFycmF5QnVmZmVyIHwgc3RyaW5nO1xuICBsZXQgbm9ybWFsaXplZERhdGE6IFVpbnQ4QXJyYXkgfCBVUkw7XG5cbiAgY29uc3QgdHlwZSA9IHBhcnQudHlwZTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgZGF0YSA9IHBhcnQuaW1hZ2U7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmaWxlJzpcbiAgICAgIGRhdGEgPSBwYXJ0LmRhdGE7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwYXJ0IHR5cGU6ICR7dHlwZX1gKTtcbiAgfVxuXG4gIC8vIEF0dGVtcHQgdG8gY3JlYXRlIGEgVVJMIGZyb20gdGhlIGRhdGEuIElmIGl0IGZhaWxzLCB3ZSBjYW4gYXNzdW1lIHRoZSBkYXRhXG4gIC8vIGlzIG5vdCBhIFVSTCBhbmQgbGlrZWx5IHNvbWUgb3RoZXIgc29ydCBvZiBkYXRhLlxuICB0cnkge1xuICAgIGNvbnRlbnQgPSB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgPyBuZXcgVVJMKGRhdGEpIDogZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb250ZW50ID0gZGF0YTtcbiAgfVxuXG4gIC8vIElmIHdlIHN1Y2Nlc3NmdWxseSBjcmVhdGVkIGEgVVJMLCB3ZSBjYW4gdXNlIHRoYXQgdG8gbm9ybWFsaXplIHRoZSBkYXRhXG4gIC8vIGVpdGhlciBieSBwYXNzaW5nIGl0IHRocm91Z2ggb3IgY29udmVydGluZyBub3JtYWxpemluZyB0aGUgYmFzZTY0IGNvbnRlbnRcbiAgLy8gdG8gYSBVaW50OEFycmF5LlxuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIFVSTCkge1xuICAgIC8vIElmIHRoZSBjb250ZW50IGlzIGEgZGF0YSBVUkwsIHdlIHdhbnQgdG8gY29udmVydCB0aGF0IHRvIGEgVWludDhBcnJheVxuICAgIGlmIChjb250ZW50LnByb3RvY29sID09PSAnZGF0YTonKSB7XG4gICAgICBjb25zdCB7IG1pbWVUeXBlOiBkYXRhVXJsTWltZVR5cGUsIGJhc2U2NENvbnRlbnQgfSA9IHNwbGl0RGF0YVVybChcbiAgICAgICAgY29udGVudC50b1N0cmluZygpLFxuICAgICAgKTtcblxuICAgICAgaWYgKGRhdGFVcmxNaW1lVHlwZSA9PSBudWxsIHx8IGJhc2U2NENvbnRlbnQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGF0YSBVUkwgZm9ybWF0IGluIHBhcnQgJHt0eXBlfWApO1xuICAgICAgfVxuXG4gICAgICBtaW1lVHlwZSA9IGRhdGFVcmxNaW1lVHlwZTtcbiAgICAgIG5vcm1hbGl6ZWREYXRhID0gY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KGJhc2U2NENvbnRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKipcbiAgICAgICAqIElmIHRoZSBjb250ZW50IGlzIGEgVVJMLCB3ZSBzaG91bGQgZmlyc3Qgc2VlIGlmIGl0IHdhcyBkb3dubG9hZGVkLiBBbmQgaWYgbm90LFxuICAgICAgICogd2UgY2FuIGxldCB0aGUgbW9kZWwgZGVjaWRlIGlmIGl0IHdhbnRzIHRvIHN1cHBvcnQgdGhlIFVSTC4gVGhpcyBhbHNvIGFsbG93c1xuICAgICAgICogZm9yIG5vbi1IVFRQIFVSTHMgdG8gYmUgcGFzc2VkIHRocm91Z2ggKGUuZy4gZ3M6Ly8pLlxuICAgICAgICovXG4gICAgICBjb25zdCBkb3dubG9hZGVkRmlsZSA9IGRvd25sb2FkZWRBc3NldHNbY29udGVudC50b1N0cmluZygpXTtcbiAgICAgIGlmIChkb3dubG9hZGVkRmlsZSkge1xuICAgICAgICBub3JtYWxpemVkRGF0YSA9IGRvd25sb2FkZWRGaWxlLmRhdGE7XG4gICAgICAgIG1pbWVUeXBlID8/PSBkb3dubG9hZGVkRmlsZS5taW1lVHlwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vcm1hbGl6ZWREYXRhID0gY29udGVudDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gU2luY2Ugd2Uga25vdyBrbm93IHRoZSBjb250ZW50IGlzIG5vdCBhIFVSTCwgd2UgY2FuIGF0dGVtcHQgdG8gbm9ybWFsaXplIHRoZSBkYXRhXG4gICAgLy8gYXNzdW1pbmcgaXQgaXMgc29tZSBzb3J0IG9mIGRhdGEuXG4gICAgbm9ybWFsaXplZERhdGEgPSBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoY29udGVudCk7XG4gIH1cblxuICAvLyBOb3cgdGhhdCB3ZSBoYXZlIHRoZSBub3JtYWxpemVkIGRhdGEgZWl0aGVyIGFzIGEgVVJMIG9yIGEgVWludDhBcnJheSxcbiAgLy8gd2UgY2FuIGNyZWF0ZSB0aGUgTGFuZ3VhZ2VNb2RlbFYxUGFydC5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgLy8gV2UgZ2l2ZSBhIGJlc3QgZWZmb3J0IHRvIGRldGVjdCB0aGUgbWltZSB0eXBlIGlmIGl0IGlzIG5vdCBwcm92aWRlZC5cbiAgICAgIC8vIG90aGVyd2lzZSwgd2UgdXNlIHRoZSBwcm92aWRlZCBtaW1lIHR5cGUuXG4gICAgICBpZiAobWltZVR5cGUgPT0gbnVsbCAmJiBub3JtYWxpemVkRGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgbWltZVR5cGUgPSBkZXRlY3RJbWFnZU1pbWVUeXBlKG5vcm1hbGl6ZWREYXRhKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgaW1hZ2U6IG5vcm1hbGl6ZWREYXRhLFxuICAgICAgICBtaW1lVHlwZSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgIH07XG4gICAgY2FzZSAnZmlsZSc6XG4gICAgICAvLyBXZSBzaG91bGQgaGF2ZSBhIG1pbWVUeXBlIGF0IHRoaXMgcG9pbnQsIGlmIG5vdCwgdGhyb3cgYW4gZXJyb3IuXG4gICAgICBpZiAobWltZVR5cGUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pbWUgdHlwZSBpcyBtaXNzaW5nIGZvciBmaWxlIHBhcnRgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2ZpbGUnLFxuICAgICAgICBkYXRhOlxuICAgICAgICAgIG5vcm1hbGl6ZWREYXRhIGluc3RhbmNlb2YgVWludDhBcnJheVxuICAgICAgICAgICAgPyBjb252ZXJ0RGF0YUNvbnRlbnRUb0Jhc2U2NFN0cmluZyhub3JtYWxpemVkRGF0YSlcbiAgICAgICAgICAgIDogbm9ybWFsaXplZERhdGEsXG4gICAgICAgIG1pbWVUeXBlLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhLFxuICAgICAgfTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgQUlTREtFcnJvciB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuXG5jb25zdCBuYW1lID0gJ0FJX0ludmFsaWRBcmd1bWVudEVycm9yJztcbmNvbnN0IG1hcmtlciA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lfWA7XG5jb25zdCBzeW1ib2wgPSBTeW1ib2wuZm9yKG1hcmtlcik7XG5cbmV4cG9ydCBjbGFzcyBJbnZhbGlkQXJndW1lbnRFcnJvciBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBwcml2YXRlIHJlYWRvbmx5IFtzeW1ib2xdID0gdHJ1ZTsgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG5cbiAgcmVhZG9ubHkgcGFyYW1ldGVyOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHZhbHVlOiB1bmtub3duO1xuXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwYXJhbWV0ZXIsXG4gICAgdmFsdWUsXG4gICAgbWVzc2FnZSxcbiAgfToge1xuICAgIHBhcmFtZXRlcjogc3RyaW5nO1xuICAgIHZhbHVlOiB1bmtub3duO1xuICAgIG1lc3NhZ2U6IHN0cmluZztcbiAgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWUsXG4gICAgICBtZXNzYWdlOiBgSW52YWxpZCBhcmd1bWVudCBmb3IgcGFyYW1ldGVyICR7cGFyYW1ldGVyfTogJHttZXNzYWdlfWAsXG4gICAgfSk7XG5cbiAgICB0aGlzLnBhcmFtZXRlciA9IHBhcmFtZXRlcjtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcjogdW5rbm93bik6IGVycm9yIGlzIEludmFsaWRBcmd1bWVudEVycm9yIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcik7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNJbnZhbGlkQXJndW1lbnRFcnJvcihlcnJvcjogdW5rbm93bik6IGVycm9yIGlzIEludmFsaWRBcmd1bWVudEVycm9yIHtcbiAgICByZXR1cm4gKFxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgZXJyb3IubmFtZSA9PT0gbmFtZSAmJlxuICAgICAgdHlwZW9mIChlcnJvciBhcyBJbnZhbGlkQXJndW1lbnRFcnJvcikucGFyYW1ldGVyID09PSAnc3RyaW5nJyAmJlxuICAgICAgdHlwZW9mIChlcnJvciBhcyBJbnZhbGlkQXJndW1lbnRFcnJvcikudmFsdWUgPT09ICdzdHJpbmcnXG4gICAgKTtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG5cbiAgICAgIHBhcmFtZXRlcjogdGhpcy5wYXJhbWV0ZXIsXG4gICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICB9O1xuICB9XG59XG4iLCJpbXBvcnQgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9IGZyb20gJy4uLy4uL2Vycm9ycy9pbnZhbGlkLWFyZ3VtZW50LWVycm9yJztcbmltcG9ydCB7IENhbGxTZXR0aW5ncyB9IGZyb20gJy4vY2FsbC1zZXR0aW5ncyc7XG5cbi8qKlxuICogVmFsaWRhdGVzIGNhbGwgc2V0dGluZ3MgYW5kIHNldHMgZGVmYXVsdCB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmVwYXJlQ2FsbFNldHRpbmdzKHtcbiAgbWF4VG9rZW5zLFxuICB0ZW1wZXJhdHVyZSxcbiAgdG9wUCxcbiAgdG9wSyxcbiAgcHJlc2VuY2VQZW5hbHR5LFxuICBmcmVxdWVuY3lQZW5hbHR5LFxuICBzdG9wU2VxdWVuY2VzLFxuICBzZWVkLFxuICBtYXhSZXRyaWVzLFxufTogT21pdDxDYWxsU2V0dGluZ3MsICdhYm9ydFNpZ25hbCcgfCAnaGVhZGVycyc+KTogT21pdDxcbiAgQ2FsbFNldHRpbmdzLFxuICAnYWJvcnRTaWduYWwnIHwgJ2hlYWRlcnMnXG4+IHtcbiAgaWYgKG1heFRva2VucyAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFRva2VucykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogJ21heFRva2VucycsXG4gICAgICAgIHZhbHVlOiBtYXhUb2tlbnMsXG4gICAgICAgIG1lc3NhZ2U6ICdtYXhUb2tlbnMgbXVzdCBiZSBhbiBpbnRlZ2VyJyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChtYXhUb2tlbnMgPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6ICdtYXhUb2tlbnMnLFxuICAgICAgICB2YWx1ZTogbWF4VG9rZW5zLFxuICAgICAgICBtZXNzYWdlOiAnbWF4VG9rZW5zIG11c3QgYmUgPj0gMScsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAodGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdGVtcGVyYXR1cmUgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6ICd0ZW1wZXJhdHVyZScsXG4gICAgICAgIHZhbHVlOiB0ZW1wZXJhdHVyZSxcbiAgICAgICAgbWVzc2FnZTogJ3RlbXBlcmF0dXJlIG11c3QgYmUgYSBudW1iZXInLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRvcFAgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdG9wUCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogJ3RvcFAnLFxuICAgICAgICB2YWx1ZTogdG9wUCxcbiAgICAgICAgbWVzc2FnZTogJ3RvcFAgbXVzdCBiZSBhIG51bWJlcicsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAodG9wSyAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB0b3BLICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiAndG9wSycsXG4gICAgICAgIHZhbHVlOiB0b3BLLFxuICAgICAgICBtZXNzYWdlOiAndG9wSyBtdXN0IGJlIGEgbnVtYmVyJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcmVzZW5jZVBlbmFsdHkgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgcHJlc2VuY2VQZW5hbHR5ICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiAncHJlc2VuY2VQZW5hbHR5JyxcbiAgICAgICAgdmFsdWU6IHByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgbWVzc2FnZTogJ3ByZXNlbmNlUGVuYWx0eSBtdXN0IGJlIGEgbnVtYmVyJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmcmVxdWVuY3lQZW5hbHR5ICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIGZyZXF1ZW5jeVBlbmFsdHkgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6ICdmcmVxdWVuY3lQZW5hbHR5JyxcbiAgICAgICAgdmFsdWU6IGZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgIG1lc3NhZ2U6ICdmcmVxdWVuY3lQZW5hbHR5IG11c3QgYmUgYSBudW1iZXInLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNlZWQgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihzZWVkKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiAnc2VlZCcsXG4gICAgICAgIHZhbHVlOiBzZWVkLFxuICAgICAgICBtZXNzYWdlOiAnc2VlZCBtdXN0IGJlIGFuIGludGVnZXInLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG1heFJldHJpZXMgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhSZXRyaWVzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiAnbWF4UmV0cmllcycsXG4gICAgICAgIHZhbHVlOiBtYXhSZXRyaWVzLFxuICAgICAgICBtZXNzYWdlOiAnbWF4UmV0cmllcyBtdXN0IGJlIGFuIGludGVnZXInLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG1heFJldHJpZXMgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6ICdtYXhSZXRyaWVzJyxcbiAgICAgICAgdmFsdWU6IG1heFJldHJpZXMsXG4gICAgICAgIG1lc3NhZ2U6ICdtYXhSZXRyaWVzIG11c3QgYmUgPj0gMCcsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1heFRva2VucyxcbiAgICB0ZW1wZXJhdHVyZTogdGVtcGVyYXR1cmUgPz8gMCxcbiAgICB0b3BQLFxuICAgIHRvcEssXG4gICAgcHJlc2VuY2VQZW5hbHR5LFxuICAgIGZyZXF1ZW5jeVBlbmFsdHksXG4gICAgc3RvcFNlcXVlbmNlczpcbiAgICAgIHN0b3BTZXF1ZW5jZXMgIT0gbnVsbCAmJiBzdG9wU2VxdWVuY2VzLmxlbmd0aCA+IDBcbiAgICAgICAgPyBzdG9wU2VxdWVuY2VzXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgIHNlZWQsXG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllcyA/PyAyLFxuICB9O1xufVxuIiwiaW1wb3J0IHtcbiAgTGFuZ3VhZ2VNb2RlbFYxRnVuY3Rpb25Ub29sLFxuICBMYW5ndWFnZU1vZGVsVjFQcm92aWRlckRlZmluZWRUb29sLFxuICBMYW5ndWFnZU1vZGVsVjFUb29sQ2hvaWNlLFxufSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyJztcbmltcG9ydCB7IGFzU2NoZW1hIH0gZnJvbSAnQGFpLXNkay91aS11dGlscyc7XG5pbXBvcnQgeyBDb3JlVG9vbCB9IGZyb20gJy4uL3Rvb2wvdG9vbCc7XG5pbXBvcnQgeyBDb3JlVG9vbENob2ljZSB9IGZyb20gJy4uL3R5cGVzL2xhbmd1YWdlLW1vZGVsJztcbmltcG9ydCB7IGlzTm9uRW1wdHlPYmplY3QgfSBmcm9tICcuLi91dGlsL2lzLW5vbi1lbXB0eS1vYmplY3QnO1xuXG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZTxcbiAgVE9PTFMgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBDb3JlVG9vbD4sXG4+KHtcbiAgdG9vbHMsXG4gIHRvb2xDaG9pY2UsXG4gIGFjdGl2ZVRvb2xzLFxufToge1xuICB0b29sczogVE9PTFMgfCB1bmRlZmluZWQ7XG4gIHRvb2xDaG9pY2U6IENvcmVUb29sQ2hvaWNlPFRPT0xTPiB8IHVuZGVmaW5lZDtcbiAgYWN0aXZlVG9vbHM6IEFycmF5PGtleW9mIFRPT0xTPiB8IHVuZGVmaW5lZDtcbn0pOiB7XG4gIHRvb2xzOlxuICAgIHwgQXJyYXk8TGFuZ3VhZ2VNb2RlbFYxRnVuY3Rpb25Ub29sIHwgTGFuZ3VhZ2VNb2RlbFYxUHJvdmlkZXJEZWZpbmVkVG9vbD5cbiAgICB8IHVuZGVmaW5lZDtcbiAgdG9vbENob2ljZTogTGFuZ3VhZ2VNb2RlbFYxVG9vbENob2ljZSB8IHVuZGVmaW5lZDtcbn0ge1xuICBpZiAoIWlzTm9uRW1wdHlPYmplY3QodG9vbHMpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvb2xzOiB1bmRlZmluZWQsXG4gICAgICB0b29sQ2hvaWNlOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfVxuXG4gIC8vIHdoZW4gYWN0aXZlVG9vbHMgaXMgcHJvdmlkZWQsIHdlIG9ubHkgaW5jbHVkZSB0aGUgdG9vbHMgdGhhdCBhcmUgaW4gdGhlIGxpc3Q6XG4gIGNvbnN0IGZpbHRlcmVkVG9vbHMgPVxuICAgIGFjdGl2ZVRvb2xzICE9IG51bGxcbiAgICAgID8gT2JqZWN0LmVudHJpZXModG9vbHMpLmZpbHRlcigoW25hbWVdKSA9PlxuICAgICAgICAgIGFjdGl2ZVRvb2xzLmluY2x1ZGVzKG5hbWUgYXMga2V5b2YgVE9PTFMpLFxuICAgICAgICApXG4gICAgICA6IE9iamVjdC5lbnRyaWVzKHRvb2xzKTtcblxuICByZXR1cm4ge1xuICAgIHRvb2xzOiBmaWx0ZXJlZFRvb2xzLm1hcCgoW25hbWUsIHRvb2xdKSA9PiB7XG4gICAgICBjb25zdCB0b29sVHlwZSA9IHRvb2wudHlwZTtcbiAgICAgIHN3aXRjaCAodG9vbFR5cGUpIHtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyBhcyBjb25zdCxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogdG9vbC5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IGFzU2NoZW1hKHRvb2wucGFyYW1ldGVycykuanNvblNjaGVtYSxcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdwcm92aWRlci1kZWZpbmVkJzpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ3Byb3ZpZGVyLWRlZmluZWQnIGFzIGNvbnN0LFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGlkOiB0b29sLmlkLFxuICAgICAgICAgICAgYXJnczogdG9vbC5hcmdzLFxuICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2s6IG5ldmVyID0gdG9vbFR5cGU7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB0b29sIHR5cGU6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSksXG4gICAgdG9vbENob2ljZTpcbiAgICAgIHRvb2xDaG9pY2UgPT0gbnVsbFxuICAgICAgICA/IHsgdHlwZTogJ2F1dG8nIH1cbiAgICAgICAgOiB0eXBlb2YgdG9vbENob2ljZSA9PT0gJ3N0cmluZydcbiAgICAgICAgPyB7IHR5cGU6IHRvb2xDaG9pY2UgfVxuICAgICAgICA6IHsgdHlwZTogJ3Rvb2wnIGFzIGNvbnN0LCB0b29sTmFtZTogdG9vbENob2ljZS50b29sTmFtZSBhcyBzdHJpbmcgfSxcbiAgfTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBpc05vbkVtcHR5T2JqZWN0KFxuICBvYmplY3Q6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHwgdW5kZWZpbmVkIHwgbnVsbCxcbik6IG9iamVjdCBpcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBPYmplY3Qua2V5cyhvYmplY3QpLmxlbmd0aCA+IDA7XG59XG4iLCJpbXBvcnQgeyBJbnZhbGlkUHJvbXB0RXJyb3IgfSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyJztcbmltcG9ydCB7IHNhZmVWYWxpZGF0ZVR5cGVzIH0gZnJvbSAnQGFpLXNkay9wcm92aWRlci11dGlscyc7XG5pbXBvcnQgeyB6IH0gZnJvbSAnem9kJztcbmltcG9ydCB7IENvcmVNZXNzYWdlLCBjb3JlTWVzc2FnZVNjaGVtYSB9IGZyb20gJy4vbWVzc2FnZSc7XG5pbXBvcnQgeyBQcm9tcHQgfSBmcm9tICcuL3Byb21wdCc7XG5pbXBvcnQgeyBkZXRlY3RQcm9tcHRUeXBlIH0gZnJvbSAnLi9kZXRlY3QtcHJvbXB0LXR5cGUnO1xuaW1wb3J0IHsgY29udmVydFRvQ29yZU1lc3NhZ2VzIH0gZnJvbSAnLi9jb252ZXJ0LXRvLWNvcmUtbWVzc2FnZXMnO1xuaW1wb3J0IHsgVUlNZXNzYWdlIH0gZnJvbSAnLi91aS1tZXNzYWdlJztcbmltcG9ydCB7IENvcmVUb29sIH0gZnJvbSAnLi4vdG9vbC90b29sJztcblxuZXhwb3J0IHR5cGUgU3RhbmRhcmRpemVkUHJvbXB0ID0ge1xuICAvKipcbiAgICogT3JpZ2luYWwgcHJvbXB0IHR5cGUuIFRoaXMgaXMgZm9yd2FyZGVkIHRvIHRoZSBwcm92aWRlcnMgYW5kIGNhbiBiZSB1c2VkXG4gICAqIHRvIHdyaXRlIHNlbmQgcmF3IHRleHQgdG8gcHJvdmlkZXJzIHRoYXQgc3VwcG9ydCBpdC5cbiAgICovXG4gIHR5cGU6ICdwcm9tcHQnIHwgJ21lc3NhZ2VzJztcblxuICAvKipcbiAgICogU3lzdGVtIG1lc3NhZ2UuXG4gICAqL1xuICBzeXN0ZW0/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE1lc3NhZ2VzLlxuICAgKi9cbiAgbWVzc2FnZXM6IENvcmVNZXNzYWdlW107XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gc3RhbmRhcmRpemVQcm9tcHQ8VE9PTFMgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBDb3JlVG9vbD4+KHtcbiAgcHJvbXB0LFxuICB0b29scyxcbn06IHtcbiAgcHJvbXB0OiBQcm9tcHQ7XG4gIHRvb2xzOiB1bmRlZmluZWQgfCBUT09MUztcbn0pOiBTdGFuZGFyZGl6ZWRQcm9tcHQge1xuICBpZiAocHJvbXB0LnByb21wdCA9PSBudWxsICYmIHByb21wdC5tZXNzYWdlcyA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiAncHJvbXB0IG9yIG1lc3NhZ2VzIG11c3QgYmUgZGVmaW5lZCcsXG4gICAgfSk7XG4gIH1cblxuICBpZiAocHJvbXB0LnByb21wdCAhPSBudWxsICYmIHByb21wdC5tZXNzYWdlcyAhPSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiAncHJvbXB0IGFuZCBtZXNzYWdlcyBjYW5ub3QgYmUgZGVmaW5lZCBhdCB0aGUgc2FtZSB0aW1lJyxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHZhbGlkYXRlIHRoYXQgc3lzdGVtIGlzIGEgc3RyaW5nXG4gIGlmIChwcm9tcHQuc3lzdGVtICE9IG51bGwgJiYgdHlwZW9mIHByb21wdC5zeXN0ZW0gIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiAnc3lzdGVtIG11c3QgYmUgYSBzdHJpbmcnLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gdHlwZTogcHJvbXB0XG4gIGlmIChwcm9tcHQucHJvbXB0ICE9IG51bGwpIHtcbiAgICAvLyB2YWxpZGF0ZSB0aGF0IHByb21wdCBpcyBhIHN0cmluZ1xuICAgIGlmICh0eXBlb2YgcHJvbXB0LnByb21wdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgICBwcm9tcHQsXG4gICAgICAgIG1lc3NhZ2U6ICdwcm9tcHQgbXVzdCBiZSBhIHN0cmluZycsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3Byb21wdCcsXG4gICAgICBzeXN0ZW06IHByb21wdC5zeXN0ZW0sXG4gICAgICBtZXNzYWdlczogW1xuICAgICAgICB7XG4gICAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICAgIGNvbnRlbnQ6IHByb21wdC5wcm9tcHQsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH07XG4gIH1cblxuICAvLyB0eXBlOiBtZXNzYWdlc1xuICBpZiAocHJvbXB0Lm1lc3NhZ2VzICE9IG51bGwpIHtcbiAgICBjb25zdCBwcm9tcHRUeXBlID0gZGV0ZWN0UHJvbXB0VHlwZShwcm9tcHQubWVzc2FnZXMpO1xuXG4gICAgaWYgKHByb21wdFR5cGUgPT09ICdvdGhlcicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgICBwcm9tcHQsXG4gICAgICAgIG1lc3NhZ2U6ICdtZXNzYWdlcyBtdXN0IGJlIGFuIGFycmF5IG9mIENvcmVNZXNzYWdlIG9yIFVJTWVzc2FnZScsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBtZXNzYWdlczogQ29yZU1lc3NhZ2VbXSA9XG4gICAgICBwcm9tcHRUeXBlID09PSAndWktbWVzc2FnZXMnXG4gICAgICAgID8gY29udmVydFRvQ29yZU1lc3NhZ2VzKHByb21wdC5tZXNzYWdlcyBhcyBVSU1lc3NhZ2VbXSwge1xuICAgICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgfSlcbiAgICAgICAgOiAocHJvbXB0Lm1lc3NhZ2VzIGFzIENvcmVNZXNzYWdlW10pO1xuXG4gICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IHNhZmVWYWxpZGF0ZVR5cGVzKHtcbiAgICAgIHZhbHVlOiBtZXNzYWdlcyxcbiAgICAgIHNjaGVtYTogei5hcnJheShjb3JlTWVzc2FnZVNjaGVtYSksXG4gICAgfSk7XG5cbiAgICBpZiAoIXZhbGlkYXRpb25SZXN1bHQuc3VjY2Vzcykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcih7XG4gICAgICAgIHByb21wdCxcbiAgICAgICAgbWVzc2FnZTogJ21lc3NhZ2VzIG11c3QgYmUgYW4gYXJyYXkgb2YgQ29yZU1lc3NhZ2Ugb3IgVUlNZXNzYWdlJyxcbiAgICAgICAgY2F1c2U6IHZhbGlkYXRpb25SZXN1bHQuZXJyb3IsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ21lc3NhZ2VzJyxcbiAgICAgIG1lc3NhZ2VzLFxuICAgICAgc3lzdGVtOiBwcm9tcHQuc3lzdGVtLFxuICAgIH07XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlJyk7XG59XG4iLCJpbXBvcnQgeyB6IH0gZnJvbSAnem9kJztcbmltcG9ydCB7IFByb3ZpZGVyTWV0YWRhdGEgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBwcm92aWRlck1ldGFkYXRhU2NoZW1hIH0gZnJvbSAnLi4vdHlwZXMvcHJvdmlkZXItbWV0YWRhdGEnO1xuaW1wb3J0IHtcbiAgRmlsZVBhcnQsXG4gIGZpbGVQYXJ0U2NoZW1hLFxuICBJbWFnZVBhcnQsXG4gIGltYWdlUGFydFNjaGVtYSxcbiAgVGV4dFBhcnQsXG4gIHRleHRQYXJ0U2NoZW1hLFxuICBUb29sQ2FsbFBhcnQsXG4gIHRvb2xDYWxsUGFydFNjaGVtYSxcbiAgVG9vbFJlc3VsdFBhcnQsXG4gIHRvb2xSZXN1bHRQYXJ0U2NoZW1hLFxufSBmcm9tICcuL2NvbnRlbnQtcGFydCc7XG5cbi8qKlxuIEEgc3lzdGVtIG1lc3NhZ2UuIEl0IGNhbiBjb250YWluIHN5c3RlbSBpbmZvcm1hdGlvbi5cblxuIE5vdGU6IHVzaW5nIHRoZSBcInN5c3RlbVwiIHBhcnQgb2YgdGhlIHByb21wdCBpcyBzdHJvbmdseSBwcmVmZXJyZWRcbiB0byBpbmNyZWFzZSB0aGUgcmVzaWxpZW5jZSBhZ2FpbnN0IHByb21wdCBpbmplY3Rpb24gYXR0YWNrcyxcbiBhbmQgYmVjYXVzZSBub3QgYWxsIHByb3ZpZGVycyBzdXBwb3J0IHNldmVyYWwgc3lzdGVtIG1lc3NhZ2VzLlxuICovXG5leHBvcnQgdHlwZSBDb3JlU3lzdGVtTWVzc2FnZSA9IHtcbiAgcm9sZTogJ3N5c3RlbSc7XG4gIGNvbnRlbnQ6IHN0cmluZztcblxuICAvKipcbkFkZGl0aW9uYWwgcHJvdmlkZXItc3BlY2lmaWMgbWV0YWRhdGEuIFRoZXkgYXJlIHBhc3NlZCB0aHJvdWdoXG50byB0aGUgcHJvdmlkZXIgZnJvbSB0aGUgQUkgU0RLIGFuZCBlbmFibGUgcHJvdmlkZXItc3BlY2lmaWNcbmZ1bmN0aW9uYWxpdHkgdGhhdCBjYW4gYmUgZnVsbHkgZW5jYXBzdWxhdGVkIGluIHRoZSBwcm92aWRlci5cbiAqL1xuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YT86IFByb3ZpZGVyTWV0YWRhdGE7XG59O1xuXG5leHBvcnQgY29uc3QgY29yZVN5c3RlbU1lc3NhZ2VTY2hlbWE6IHouWm9kVHlwZTxDb3JlU3lzdGVtTWVzc2FnZT4gPSB6Lm9iamVjdCh7XG4gIHJvbGU6IHoubGl0ZXJhbCgnc3lzdGVtJyksXG4gIGNvbnRlbnQ6IHouc3RyaW5nKCksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG59KTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYENvcmVNZXNzYWdlYCBpbnN0ZWFkLlxuICovXG5leHBvcnQgdHlwZSBFeHBlcmltZW50YWxNZXNzYWdlID0gQ29yZU1lc3NhZ2U7XG5cbi8qKlxuQSB1c2VyIG1lc3NhZ2UuIEl0IGNhbiBjb250YWluIHRleHQgb3IgYSBjb21iaW5hdGlvbiBvZiB0ZXh0IGFuZCBpbWFnZXMuXG4gKi9cbmV4cG9ydCB0eXBlIENvcmVVc2VyTWVzc2FnZSA9IHtcbiAgcm9sZTogJ3VzZXInO1xuICBjb250ZW50OiBVc2VyQ29udGVudDtcblxuICAvKipcbkFkZGl0aW9uYWwgcHJvdmlkZXItc3BlY2lmaWMgbWV0YWRhdGEuIFRoZXkgYXJlIHBhc3NlZCB0aHJvdWdoXG50byB0aGUgcHJvdmlkZXIgZnJvbSB0aGUgQUkgU0RLIGFuZCBlbmFibGUgcHJvdmlkZXItc3BlY2lmaWNcbmZ1bmN0aW9uYWxpdHkgdGhhdCBjYW4gYmUgZnVsbHkgZW5jYXBzdWxhdGVkIGluIHRoZSBwcm92aWRlci5cbiAqL1xuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YT86IFByb3ZpZGVyTWV0YWRhdGE7XG59O1xuXG5leHBvcnQgY29uc3QgY29yZVVzZXJNZXNzYWdlU2NoZW1hOiB6LlpvZFR5cGU8Q29yZVVzZXJNZXNzYWdlPiA9IHoub2JqZWN0KHtcbiAgcm9sZTogei5saXRlcmFsKCd1c2VyJyksXG4gIGNvbnRlbnQ6IHoudW5pb24oW1xuICAgIHouc3RyaW5nKCksXG4gICAgei5hcnJheSh6LnVuaW9uKFt0ZXh0UGFydFNjaGVtYSwgaW1hZ2VQYXJ0U2NoZW1hLCBmaWxlUGFydFNjaGVtYV0pKSxcbiAgXSksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG59KTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYENvcmVVc2VyTWVzc2FnZWAgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IHR5cGUgRXhwZXJpbWVudGFsVXNlck1lc3NhZ2UgPSBDb3JlVXNlck1lc3NhZ2U7XG5cbi8qKlxuQ29udGVudCBvZiBhIHVzZXIgbWVzc2FnZS4gSXQgY2FuIGJlIGEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHRleHQgYW5kIGltYWdlIHBhcnRzLlxuICovXG5leHBvcnQgdHlwZSBVc2VyQ29udGVudCA9IHN0cmluZyB8IEFycmF5PFRleHRQYXJ0IHwgSW1hZ2VQYXJ0IHwgRmlsZVBhcnQ+O1xuXG4vKipcbkFuIGFzc2lzdGFudCBtZXNzYWdlLiBJdCBjYW4gY29udGFpbiB0ZXh0LCB0b29sIGNhbGxzLCBvciBhIGNvbWJpbmF0aW9uIG9mIHRleHQgYW5kIHRvb2wgY2FsbHMuXG4gKi9cbmV4cG9ydCB0eXBlIENvcmVBc3Npc3RhbnRNZXNzYWdlID0ge1xuICByb2xlOiAnYXNzaXN0YW50JztcbiAgY29udGVudDogQXNzaXN0YW50Q29udGVudDtcblxuICAvKipcbkFkZGl0aW9uYWwgcHJvdmlkZXItc3BlY2lmaWMgbWV0YWRhdGEuIFRoZXkgYXJlIHBhc3NlZCB0aHJvdWdoXG50byB0aGUgcHJvdmlkZXIgZnJvbSB0aGUgQUkgU0RLIGFuZCBlbmFibGUgcHJvdmlkZXItc3BlY2lmaWNcbmZ1bmN0aW9uYWxpdHkgdGhhdCBjYW4gYmUgZnVsbHkgZW5jYXBzdWxhdGVkIGluIHRoZSBwcm92aWRlci5cbiAqL1xuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YT86IFByb3ZpZGVyTWV0YWRhdGE7XG59O1xuXG5leHBvcnQgY29uc3QgY29yZUFzc2lzdGFudE1lc3NhZ2VTY2hlbWE6IHouWm9kVHlwZTxDb3JlQXNzaXN0YW50TWVzc2FnZT4gPVxuICB6Lm9iamVjdCh7XG4gICAgcm9sZTogei5saXRlcmFsKCdhc3Npc3RhbnQnKSxcbiAgICBjb250ZW50OiB6LnVuaW9uKFtcbiAgICAgIHouc3RyaW5nKCksXG4gICAgICB6LmFycmF5KHoudW5pb24oW3RleHRQYXJ0U2NoZW1hLCB0b29sQ2FsbFBhcnRTY2hlbWFdKSksXG4gICAgXSksXG4gICAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgfSk7XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGBDb3JlQXNzaXN0YW50TWVzc2FnZWAgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IHR5cGUgRXhwZXJpbWVudGFsQXNzaXN0YW50TWVzc2FnZSA9IENvcmVBc3Npc3RhbnRNZXNzYWdlO1xuXG4vKipcbkNvbnRlbnQgb2YgYW4gYXNzaXN0YW50IG1lc3NhZ2UuIEl0IGNhbiBiZSBhIHN0cmluZyBvciBhbiBhcnJheSBvZiB0ZXh0IGFuZCB0b29sIGNhbGwgcGFydHMuXG4gKi9cbmV4cG9ydCB0eXBlIEFzc2lzdGFudENvbnRlbnQgPSBzdHJpbmcgfCBBcnJheTxUZXh0UGFydCB8IFRvb2xDYWxsUGFydD47XG5cbi8qKlxuQSB0b29sIG1lc3NhZ2UuIEl0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2Ygb25lIG9yIG1vcmUgdG9vbCBjYWxscy5cbiAqL1xuZXhwb3J0IHR5cGUgQ29yZVRvb2xNZXNzYWdlID0ge1xuICByb2xlOiAndG9vbCc7XG4gIGNvbnRlbnQ6IFRvb2xDb250ZW50O1xuXG4gIC8qKlxuQWRkaXRpb25hbCBwcm92aWRlci1zcGVjaWZpYyBtZXRhZGF0YS4gVGhleSBhcmUgcGFzc2VkIHRocm91Z2hcbnRvIHRoZSBwcm92aWRlciBmcm9tIHRoZSBBSSBTREsgYW5kIGVuYWJsZSBwcm92aWRlci1zcGVjaWZpY1xuZnVuY3Rpb25hbGl0eSB0aGF0IGNhbiBiZSBmdWxseSBlbmNhcHN1bGF0ZWQgaW4gdGhlIHByb3ZpZGVyLlxuICovXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhPzogUHJvdmlkZXJNZXRhZGF0YTtcbn07XG5cbmV4cG9ydCBjb25zdCBjb3JlVG9vbE1lc3NhZ2VTY2hlbWE6IHouWm9kVHlwZTxDb3JlVG9vbE1lc3NhZ2U+ID0gei5vYmplY3Qoe1xuICByb2xlOiB6LmxpdGVyYWwoJ3Rvb2wnKSxcbiAgY29udGVudDogei5hcnJheSh0b29sUmVzdWx0UGFydFNjaGVtYSksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG59KTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYENvcmVUb29sTWVzc2FnZWAgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IHR5cGUgRXhwZXJpbWVudGFsVG9vbE1lc3NhZ2UgPSBDb3JlVG9vbE1lc3NhZ2U7XG5cbi8qKlxuQ29udGVudCBvZiBhIHRvb2wgbWVzc2FnZS4gSXQgaXMgYW4gYXJyYXkgb2YgdG9vbCByZXN1bHQgcGFydHMuXG4gKi9cbmV4cG9ydCB0eXBlIFRvb2xDb250ZW50ID0gQXJyYXk8VG9vbFJlc3VsdFBhcnQ+O1xuXG4vKipcbkEgbWVzc2FnZSB0aGF0IGNhbiBiZSB1c2VkIGluIHRoZSBgbWVzc2FnZXNgIGZpZWxkIG9mIGEgcHJvbXB0LlxuSXQgY2FuIGJlIGEgdXNlciBtZXNzYWdlLCBhbiBhc3Npc3RhbnQgbWVzc2FnZSwgb3IgYSB0b29sIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCB0eXBlIENvcmVNZXNzYWdlID1cbiAgfCBDb3JlU3lzdGVtTWVzc2FnZVxuICB8IENvcmVVc2VyTWVzc2FnZVxuICB8IENvcmVBc3Npc3RhbnRNZXNzYWdlXG4gIHwgQ29yZVRvb2xNZXNzYWdlO1xuXG5leHBvcnQgY29uc3QgY29yZU1lc3NhZ2VTY2hlbWE6IHouWm9kVHlwZTxDb3JlTWVzc2FnZT4gPSB6LnVuaW9uKFtcbiAgY29yZVN5c3RlbU1lc3NhZ2VTY2hlbWEsXG4gIGNvcmVVc2VyTWVzc2FnZVNjaGVtYSxcbiAgY29yZUFzc2lzdGFudE1lc3NhZ2VTY2hlbWEsXG4gIGNvcmVUb29sTWVzc2FnZVNjaGVtYSxcbl0pO1xuIiwiaW1wb3J0IHsgTGFuZ3VhZ2VNb2RlbFYxUHJvdmlkZXJNZXRhZGF0YSB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuaW1wb3J0IHsgeiB9IGZyb20gJ3pvZCc7XG5pbXBvcnQgeyBqc29uVmFsdWVTY2hlbWEgfSBmcm9tICcuL2pzb24tdmFsdWUnO1xuXG4vKipcbkFkZGl0aW9uYWwgcHJvdmlkZXItc3BlY2lmaWMgbWV0YWRhdGEuIFRoZXkgYXJlIHBhc3NlZCB0aHJvdWdoXG50byB0aGUgcHJvdmlkZXIgZnJvbSB0aGUgQUkgU0RLIGFuZCBlbmFibGUgcHJvdmlkZXItc3BlY2lmaWNcbmZ1bmN0aW9uYWxpdHkgdGhhdCBjYW4gYmUgZnVsbHkgZW5jYXBzdWxhdGVkIGluIHRoZSBwcm92aWRlci5cbiAqL1xuZXhwb3J0IHR5cGUgUHJvdmlkZXJNZXRhZGF0YSA9IExhbmd1YWdlTW9kZWxWMVByb3ZpZGVyTWV0YWRhdGE7XG5cbmV4cG9ydCBjb25zdCBwcm92aWRlck1ldGFkYXRhU2NoZW1hOiB6LlpvZFR5cGU8UHJvdmlkZXJNZXRhZGF0YT4gPSB6LnJlY29yZChcbiAgei5zdHJpbmcoKSxcbiAgei5yZWNvcmQoei5zdHJpbmcoKSwganNvblZhbHVlU2NoZW1hKSxcbik7XG4iLCJpbXBvcnQgeyBKU09OVmFsdWUgfSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyJztcbmltcG9ydCB7IHogfSBmcm9tICd6b2QnO1xuXG5leHBvcnQgY29uc3QganNvblZhbHVlU2NoZW1hOiB6LlpvZFR5cGU8SlNPTlZhbHVlPiA9IHoubGF6eSgoKSA9PlxuICB6LnVuaW9uKFtcbiAgICB6Lm51bGwoKSxcbiAgICB6LnN0cmluZygpLFxuICAgIHoubnVtYmVyKCksXG4gICAgei5ib29sZWFuKCksXG4gICAgei5yZWNvcmQoei5zdHJpbmcoKSwganNvblZhbHVlU2NoZW1hKSxcbiAgICB6LmFycmF5KGpzb25WYWx1ZVNjaGVtYSksXG4gIF0pLFxuKTtcbiIsImltcG9ydCB7IHogfSBmcm9tICd6b2QnO1xuaW1wb3J0IHtcbiAgUHJvdmlkZXJNZXRhZGF0YSxcbiAgcHJvdmlkZXJNZXRhZGF0YVNjaGVtYSxcbn0gZnJvbSAnLi4vdHlwZXMvcHJvdmlkZXItbWV0YWRhdGEnO1xuaW1wb3J0IHsgRGF0YUNvbnRlbnQsIGRhdGFDb250ZW50U2NoZW1hIH0gZnJvbSAnLi9kYXRhLWNvbnRlbnQnO1xuaW1wb3J0IHtcbiAgVG9vbFJlc3VsdENvbnRlbnQsXG4gIHRvb2xSZXN1bHRDb250ZW50U2NoZW1hLFxufSBmcm9tICcuL3Rvb2wtcmVzdWx0LWNvbnRlbnQnO1xuXG4vKipcblRleHQgY29udGVudCBwYXJ0IG9mIGEgcHJvbXB0LiBJdCBjb250YWlucyBhIHN0cmluZyBvZiB0ZXh0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRleHRQYXJ0IHtcbiAgdHlwZTogJ3RleHQnO1xuXG4gIC8qKlxuVGhlIHRleHQgY29udGVudC5cbiAgICovXG4gIHRleHQ6IHN0cmluZztcblxuICAvKipcbkFkZGl0aW9uYWwgcHJvdmlkZXItc3BlY2lmaWMgbWV0YWRhdGEuIFRoZXkgYXJlIHBhc3NlZCB0aHJvdWdoXG50byB0aGUgcHJvdmlkZXIgZnJvbSB0aGUgQUkgU0RLIGFuZCBlbmFibGUgcHJvdmlkZXItc3BlY2lmaWNcbmZ1bmN0aW9uYWxpdHkgdGhhdCBjYW4gYmUgZnVsbHkgZW5jYXBzdWxhdGVkIGluIHRoZSBwcm92aWRlci5cbiAqL1xuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YT86IFByb3ZpZGVyTWV0YWRhdGE7XG59XG5cbmV4cG9ydCBjb25zdCB0ZXh0UGFydFNjaGVtYTogei5ab2RUeXBlPFRleHRQYXJ0PiA9IHoub2JqZWN0KHtcbiAgdHlwZTogei5saXRlcmFsKCd0ZXh0JyksXG4gIHRleHQ6IHouc3RyaW5nKCksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG59KTtcblxuLyoqXG5JbWFnZSBjb250ZW50IHBhcnQgb2YgYSBwcm9tcHQuIEl0IGNvbnRhaW5zIGFuIGltYWdlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlUGFydCB7XG4gIHR5cGU6ICdpbWFnZSc7XG5cbiAgLyoqXG5JbWFnZSBkYXRhLiBDYW4gZWl0aGVyIGJlOlxuXG4tIGRhdGE6IGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nLCBhIFVpbnQ4QXJyYXksIGFuIEFycmF5QnVmZmVyLCBvciBhIEJ1ZmZlclxuLSBVUkw6IGEgVVJMIHRoYXQgcG9pbnRzIHRvIHRoZSBpbWFnZVxuICAgKi9cbiAgaW1hZ2U6IERhdGFDb250ZW50IHwgVVJMO1xuXG4gIC8qKlxuT3B0aW9uYWwgbWltZSB0eXBlIG9mIHRoZSBpbWFnZS5cbiAgICovXG4gIG1pbWVUeXBlPzogc3RyaW5nO1xuXG4gIC8qKlxuQWRkaXRpb25hbCBwcm92aWRlci1zcGVjaWZpYyBtZXRhZGF0YS4gVGhleSBhcmUgcGFzc2VkIHRocm91Z2hcbnRvIHRoZSBwcm92aWRlciBmcm9tIHRoZSBBSSBTREsgYW5kIGVuYWJsZSBwcm92aWRlci1zcGVjaWZpY1xuZnVuY3Rpb25hbGl0eSB0aGF0IGNhbiBiZSBmdWxseSBlbmNhcHN1bGF0ZWQgaW4gdGhlIHByb3ZpZGVyLlxuICovXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhPzogUHJvdmlkZXJNZXRhZGF0YTtcbn1cblxuZXhwb3J0IGNvbnN0IGltYWdlUGFydFNjaGVtYTogei5ab2RUeXBlPEltYWdlUGFydD4gPSB6Lm9iamVjdCh7XG4gIHR5cGU6IHoubGl0ZXJhbCgnaW1hZ2UnKSxcbiAgaW1hZ2U6IHoudW5pb24oW2RhdGFDb250ZW50U2NoZW1hLCB6Lmluc3RhbmNlb2YoVVJMKV0pLFxuICBtaW1lVHlwZTogei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxufSk7XG5cbi8qKlxuRmlsZSBjb250ZW50IHBhcnQgb2YgYSBwcm9tcHQuIEl0IGNvbnRhaW5zIGEgZmlsZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGaWxlUGFydCB7XG4gIHR5cGU6ICdmaWxlJztcblxuICAvKipcbkZpbGUgZGF0YS4gQ2FuIGVpdGhlciBiZTpcblxuLSBkYXRhOiBhIGJhc2U2NC1lbmNvZGVkIHN0cmluZywgYSBVaW50OEFycmF5LCBhbiBBcnJheUJ1ZmZlciwgb3IgYSBCdWZmZXJcbi0gVVJMOiBhIFVSTCB0aGF0IHBvaW50cyB0byB0aGUgaW1hZ2VcbiAgICovXG4gIGRhdGE6IERhdGFDb250ZW50IHwgVVJMO1xuXG4gIC8qKlxuTWltZSB0eXBlIG9mIHRoZSBmaWxlLlxuICAgKi9cbiAgbWltZVR5cGU6IHN0cmluZztcblxuICAvKipcbkFkZGl0aW9uYWwgcHJvdmlkZXItc3BlY2lmaWMgbWV0YWRhdGEuIFRoZXkgYXJlIHBhc3NlZCB0aHJvdWdoXG50byB0aGUgcHJvdmlkZXIgZnJvbSB0aGUgQUkgU0RLIGFuZCBlbmFibGUgcHJvdmlkZXItc3BlY2lmaWNcbmZ1bmN0aW9uYWxpdHkgdGhhdCBjYW4gYmUgZnVsbHkgZW5jYXBzdWxhdGVkIGluIHRoZSBwcm92aWRlci5cbiAqL1xuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YT86IFByb3ZpZGVyTWV0YWRhdGE7XG59XG5cbmV4cG9ydCBjb25zdCBmaWxlUGFydFNjaGVtYTogei5ab2RUeXBlPEZpbGVQYXJ0PiA9IHoub2JqZWN0KHtcbiAgdHlwZTogei5saXRlcmFsKCdmaWxlJyksXG4gIGRhdGE6IHoudW5pb24oW2RhdGFDb250ZW50U2NoZW1hLCB6Lmluc3RhbmNlb2YoVVJMKV0pLFxuICBtaW1lVHlwZTogei5zdHJpbmcoKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbn0pO1xuXG4vKipcblRvb2wgY2FsbCBjb250ZW50IHBhcnQgb2YgYSBwcm9tcHQuIEl0IGNvbnRhaW5zIGEgdG9vbCBjYWxsICh1c3VhbGx5IGdlbmVyYXRlZCBieSB0aGUgQUkgbW9kZWwpLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRvb2xDYWxsUGFydCB7XG4gIHR5cGU6ICd0b29sLWNhbGwnO1xuXG4gIC8qKlxuSUQgb2YgdGhlIHRvb2wgY2FsbC4gVGhpcyBJRCBpcyB1c2VkIHRvIG1hdGNoIHRoZSB0b29sIGNhbGwgd2l0aCB0aGUgdG9vbCByZXN1bHQuXG4gKi9cbiAgdG9vbENhbGxJZDogc3RyaW5nO1xuXG4gIC8qKlxuTmFtZSBvZiB0aGUgdG9vbCB0aGF0IGlzIGJlaW5nIGNhbGxlZC5cbiAqL1xuICB0b29sTmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuQXJndW1lbnRzIG9mIHRoZSB0b29sIGNhbGwuIFRoaXMgaXMgYSBKU09OLXNlcmlhbGl6YWJsZSBvYmplY3QgdGhhdCBtYXRjaGVzIHRoZSB0b29sJ3MgaW5wdXQgc2NoZW1hLlxuICAgKi9cbiAgYXJnczogdW5rbm93bjtcblxuICAvKipcbkFkZGl0aW9uYWwgcHJvdmlkZXItc3BlY2lmaWMgbWV0YWRhdGEuIFRoZXkgYXJlIHBhc3NlZCB0aHJvdWdoXG50byB0aGUgcHJvdmlkZXIgZnJvbSB0aGUgQUkgU0RLIGFuZCBlbmFibGUgcHJvdmlkZXItc3BlY2lmaWNcbmZ1bmN0aW9uYWxpdHkgdGhhdCBjYW4gYmUgZnVsbHkgZW5jYXBzdWxhdGVkIGluIHRoZSBwcm92aWRlci5cbiAqL1xuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YT86IFByb3ZpZGVyTWV0YWRhdGE7XG59XG5cbmV4cG9ydCBjb25zdCB0b29sQ2FsbFBhcnRTY2hlbWE6IHouWm9kVHlwZTxUb29sQ2FsbFBhcnQ+ID0gei5vYmplY3Qoe1xuICB0eXBlOiB6LmxpdGVyYWwoJ3Rvb2wtY2FsbCcpLFxuICB0b29sQ2FsbElkOiB6LnN0cmluZygpLFxuICB0b29sTmFtZTogei5zdHJpbmcoKSxcbiAgYXJnczogei51bmtub3duKCksXG59KSBhcyB6LlpvZFR5cGU8VG9vbENhbGxQYXJ0PjsgLy8gbmVjZXNzYXJ5IGJjIGFyZ3MgaXMgb3B0aW9uYWwgb24gWm9kIHR5cGVcblxuLyoqXG5Ub29sIHJlc3VsdCBjb250ZW50IHBhcnQgb2YgYSBwcm9tcHQuIEl0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHRvb2wgY2FsbCB3aXRoIHRoZSBtYXRjaGluZyBJRC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUb29sUmVzdWx0UGFydCB7XG4gIHR5cGU6ICd0b29sLXJlc3VsdCc7XG5cbiAgLyoqXG5JRCBvZiB0aGUgdG9vbCBjYWxsIHRoYXQgdGhpcyByZXN1bHQgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICovXG4gIHRvb2xDYWxsSWQ6IHN0cmluZztcblxuICAvKipcbk5hbWUgb2YgdGhlIHRvb2wgdGhhdCBnZW5lcmF0ZWQgdGhpcyByZXN1bHQuXG4gICovXG4gIHRvb2xOYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG5SZXN1bHQgb2YgdGhlIHRvb2wgY2FsbC4gVGhpcyBpcyBhIEpTT04tc2VyaWFsaXphYmxlIG9iamVjdC5cbiAgICovXG4gIHJlc3VsdDogdW5rbm93bjtcblxuICAvKipcbk11bHRpLXBhcnQgY29udGVudCBvZiB0aGUgdG9vbCByZXN1bHQuIE9ubHkgZm9yIHRvb2xzIHRoYXQgc3VwcG9ydCBtdWx0aXBhcnQgcmVzdWx0cy5cbiAgICovXG4gIGV4cGVyaW1lbnRhbF9jb250ZW50PzogVG9vbFJlc3VsdENvbnRlbnQ7XG5cbiAgLyoqXG5PcHRpb25hbCBmbGFnIGlmIHRoZSByZXN1bHQgaXMgYW4gZXJyb3Igb3IgYW4gZXJyb3IgbWVzc2FnZS5cbiAgICovXG4gIGlzRXJyb3I/OiBib29sZWFuO1xuXG4gIC8qKlxuQWRkaXRpb25hbCBwcm92aWRlci1zcGVjaWZpYyBtZXRhZGF0YS4gVGhleSBhcmUgcGFzc2VkIHRocm91Z2hcbnRvIHRoZSBwcm92aWRlciBmcm9tIHRoZSBBSSBTREsgYW5kIGVuYWJsZSBwcm92aWRlci1zcGVjaWZpY1xuZnVuY3Rpb25hbGl0eSB0aGF0IGNhbiBiZSBmdWxseSBlbmNhcHN1bGF0ZWQgaW4gdGhlIHByb3ZpZGVyLlxuICovXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhPzogUHJvdmlkZXJNZXRhZGF0YTtcbn1cblxuZXhwb3J0IGNvbnN0IHRvb2xSZXN1bHRQYXJ0U2NoZW1hOiB6LlpvZFR5cGU8VG9vbFJlc3VsdFBhcnQ+ID0gei5vYmplY3Qoe1xuICB0eXBlOiB6LmxpdGVyYWwoJ3Rvb2wtcmVzdWx0JyksXG4gIHRvb2xDYWxsSWQ6IHouc3RyaW5nKCksXG4gIHRvb2xOYW1lOiB6LnN0cmluZygpLFxuICByZXN1bHQ6IHoudW5rbm93bigpLFxuICBjb250ZW50OiB0b29sUmVzdWx0Q29udGVudFNjaGVtYS5vcHRpb25hbCgpLFxuICBpc0Vycm9yOiB6LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxufSkgYXMgei5ab2RUeXBlPFRvb2xSZXN1bHRQYXJ0PjsgLy8gbmVjZXNzYXJ5IGJjIHJlc3VsdCBpcyBvcHRpb25hbCBvbiBab2QgdHlwZVxuIiwiaW1wb3J0IHsgeiB9IGZyb20gJ3pvZCc7XG5cbmV4cG9ydCB0eXBlIFRvb2xSZXN1bHRDb250ZW50ID0gQXJyYXk8XG4gIHwge1xuICAgICAgdHlwZTogJ3RleHQnO1xuICAgICAgdGV4dDogc3RyaW5nO1xuICAgIH1cbiAgfCB7XG4gICAgICB0eXBlOiAnaW1hZ2UnO1xuICAgICAgZGF0YTogc3RyaW5nOyAvLyBiYXNlNjQgZW5jb2RlZCBwbmcgaW1hZ2UsIGUuZy4gc2NyZWVuc2hvdFxuICAgICAgbWltZVR5cGU/OiBzdHJpbmc7IC8vIGUuZy4gJ2ltYWdlL3BuZyc7XG4gICAgfVxuPjtcblxuZXhwb3J0IGNvbnN0IHRvb2xSZXN1bHRDb250ZW50U2NoZW1hOiB6LlpvZFR5cGU8VG9vbFJlc3VsdENvbnRlbnQ+ID0gei5hcnJheShcbiAgei51bmlvbihbXG4gICAgei5vYmplY3QoeyB0eXBlOiB6LmxpdGVyYWwoJ3RleHQnKSwgdGV4dDogei5zdHJpbmcoKSB9KSxcbiAgICB6Lm9iamVjdCh7XG4gICAgICB0eXBlOiB6LmxpdGVyYWwoJ2ltYWdlJyksXG4gICAgICBkYXRhOiB6LnN0cmluZygpLFxuICAgICAgbWltZVR5cGU6IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICB9KSxcbiAgXSksXG4pO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNUb29sUmVzdWx0Q29udGVudChcbiAgdmFsdWU6IHVua25vd24sXG4pOiB2YWx1ZSBpcyBUb29sUmVzdWx0Q29udGVudCB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgdmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlLmV2ZXJ5KHBhcnQgPT4ge1xuICAgIGlmICh0eXBlb2YgcGFydCAhPT0gJ29iamVjdCcgfHwgcGFydCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChwYXJ0LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgcmV0dXJuIHR5cGVvZiBwYXJ0LnRleHQgPT09ICdzdHJpbmcnO1xuICAgIH1cblxuICAgIGlmIChwYXJ0LnR5cGUgPT09ICdpbWFnZScpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHR5cGVvZiBwYXJ0LmRhdGEgPT09ICdzdHJpbmcnICYmXG4gICAgICAgIChwYXJ0Lm1pbWVUeXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHBhcnQubWltZVR5cGUgPT09ICdzdHJpbmcnKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGRldGVjdFByb21wdFR5cGUoXG4gIHByb21wdDogQXJyYXk8YW55Pixcbik6ICd1aS1tZXNzYWdlcycgfCAnbWVzc2FnZXMnIHwgJ290aGVyJyB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwcm9tcHQpKSB7XG4gICAgcmV0dXJuICdvdGhlcic7XG4gIH1cblxuICBpZiAocHJvbXB0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnbWVzc2FnZXMnO1xuICB9XG5cbiAgY29uc3QgY2hhcmFjdGVyaXN0aWNzID0gcHJvbXB0Lm1hcChkZXRlY3RTaW5nbGVNZXNzYWdlQ2hhcmFjdGVyaXN0aWNzKTtcblxuICBpZiAoY2hhcmFjdGVyaXN0aWNzLnNvbWUoYyA9PiBjID09PSAnaGFzLXVpLXNwZWNpZmljLXBhcnRzJykpIHtcbiAgICByZXR1cm4gJ3VpLW1lc3NhZ2VzJztcbiAgfSBlbHNlIGlmIChcbiAgICBjaGFyYWN0ZXJpc3RpY3MuZXZlcnkoXG4gICAgICBjID0+IGMgPT09ICdoYXMtY29yZS1zcGVjaWZpYy1wYXJ0cycgfHwgYyA9PT0gJ21lc3NhZ2UnLFxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuICdtZXNzYWdlcyc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICdvdGhlcic7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0ZWN0U2luZ2xlTWVzc2FnZUNoYXJhY3RlcmlzdGljcyhcbiAgbWVzc2FnZTogYW55LFxuKTogJ2hhcy11aS1zcGVjaWZpYy1wYXJ0cycgfCAnaGFzLWNvcmUtc3BlY2lmaWMtcGFydHMnIHwgJ21lc3NhZ2UnIHwgJ290aGVyJyB7XG4gIGlmIChcbiAgICB0eXBlb2YgbWVzc2FnZSA9PT0gJ29iamVjdCcgJiZcbiAgICBtZXNzYWdlICE9PSBudWxsICYmXG4gICAgKG1lc3NhZ2Uucm9sZSA9PT0gJ2Z1bmN0aW9uJyB8fCAvLyBVSS1vbmx5IHJvbGVcbiAgICAgIG1lc3NhZ2Uucm9sZSA9PT0gJ2RhdGEnIHx8IC8vIFVJLW9ubHkgcm9sZVxuICAgICAgJ3Rvb2xJbnZvY2F0aW9ucycgaW4gbWVzc2FnZSB8fCAvLyBVSS1zcGVjaWZpYyBmaWVsZFxuICAgICAgJ2V4cGVyaW1lbnRhbF9hdHRhY2htZW50cycgaW4gbWVzc2FnZSlcbiAgKSB7XG4gICAgcmV0dXJuICdoYXMtdWktc3BlY2lmaWMtcGFydHMnO1xuICB9IGVsc2UgaWYgKFxuICAgIHR5cGVvZiBtZXNzYWdlID09PSAnb2JqZWN0JyAmJlxuICAgIG1lc3NhZ2UgIT09IG51bGwgJiZcbiAgICAnY29udGVudCcgaW4gbWVzc2FnZSAmJlxuICAgIChBcnJheS5pc0FycmF5KG1lc3NhZ2UuY29udGVudCkgfHwgLy8gQ29yZSBtZXNzYWdlcyBjYW4gaGF2ZSBhcnJheSBjb250ZW50XG4gICAgICAnZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEnIGluIG1lc3NhZ2UpXG4gICkge1xuICAgIHJldHVybiAnaGFzLWNvcmUtc3BlY2lmaWMtcGFydHMnO1xuICB9IGVsc2UgaWYgKFxuICAgIHR5cGVvZiBtZXNzYWdlID09PSAnb2JqZWN0JyAmJlxuICAgIG1lc3NhZ2UgIT09IG51bGwgJiZcbiAgICAncm9sZScgaW4gbWVzc2FnZSAmJlxuICAgICdjb250ZW50JyBpbiBtZXNzYWdlICYmXG4gICAgdHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gJ3N0cmluZycgJiZcbiAgICBbJ3N5c3RlbScsICd1c2VyJywgJ2Fzc2lzdGFudCcsICd0b29sJ10uaW5jbHVkZXMobWVzc2FnZS5yb2xlKVxuICApIHtcbiAgICByZXR1cm4gJ21lc3NhZ2UnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAnb3RoZXInO1xuICB9XG59XG4iLCJpbXBvcnQgeyBBdHRhY2htZW50IH0gZnJvbSAnQGFpLXNkay91aS11dGlscyc7XG5pbXBvcnQgeyBGaWxlUGFydCwgSW1hZ2VQYXJ0LCBUZXh0UGFydCB9IGZyb20gJy4vY29udGVudC1wYXJ0JztcbmltcG9ydCB7XG4gIGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheSxcbiAgY29udmVydFVpbnQ4QXJyYXlUb1RleHQsXG59IGZyb20gJy4vZGF0YS1jb250ZW50JztcblxudHlwZSBDb250ZW50UGFydCA9IFRleHRQYXJ0IHwgSW1hZ2VQYXJ0IHwgRmlsZVBhcnQ7XG5cbi8qKlxuICogQ29udmVydHMgYSBsaXN0IG9mIGF0dGFjaG1lbnRzIHRvIGEgbGlzdCBvZiBjb250ZW50IHBhcnRzXG4gKiBmb3IgY29uc3VtcHRpb24gYnkgYGFpL2NvcmVgIGZ1bmN0aW9ucy5cbiAqIEN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIGltYWdlcyBhbmQgdGV4dCBhdHRhY2htZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF0dGFjaG1lbnRzVG9QYXJ0cyhhdHRhY2htZW50czogQXR0YWNobWVudFtdKTogQ29udGVudFBhcnRbXSB7XG4gIGNvbnN0IHBhcnRzOiBDb250ZW50UGFydFtdID0gW107XG5cbiAgZm9yIChjb25zdCBhdHRhY2htZW50IG9mIGF0dGFjaG1lbnRzKSB7XG4gICAgbGV0IHVybDtcblxuICAgIHRyeSB7XG4gICAgICB1cmwgPSBuZXcgVVJMKGF0dGFjaG1lbnQudXJsKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFVSTDogJHthdHRhY2htZW50LnVybH1gKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHVybC5wcm90b2NvbCkge1xuICAgICAgY2FzZSAnaHR0cDonOlxuICAgICAgY2FzZSAnaHR0cHM6Jzoge1xuICAgICAgICBpZiAoYXR0YWNobWVudC5jb250ZW50VHlwZT8uc3RhcnRzV2l0aCgnaW1hZ2UvJykpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHsgdHlwZTogJ2ltYWdlJywgaW1hZ2U6IHVybCB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWF0dGFjaG1lbnQuY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgJ0lmIHRoZSBhdHRhY2htZW50IGlzIG5vdCBhbiBpbWFnZSwgaXQgbXVzdCBzcGVjaWZ5IGEgY29udGVudCB0eXBlJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnZmlsZScsXG4gICAgICAgICAgICBkYXRhOiB1cmwsXG4gICAgICAgICAgICBtaW1lVHlwZTogYXR0YWNobWVudC5jb250ZW50VHlwZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2FzZSAnZGF0YTonOiB7XG4gICAgICAgIGxldCBoZWFkZXI7XG4gICAgICAgIGxldCBiYXNlNjRDb250ZW50O1xuICAgICAgICBsZXQgbWltZVR5cGU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBbaGVhZGVyLCBiYXNlNjRDb250ZW50XSA9IGF0dGFjaG1lbnQudXJsLnNwbGl0KCcsJyk7XG4gICAgICAgICAgbWltZVR5cGUgPSBoZWFkZXIuc3BsaXQoJzsnKVswXS5zcGxpdCgnOicpWzFdO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgcHJvY2Vzc2luZyBkYXRhIFVSTDogJHthdHRhY2htZW50LnVybH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtaW1lVHlwZSA9PSBudWxsIHx8IGJhc2U2NENvbnRlbnQgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRhIFVSTCBmb3JtYXQ6ICR7YXR0YWNobWVudC51cmx9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXR0YWNobWVudC5jb250ZW50VHlwZT8uc3RhcnRzV2l0aCgnaW1hZ2UvJykpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdpbWFnZScsXG4gICAgICAgICAgICBpbWFnZTogY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KGJhc2U2NENvbnRlbnQpLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGF0dGFjaG1lbnQuY29udGVudFR5cGU/LnN0YXJ0c1dpdGgoJ3RleHQvJykpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHRleHQ6IGNvbnZlcnRVaW50OEFycmF5VG9UZXh0KFxuICAgICAgICAgICAgICBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoYmFzZTY0Q29udGVudCksXG4gICAgICAgICAgICApLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghYXR0YWNobWVudC5jb250ZW50VHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAnSWYgdGhlIGF0dGFjaG1lbnQgaXMgbm90IGFuIGltYWdlIG9yIHRleHQsIGl0IG11c3Qgc3BlY2lmeSBhIGNvbnRlbnQgdHlwZScsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ2ZpbGUnLFxuICAgICAgICAgICAgZGF0YTogYmFzZTY0Q29udGVudCxcbiAgICAgICAgICAgIG1pbWVUeXBlOiBhdHRhY2htZW50LmNvbnRlbnRUeXBlLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBVUkwgcHJvdG9jb2w6ICR7dXJsLnByb3RvY29sfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cbiIsImltcG9ydCB7IEFJU0RLRXJyb3IgfSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyJztcbmltcG9ydCB7IFVJTWVzc2FnZSB9IGZyb20gJy4vdWktbWVzc2FnZSc7XG5cbmNvbnN0IG5hbWUgPSAnQUlfTWVzc2FnZUNvbnZlcnNpb25FcnJvcic7XG5jb25zdCBtYXJrZXIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZX1gO1xuY29uc3Qgc3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIpO1xuXG5leHBvcnQgY2xhc3MgTWVzc2FnZUNvbnZlcnNpb25FcnJvciBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBwcml2YXRlIHJlYWRvbmx5IFtzeW1ib2xdID0gdHJ1ZTsgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG5cbiAgcmVhZG9ubHkgb3JpZ2luYWxNZXNzYWdlOiBVSU1lc3NhZ2U7XG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIG9yaWdpbmFsTWVzc2FnZSxcbiAgICBtZXNzYWdlLFxuICB9OiB7XG4gICAgb3JpZ2luYWxNZXNzYWdlOiBVSU1lc3NhZ2U7XG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lLCBtZXNzYWdlIH0pO1xuXG4gICAgdGhpcy5vcmlnaW5hbE1lc3NhZ2UgPSBvcmlnaW5hbE1lc3NhZ2U7XG4gIH1cblxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcjogdW5rbm93bik6IGVycm9yIGlzIE1lc3NhZ2VDb252ZXJzaW9uRXJyb3Ige1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ29yZU1lc3NhZ2UsIFRvb2xDYWxsUGFydCwgVG9vbFJlc3VsdFBhcnQgfSBmcm9tICcuLi9wcm9tcHQnO1xuaW1wb3J0IHsgQ29yZVRvb2wgfSBmcm9tICcuLi90b29sL3Rvb2wnO1xuaW1wb3J0IHsgYXR0YWNobWVudHNUb1BhcnRzIH0gZnJvbSAnLi9hdHRhY2htZW50cy10by1wYXJ0cyc7XG5pbXBvcnQgeyBNZXNzYWdlQ29udmVyc2lvbkVycm9yIH0gZnJvbSAnLi9tZXNzYWdlLWNvbnZlcnNpb24tZXJyb3InO1xuaW1wb3J0IHsgVUlNZXNzYWdlIH0gZnJvbSAnLi91aS1tZXNzYWdlJztcblxuLyoqXG5Db252ZXJ0cyBhbiBhcnJheSBvZiBtZXNzYWdlcyBmcm9tIHVzZUNoYXQgaW50byBhbiBhcnJheSBvZiBDb3JlTWVzc2FnZXMgdGhhdCBjYW4gYmUgdXNlZFxud2l0aCB0aGUgQUkgY29yZSBmdW5jdGlvbnMgKGUuZy4gYHN0cmVhbVRleHRgKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb0NvcmVNZXNzYWdlczxcbiAgVE9PTFMgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBDb3JlVG9vbD4gPSBuZXZlcixcbj4obWVzc2FnZXM6IEFycmF5PFVJTWVzc2FnZT4sIG9wdGlvbnM/OiB7IHRvb2xzPzogVE9PTFMgfSkge1xuICBjb25zdCB0b29scyA9IG9wdGlvbnM/LnRvb2xzID8/ICh7fSBhcyBUT09MUyk7XG4gIGNvbnN0IGNvcmVNZXNzYWdlczogQ29yZU1lc3NhZ2VbXSA9IFtdO1xuXG4gIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcykge1xuICAgIGNvbnN0IHsgcm9sZSwgY29udGVudCwgdG9vbEludm9jYXRpb25zLCBleHBlcmltZW50YWxfYXR0YWNobWVudHMgfSA9XG4gICAgICBtZXNzYWdlO1xuXG4gICAgc3dpdGNoIChyb2xlKSB7XG4gICAgICBjYXNlICdzeXN0ZW0nOiB7XG4gICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiAnc3lzdGVtJyxcbiAgICAgICAgICBjb250ZW50LFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgJ3VzZXInOiB7XG4gICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgY29udGVudDogZXhwZXJpbWVudGFsX2F0dGFjaG1lbnRzXG4gICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICB7IHR5cGU6ICd0ZXh0JywgdGV4dDogY29udGVudCB9LFxuICAgICAgICAgICAgICAgIC4uLmF0dGFjaG1lbnRzVG9QYXJ0cyhleHBlcmltZW50YWxfYXR0YWNobWVudHMpLFxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICA6IGNvbnRlbnQsXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2FzZSAnYXNzaXN0YW50Jzoge1xuICAgICAgICBpZiAodG9vbEludm9jYXRpb25zID09IG51bGwpIHtcbiAgICAgICAgICBjb3JlTWVzc2FnZXMucHVzaCh7IHJvbGU6ICdhc3Npc3RhbnQnLCBjb250ZW50IH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXNzaXN0YW50IG1lc3NhZ2Ugd2l0aCB0b29sIGNhbGxzXG4gICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICB7IHR5cGU6ICd0ZXh0JywgdGV4dDogY29udGVudCB9LFxuICAgICAgICAgICAgLi4udG9vbEludm9jYXRpb25zLm1hcChcbiAgICAgICAgICAgICAgKHsgdG9vbENhbGxJZCwgdG9vbE5hbWUsIGFyZ3MgfSk6IFRvb2xDYWxsUGFydCA9PiAoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0b29sLWNhbGwnIGFzIGNvbnN0LFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICApLFxuICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHRvb2wgbWVzc2FnZSB3aXRoIHRvb2wgcmVzdWx0c1xuICAgICAgICBjb3JlTWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgcm9sZTogJ3Rvb2wnLFxuICAgICAgICAgIGNvbnRlbnQ6IHRvb2xJbnZvY2F0aW9ucy5tYXAoKHRvb2xJbnZvY2F0aW9uKTogVG9vbFJlc3VsdFBhcnQgPT4ge1xuICAgICAgICAgICAgaWYgKCEoJ3Jlc3VsdCcgaW4gdG9vbEludm9jYXRpb24pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBNZXNzYWdlQ29udmVyc2lvbkVycm9yKHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbE1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgICAgICdUb29sSW52b2NhdGlvbiBtdXN0IGhhdmUgYSByZXN1bHQ6ICcgK1xuICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkodG9vbEludm9jYXRpb24pLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgeyB0b29sQ2FsbElkLCB0b29sTmFtZSwgcmVzdWx0IH0gPSB0b29sSW52b2NhdGlvbjtcblxuICAgICAgICAgICAgY29uc3QgdG9vbCA9IHRvb2xzW3Rvb2xOYW1lXTtcbiAgICAgICAgICAgIHJldHVybiB0b29sPy5leHBlcmltZW50YWxfdG9Ub29sUmVzdWx0Q29udGVudCAhPSBudWxsXG4gICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ3Rvb2wtcmVzdWx0JyxcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDogdG9vbC5leHBlcmltZW50YWxfdG9Ub29sUmVzdWx0Q29udGVudChyZXN1bHQpLFxuICAgICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRlbnQ6XG4gICAgICAgICAgICAgICAgICAgIHRvb2wuZXhwZXJpbWVudGFsX3RvVG9vbFJlc3VsdENvbnRlbnQocmVzdWx0KSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ3Rvb2wtcmVzdWx0JyxcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgIH0pLFxuICAgICAgICB9KTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgY2FzZSAnZGF0YSc6XG4gICAgICBjYXNlICd0b29sJzoge1xuICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjazogbmV2ZXIgPSByb2xlO1xuICAgICAgICB0aHJvdyBuZXcgTWVzc2FnZUNvbnZlcnNpb25FcnJvcih7XG4gICAgICAgICAgb3JpZ2luYWxNZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgIG1lc3NhZ2U6IGBVbnN1cHBvcnRlZCByb2xlOiAke19leGhhdXN0aXZlQ2hlY2t9YCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvcmVNZXNzYWdlcztcbn1cbiIsIi8qKlxuUmVwcmVzZW50cyB0aGUgbnVtYmVyIG9mIHRva2VucyB1c2VkIGluIGEgcHJvbXB0IGFuZCBjb21wbGV0aW9uLlxuICovXG5leHBvcnQgdHlwZSBMYW5ndWFnZU1vZGVsVXNhZ2UgPSB7XG4gIC8qKlxuVGhlIG51bWJlciBvZiB0b2tlbnMgdXNlZCBpbiB0aGUgcHJvbXB0LlxuICAgKi9cbiAgcHJvbXB0VG9rZW5zOiBudW1iZXI7XG5cbiAgLyoqXG5UaGUgbnVtYmVyIG9mIHRva2VucyB1c2VkIGluIHRoZSBjb21wbGV0aW9uLlxuICovXG4gIGNvbXBsZXRpb25Ub2tlbnM6IG51bWJlcjtcblxuICAvKipcblRoZSB0b3RhbCBudW1iZXIgb2YgdG9rZW5zIHVzZWQgKHByb21wdFRva2VucyArIGNvbXBsZXRpb25Ub2tlbnMpLlxuICAgKi9cbiAgdG90YWxUb2tlbnM6IG51bWJlcjtcbn07XG5cbi8qKlxuUmVwcmVzZW50cyB0aGUgbnVtYmVyIG9mIHRva2VucyB1c2VkIGluIGEgcHJvbXB0IGFuZCBjb21wbGV0aW9uLlxuXG5AZGVwcmVjYXRlZCBVc2UgYExhbmd1YWdlTW9kZWxVc2FnZWAgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IHR5cGUgQ29tcGxldGlvblRva2VuVXNhZ2UgPSBMYW5ndWFnZU1vZGVsVXNhZ2U7XG5cbi8qKlxuUmVwcmVzZW50cyB0aGUgbnVtYmVyIG9mIHRva2VucyB1c2VkIGluIGFuIGVtYmVkZGluZy5cbiAqL1xuZXhwb3J0IHR5cGUgRW1iZWRkaW5nTW9kZWxVc2FnZSA9IHtcbiAgLyoqXG5UaGUgbnVtYmVyIG9mIHRva2VucyB1c2VkIGluIHRoZSBlbWJlZGRpbmcuXG4gICAqL1xuICB0b2tlbnM6IG51bWJlcjtcbn07XG5cbi8qKlxuUmVwcmVzZW50cyB0aGUgbnVtYmVyIG9mIHRva2VucyB1c2VkIGluIGFuIGVtYmVkZGluZy5cblxuQGRlcHJlY2F0ZWQgVXNlIGBFbWJlZGRpbmdNb2RlbFVzYWdlYCBpbnN0ZWFkLlxuICovXG5leHBvcnQgdHlwZSBFbWJlZGRpbmdUb2tlblVzYWdlID0gRW1iZWRkaW5nTW9kZWxVc2FnZTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZSh1c2FnZToge1xuICBwcm9tcHRUb2tlbnM6IG51bWJlcjtcbiAgY29tcGxldGlvblRva2VuczogbnVtYmVyO1xufSk6IExhbmd1YWdlTW9kZWxVc2FnZSB7XG4gIHJldHVybiB7XG4gICAgcHJvbXB0VG9rZW5zOiB1c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgY29tcGxldGlvblRva2VuczogdXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICB0b3RhbFRva2VuczogdXNhZ2UucHJvbXB0VG9rZW5zICsgdXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgfTtcbn1cbiIsImltcG9ydCB7IEFJU0RLRXJyb3IsIGdldEVycm9yTWVzc2FnZSB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuXG5jb25zdCBuYW1lID0gJ0FJX0ludmFsaWRUb29sQXJndW1lbnRzRXJyb3InO1xuY29uc3QgbWFya2VyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWV9YDtcbmNvbnN0IHN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyKTtcblxuZXhwb3J0IGNsYXNzIEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgcHJpdmF0ZSByZWFkb25seSBbc3ltYm9sXSA9IHRydWU7IC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuXG4gIHJlYWRvbmx5IHRvb2xOYW1lOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHRvb2xBcmdzOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIHRvb2xBcmdzLFxuICAgIHRvb2xOYW1lLFxuICAgIGNhdXNlLFxuICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBhcmd1bWVudHMgZm9yIHRvb2wgJHt0b29sTmFtZX06ICR7Z2V0RXJyb3JNZXNzYWdlKFxuICAgICAgY2F1c2UsXG4gICAgKX1gLFxuICB9OiB7XG4gICAgbWVzc2FnZT86IHN0cmluZztcbiAgICB0b29sQXJnczogc3RyaW5nO1xuICAgIHRvb2xOYW1lOiBzdHJpbmc7XG4gICAgY2F1c2U6IHVua25vd247XG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWUsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuXG4gICAgdGhpcy50b29sQXJncyA9IHRvb2xBcmdzO1xuICAgIHRoaXMudG9vbE5hbWUgPSB0b29sTmFtZTtcbiAgfVxuXG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvciB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvcihcbiAgICBlcnJvcjogdW5rbm93bixcbiAgKTogZXJyb3IgaXMgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvciB7XG4gICAgcmV0dXJuIChcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgIGVycm9yLm5hbWUgPT09IG5hbWUgJiZcbiAgICAgIHR5cGVvZiAoZXJyb3IgYXMgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvcikudG9vbE5hbWUgPT09ICdzdHJpbmcnICYmXG4gICAgICB0eXBlb2YgKGVycm9yIGFzIEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IpLnRvb2xBcmdzID09PSAnc3RyaW5nJ1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIGNhdXNlOiB0aGlzLmNhdXNlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG5cbiAgICAgIHRvb2xOYW1lOiB0aGlzLnRvb2xOYW1lLFxuICAgICAgdG9vbEFyZ3M6IHRoaXMudG9vbEFyZ3MsXG4gICAgfTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgQUlTREtFcnJvciB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuXG5jb25zdCBuYW1lID0gJ0FJX05vU3VjaFRvb2xFcnJvcic7XG5jb25zdCBtYXJrZXIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZX1gO1xuY29uc3Qgc3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIpO1xuXG5leHBvcnQgY2xhc3MgTm9TdWNoVG9vbEVycm9yIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgW3N5bWJvbF0gPSB0cnVlOyAvLyB1c2VkIGluIGlzSW5zdGFuY2VcblxuICByZWFkb25seSB0b29sTmFtZTogc3RyaW5nO1xuICByZWFkb25seSBhdmFpbGFibGVUb29sczogc3RyaW5nW10gfCB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIHRvb2xOYW1lLFxuICAgIGF2YWlsYWJsZVRvb2xzID0gdW5kZWZpbmVkLFxuICAgIG1lc3NhZ2UgPSBgTW9kZWwgdHJpZWQgdG8gY2FsbCB1bmF2YWlsYWJsZSB0b29sICcke3Rvb2xOYW1lfScuICR7XG4gICAgICBhdmFpbGFibGVUb29scyA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gJ05vIHRvb2xzIGFyZSBhdmFpbGFibGUuJ1xuICAgICAgICA6IGBBdmFpbGFibGUgdG9vbHM6ICR7YXZhaWxhYmxlVG9vbHMuam9pbignLCAnKX0uYFxuICAgIH1gLFxuICB9OiB7XG4gICAgdG9vbE5hbWU6IHN0cmluZztcbiAgICBhdmFpbGFibGVUb29scz86IHN0cmluZ1tdIHwgdW5kZWZpbmVkO1xuICAgIG1lc3NhZ2U/OiBzdHJpbmc7XG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWUsIG1lc3NhZ2UgfSk7XG5cbiAgICB0aGlzLnRvb2xOYW1lID0gdG9vbE5hbWU7XG4gICAgdGhpcy5hdmFpbGFibGVUb29scyA9IGF2YWlsYWJsZVRvb2xzO1xuICB9XG5cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBOb1N1Y2hUb29sRXJyb3Ige1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc05vU3VjaFRvb2xFcnJvcihlcnJvcjogdW5rbm93bik6IGVycm9yIGlzIE5vU3VjaFRvb2xFcnJvciB7XG4gICAgcmV0dXJuIChcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgIGVycm9yLm5hbWUgPT09IG5hbWUgJiZcbiAgICAgICd0b29sTmFtZScgaW4gZXJyb3IgJiZcbiAgICAgIGVycm9yLnRvb2xOYW1lICE9IHVuZGVmaW5lZCAmJlxuICAgICAgdHlwZW9mIGVycm9yLm5hbWUgPT09ICdzdHJpbmcnXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG5cbiAgICAgIHRvb2xOYW1lOiB0aGlzLnRvb2xOYW1lLFxuICAgICAgYXZhaWxhYmxlVG9vbHM6IHRoaXMuYXZhaWxhYmxlVG9vbHMsXG4gICAgfTtcbiAgfVxufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGlzQXN5bmNHZW5lcmF0b3I8VCwgVFJldHVybiwgVE5leHQ+KFxuICB2YWx1ZTogdW5rbm93bixcbik6IHZhbHVlIGlzIEFzeW5jR2VuZXJhdG9yPFQsIFRSZXR1cm4sIFROZXh0PiB7XG4gIHJldHVybiAoXG4gICAgdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIHZhbHVlXG4gICk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gaXNHZW5lcmF0b3I8VCwgVFJldHVybiwgVE5leHQ+KFxuICB2YWx1ZTogdW5rbm93bixcbik6IHZhbHVlIGlzIEdlbmVyYXRvcjxULCBUUmV0dXJuLCBUTmV4dD4ge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIFN5bWJvbC5pdGVyYXRvciBpbiB2YWx1ZTtcbn1cbiIsImltcG9ydCB7IEFQSUNhbGxFcnJvciB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuaW1wb3J0IHsgZ2V0RXJyb3JNZXNzYWdlLCBpc0Fib3J0RXJyb3IgfSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyLXV0aWxzJztcbmltcG9ydCB7IGRlbGF5IH0gZnJvbSAnLi9kZWxheSc7XG5pbXBvcnQgeyBSZXRyeUVycm9yIH0gZnJvbSAnLi9yZXRyeS1lcnJvcic7XG5cbmV4cG9ydCB0eXBlIFJldHJ5RnVuY3Rpb24gPSA8T1VUUFVUPihcbiAgZm46ICgpID0+IFByb21pc2VMaWtlPE9VVFBVVD4sXG4pID0+IFByb21pc2VMaWtlPE9VVFBVVD47XG5cbi8qKlxuVGhlIGByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmZgIHN0cmF0ZWd5IHJldHJpZXMgYSBmYWlsZWQgQVBJIGNhbGwgd2l0aCBhbiBleHBvbmVudGlhbCBiYWNrb2ZmLlxuWW91IGNhbiBjb25maWd1cmUgdGhlIG1heGltdW0gbnVtYmVyIG9mIHJldHJpZXMsIHRoZSBpbml0aWFsIGRlbGF5LCBhbmQgdGhlIGJhY2tvZmYgZmFjdG9yLlxuICovXG5leHBvcnQgY29uc3QgcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmID1cbiAgKHtcbiAgICBtYXhSZXRyaWVzID0gMixcbiAgICBpbml0aWFsRGVsYXlJbk1zID0gMjAwMCxcbiAgICBiYWNrb2ZmRmFjdG9yID0gMixcbiAgfSA9IHt9KTogUmV0cnlGdW5jdGlvbiA9PlxuICBhc3luYyA8T1VUUFVUPihmOiAoKSA9PiBQcm9taXNlTGlrZTxPVVRQVVQ+KSA9PlxuICAgIF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoZiwge1xuICAgICAgbWF4UmV0cmllcyxcbiAgICAgIGRlbGF5SW5NczogaW5pdGlhbERlbGF5SW5NcyxcbiAgICAgIGJhY2tvZmZGYWN0b3IsXG4gICAgfSk7XG5cbmFzeW5jIGZ1bmN0aW9uIF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmY8T1VUUFVUPihcbiAgZjogKCkgPT4gUHJvbWlzZUxpa2U8T1VUUFVUPixcbiAge1xuICAgIG1heFJldHJpZXMsXG4gICAgZGVsYXlJbk1zLFxuICAgIGJhY2tvZmZGYWN0b3IsXG4gIH06IHsgbWF4UmV0cmllczogbnVtYmVyOyBkZWxheUluTXM6IG51bWJlcjsgYmFja29mZkZhY3RvcjogbnVtYmVyIH0sXG4gIGVycm9yczogdW5rbm93bltdID0gW10sXG4pOiBQcm9taXNlPE9VVFBVVD4ge1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBmKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yOyAvLyBkb24ndCByZXRyeSB3aGVuIHRoZSByZXF1ZXN0IHdhcyBhYm9ydGVkXG4gICAgfVxuXG4gICAgaWYgKG1heFJldHJpZXMgPT09IDApIHtcbiAgICAgIHRocm93IGVycm9yOyAvLyBkb24ndCB3cmFwIHRoZSBlcnJvciB3aGVuIHJldHJpZXMgYXJlIGRpc2FibGVkXG4gICAgfVxuXG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZ2V0RXJyb3JNZXNzYWdlKGVycm9yKTtcbiAgICBjb25zdCBuZXdFcnJvcnMgPSBbLi4uZXJyb3JzLCBlcnJvcl07XG4gICAgY29uc3QgdHJ5TnVtYmVyID0gbmV3RXJyb3JzLmxlbmd0aDtcblxuICAgIGlmICh0cnlOdW1iZXIgPiBtYXhSZXRyaWVzKSB7XG4gICAgICB0aHJvdyBuZXcgUmV0cnlFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgYWZ0ZXIgJHt0cnlOdW1iZXJ9IGF0dGVtcHRzLiBMYXN0IGVycm9yOiAke2Vycm9yTWVzc2FnZX1gLFxuICAgICAgICByZWFzb246ICdtYXhSZXRyaWVzRXhjZWVkZWQnLFxuICAgICAgICBlcnJvcnM6IG5ld0Vycm9ycyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgIEFQSUNhbGxFcnJvci5pc0FQSUNhbGxFcnJvcihlcnJvcikgJiZcbiAgICAgIGVycm9yLmlzUmV0cnlhYmxlID09PSB0cnVlICYmXG4gICAgICB0cnlOdW1iZXIgPD0gbWF4UmV0cmllc1xuICAgICkge1xuICAgICAgYXdhaXQgZGVsYXkoZGVsYXlJbk1zKTtcbiAgICAgIHJldHVybiBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKFxuICAgICAgICBmLFxuICAgICAgICB7IG1heFJldHJpZXMsIGRlbGF5SW5NczogYmFja29mZkZhY3RvciAqIGRlbGF5SW5NcywgYmFja29mZkZhY3RvciB9LFxuICAgICAgICBuZXdFcnJvcnMsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0cnlOdW1iZXIgPT09IDEpIHtcbiAgICAgIHRocm93IGVycm9yOyAvLyBkb24ndCB3cmFwIHRoZSBlcnJvciB3aGVuIGEgbm9uLXJldHJ5YWJsZSBlcnJvciBvY2N1cnMgb24gdGhlIGZpcnN0IHRyeVxuICAgIH1cblxuICAgIHRocm93IG5ldyBSZXRyeUVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgYWZ0ZXIgJHt0cnlOdW1iZXJ9IGF0dGVtcHRzIHdpdGggbm9uLXJldHJ5YWJsZSBlcnJvcjogJyR7ZXJyb3JNZXNzYWdlfSdgLFxuICAgICAgcmVhc29uOiAnZXJyb3JOb3RSZXRyeWFibGUnLFxuICAgICAgZXJyb3JzOiBuZXdFcnJvcnMsXG4gICAgfSk7XG4gIH1cbn1cbiIsImV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxheShkZWxheUluTXM/OiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgcmV0dXJuIGRlbGF5SW5NcyA9PT0gdW5kZWZpbmVkXG4gICAgPyBQcm9taXNlLnJlc29sdmUoKVxuICAgIDogbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5SW5NcykpO1xufVxuIiwiaW1wb3J0IHsgQUlTREtFcnJvciB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuXG5jb25zdCBuYW1lID0gJ0FJX1JldHJ5RXJyb3InO1xuY29uc3QgbWFya2VyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWV9YDtcbmNvbnN0IHN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyKTtcblxuZXhwb3J0IHR5cGUgUmV0cnlFcnJvclJlYXNvbiA9XG4gIHwgJ21heFJldHJpZXNFeGNlZWRlZCdcbiAgfCAnZXJyb3JOb3RSZXRyeWFibGUnXG4gIHwgJ2Fib3J0JztcblxuZXhwb3J0IGNsYXNzIFJldHJ5RXJyb3IgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgcHJpdmF0ZSByZWFkb25seSBbc3ltYm9sXSA9IHRydWU7IC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuXG4gIC8vIG5vdGU6IHByb3BlcnR5IG9yZGVyIGRldGVybWluZXMgZGVidWdnaW5nIG91dHB1dFxuICByZWFkb25seSByZWFzb246IFJldHJ5RXJyb3JSZWFzb247XG4gIHJlYWRvbmx5IGxhc3RFcnJvcjogdW5rbm93bjtcbiAgcmVhZG9ubHkgZXJyb3JzOiBBcnJheTx1bmtub3duPjtcblxuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSxcbiAgICByZWFzb24sXG4gICAgZXJyb3JzLFxuICB9OiB7XG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICAgIHJlYXNvbjogUmV0cnlFcnJvclJlYXNvbjtcbiAgICBlcnJvcnM6IEFycmF5PHVua25vd24+O1xuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lLCBtZXNzYWdlIH0pO1xuXG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG5cbiAgICAvLyBzZXBhcmF0ZSBvdXIgbGFzdCBlcnJvciB0byBtYWtlIGRlYnVnZ2luZyB2aWEgbG9nIGVhc2llcjpcbiAgICB0aGlzLmxhc3RFcnJvciA9IGVycm9yc1tlcnJvcnMubGVuZ3RoIC0gMV07XG4gIH1cblxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcjogdW5rbm93bik6IGVycm9yIGlzIFJldHJ5RXJyb3Ige1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc1JldHJ5RXJyb3IoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBSZXRyeUVycm9yIHtcbiAgICByZXR1cm4gKFxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgZXJyb3IubmFtZSA9PT0gbmFtZSAmJlxuICAgICAgdHlwZW9mIChlcnJvciBhcyBSZXRyeUVycm9yKS5yZWFzb24gPT09ICdzdHJpbmcnICYmXG4gICAgICBBcnJheS5pc0FycmF5KChlcnJvciBhcyBSZXRyeUVycm9yKS5lcnJvcnMpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgcmVhc29uOiB0aGlzLnJlYXNvbixcbiAgICAgIGxhc3RFcnJvcjogdGhpcy5sYXN0RXJyb3IsXG4gICAgICBlcnJvcnM6IHRoaXMuZXJyb3JzLFxuICAgIH07XG4gIH1cbn1cbiIsIi8qKlxuICogV2FybmluZyB0aW1lIGZvciBub3RpZnlpbmcgZGV2ZWxvcGVycyB0aGF0IGEgc3RyZWFtIGlzIGhhbmdpbmcgaW4gZGV2IG1vZGVcbiAqIHVzaW5nIGEgY29uc29sZS53YXJuLlxuICovXG5leHBvcnQgY29uc3QgSEFOR0lOR19TVFJFQU1fV0FSTklOR19USU1FX01TID0gMTUgKiAxMDAwO1xuIiwiaW1wb3J0IFJlYWN0LCB7IFN1c3BlbnNlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlUmVzb2x2YWJsZVByb21pc2UgfSBmcm9tICcuLi8uLi91dGlsL2NyZWF0ZS1yZXNvbHZhYmxlLXByb21pc2UnO1xuXG4vLyBSZWN1cnNpdmUgdHlwZSBmb3IgdGhlIGNodW5rLlxudHlwZSBDaHVua1R5cGUgPVxuICB8IHtcbiAgICAgIGRvbmU6IGZhbHNlO1xuICAgICAgdmFsdWU6IFJlYWN0LlJlYWN0Tm9kZTtcbiAgICAgIG5leHQ6IFByb21pc2U8Q2h1bmtUeXBlPjtcbiAgICAgIGFwcGVuZD86IGJvb2xlYW47XG4gICAgfVxuICB8IHtcbiAgICAgIGRvbmU6IHRydWU7XG4gICAgICB2YWx1ZTogUmVhY3QuUmVhY3ROb2RlO1xuICAgIH07XG5cbi8vIFVzZSBzaW5nbGUgbGV0dGVyIG5hbWVzIGZvciB0aGUgdmFyaWFibGVzIHRvIHJlZHVjZSB0aGUgc2l6ZSBvZiB0aGUgUlNDIHBheWxvYWQuXG4vLyBgUmAgZm9yIGBSb3dgLCBgY2AgZm9yIGBjdXJyZW50YCwgYG5gIGZvciBgbmV4dGAuXG4vLyBOb3RlOiBBcnJheSBjb25zdHJ1Y3Rpb24gaXMgbmVlZGVkIHRvIGFjY2VzcyB0aGUgbmFtZSBSLlxuY29uc3QgUiA9IFtcbiAgKGFzeW5jICh7XG4gICAgYzogY3VycmVudCxcbiAgICBuOiBuZXh0LFxuICB9OiB7XG4gICAgYzogUmVhY3QuUmVhY3ROb2RlO1xuICAgIG46IFByb21pc2U8Q2h1bmtUeXBlPjtcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGNodW5rID0gYXdhaXQgbmV4dDtcblxuICAgIGlmIChjaHVuay5kb25lKSB7XG4gICAgICByZXR1cm4gY2h1bmsudmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGNodW5rLmFwcGVuZCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICB7Y3VycmVudH1cbiAgICAgICAgICA8U3VzcGVuc2UgZmFsbGJhY2s9e2NodW5rLnZhbHVlfT5cbiAgICAgICAgICAgIDxSIGM9e2NodW5rLnZhbHVlfSBuPXtjaHVuay5uZXh0fSAvPlxuICAgICAgICAgIDwvU3VzcGVuc2U+XG4gICAgICAgIDwvPlxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPFN1c3BlbnNlIGZhbGxiYWNrPXtjaHVuay52YWx1ZX0+XG4gICAgICAgIDxSIGM9e2NodW5rLnZhbHVlfSBuPXtjaHVuay5uZXh0fSAvPlxuICAgICAgPC9TdXNwZW5zZT5cbiAgICApO1xuICB9KSBhcyB1bmtub3duIGFzIFJlYWN0LkZDPHtcbiAgICBjOiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgbjogUHJvbWlzZTxDaHVua1R5cGU+O1xuICB9Pixcbl1bMF07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN1c3BlbmRlZCBjaHVuayBmb3IgUmVhY3QgU2VydmVyIENvbXBvbmVudHMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBnZW5lcmF0ZXMgYSBzdXNwZW5zZWZ1bCBSZWFjdCBjb21wb25lbnQgdGhhdCBjYW4gYmUgZHluYW1pY2FsbHkgdXBkYXRlZC5cbiAqIEl0J3MgdXNlZnVsIGZvciBzdHJlYW1pbmcgdXBkYXRlcyB0byB0aGUgY2xpZW50IGluIGEgUmVhY3QgU2VydmVyIENvbXBvbmVudHMgY29udGV4dC5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0LlJlYWN0Tm9kZX0gaW5pdGlhbFZhbHVlIC0gVGhlIGluaXRpYWwgdmFsdWUgdG8gcmVuZGVyIHdoaWxlIHRoZSBwcm9taXNlIGlzIHBlbmRpbmcuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZzpcbiAqICAgLSByb3c6IEEgUmVhY3Qgbm9kZSB0aGF0IHJlbmRlcnMgdGhlIHN1c3BlbnNlZnVsIGNvbnRlbnQuXG4gKiAgIC0gcmVzb2x2ZTogQSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBwcm9taXNlIHdpdGggYSBuZXcgdmFsdWUuXG4gKiAgIC0gcmVqZWN0OiBBIGZ1bmN0aW9uIHRvIHJlamVjdCB0aGUgcHJvbWlzZSB3aXRoIGFuIGVycm9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3VzcGVuZGVkQ2h1bmsoaW5pdGlhbFZhbHVlOiBSZWFjdC5SZWFjdE5vZGUpOiB7XG4gIHJvdzogUmVhY3QuUmVhY3ROb2RlO1xuICByZXNvbHZlOiAodmFsdWU6IENodW5rVHlwZSkgPT4gdm9pZDtcbiAgcmVqZWN0OiAoZXJyb3I6IHVua25vd24pID0+IHZvaWQ7XG59IHtcbiAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlLCByZWplY3QgfSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlPENodW5rVHlwZT4oKTtcblxuICByZXR1cm4ge1xuICAgIHJvdzogKFxuICAgICAgPFN1c3BlbnNlIGZhbGxiYWNrPXtpbml0aWFsVmFsdWV9PlxuICAgICAgICA8UiBjPXtpbml0aWFsVmFsdWV9IG49e3Byb21pc2V9IC8+XG4gICAgICA8L1N1c3BlbnNlPlxuICAgICksXG4gICAgcmVzb2x2ZSxcbiAgICByZWplY3QsXG4gIH07XG59XG4iLCJpbXBvcnQgeyBIQU5HSU5HX1NUUkVBTV9XQVJOSU5HX1RJTUVfTVMgfSBmcm9tICcuLi8uLi91dGlsL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSB9IGZyb20gJy4uLy4uL3V0aWwvY3JlYXRlLXJlc29sdmFibGUtcHJvbWlzZSc7XG5pbXBvcnQgeyBjcmVhdGVTdXNwZW5kZWRDaHVuayB9IGZyb20gJy4vY3JlYXRlLXN1c3BlbmRlZC1jaHVuayc7XG5cbi8vIEl0J3MgbmVjZXNzYXJ5IHRvIGRlZmluZSB0aGUgdHlwZSBtYW51YWxseSBoZXJlLCBvdGhlcndpc2UgVHlwZVNjcmlwdCBjb21waWxlclxuLy8gd2lsbCBub3QgYmUgYWJsZSB0byBpbmZlciB0aGUgY29ycmVjdCByZXR1cm4gdHlwZSBhcyBpdCdzIGNpcmN1bGFyLlxudHlwZSBTdHJlYW1hYmxlVUlXcmFwcGVyID0ge1xuICAvKipcbiAgICogVGhlIHZhbHVlIG9mIHRoZSBzdHJlYW1hYmxlIFVJLiBUaGlzIGNhbiBiZSByZXR1cm5lZCBmcm9tIGEgU2VydmVyIEFjdGlvbiBhbmQgcmVjZWl2ZWQgYnkgdGhlIGNsaWVudC5cbiAgICovXG4gIHJlYWRvbmx5IHZhbHVlOiBSZWFjdC5SZWFjdE5vZGU7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHVwZGF0ZXMgdGhlIGN1cnJlbnQgVUkgbm9kZS4gSXQgdGFrZXMgYSBuZXcgVUkgbm9kZSBhbmQgcmVwbGFjZXMgdGhlIG9sZCBvbmUuXG4gICAqL1xuICB1cGRhdGUodmFsdWU6IFJlYWN0LlJlYWN0Tm9kZSk6IFN0cmVhbWFibGVVSVdyYXBwZXI7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gYXBwZW5kIGEgbmV3IFVJIG5vZGUgdG8gdGhlIGVuZCBvZiB0aGUgb2xkIG9uZS5cbiAgICogT25jZSBhcHBlbmRlZCBhIG5ldyBVSSBub2RlLCB0aGUgcHJldmlvdXMgVUkgbm9kZSBjYW5ub3QgYmUgdXBkYXRlZCBhbnltb3JlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc3hcbiAgICogY29uc3QgdWkgPSBjcmVhdGVTdHJlYW1hYmxlVUkoPGRpdj5oZWxsbzwvZGl2PilcbiAgICogdWkuYXBwZW5kKDxkaXY+d29ybGQ8L2Rpdj4pXG4gICAqXG4gICAqIC8vIFRoZSBVSSBub2RlIHdpbGwgYmU6XG4gICAqIC8vIDw+XG4gICAqIC8vICAgPGRpdj5oZWxsbzwvZGl2PlxuICAgKiAvLyAgIDxkaXY+d29ybGQ8L2Rpdj5cbiAgICogLy8gPC8+XG4gICAqIGBgYFxuICAgKi9cbiAgYXBwZW5kKHZhbHVlOiBSZWFjdC5SZWFjdE5vZGUpOiBTdHJlYW1hYmxlVUlXcmFwcGVyO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIHNpZ25hbCB0aGF0IHRoZXJlIGlzIGFuIGVycm9yIGluIHRoZSBVSSBzdHJlYW0uXG4gICAqIEl0IHdpbGwgYmUgdGhyb3duIG9uIHRoZSBjbGllbnQgc2lkZSBhbmQgY2F1Z2h0IGJ5IHRoZSBuZWFyZXN0IGVycm9yIGJvdW5kYXJ5IGNvbXBvbmVudC5cbiAgICovXG4gIGVycm9yKGVycm9yOiBhbnkpOiBTdHJlYW1hYmxlVUlXcmFwcGVyO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBtYXJrcyB0aGUgVUkgbm9kZSBhcyBmaW5hbGl6ZWQuIFlvdSBjYW4gZWl0aGVyIGNhbGwgaXQgd2l0aG91dCBhbnkgcGFyYW1ldGVycyBvciB3aXRoIGEgbmV3IFVJIG5vZGUgYXMgdGhlIGZpbmFsIHN0YXRlLlxuICAgKiBPbmNlIGNhbGxlZCwgdGhlIFVJIG5vZGUgY2Fubm90IGJlIHVwZGF0ZWQgb3IgYXBwZW5kZWQgYW55bW9yZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgYWx3YXlzICoqcmVxdWlyZWQqKiB0byBiZSBjYWxsZWQsIG90aGVyd2lzZSB0aGUgcmVzcG9uc2Ugd2lsbCBiZSBzdHVjayBpbiBhIGxvYWRpbmcgc3RhdGUuXG4gICAqL1xuICBkb25lKC4uLmFyZ3M6IFtSZWFjdC5SZWFjdE5vZGVdIHwgW10pOiBTdHJlYW1hYmxlVUlXcmFwcGVyO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBwaWVjZSBvZiBjaGFuZ2VhYmxlIFVJIHRoYXQgY2FuIGJlIHN0cmVhbWVkIHRvIHRoZSBjbGllbnQuXG4gKiBPbiB0aGUgY2xpZW50IHNpZGUsIGl0IGNhbiBiZSByZW5kZXJlZCBhcyBhIG5vcm1hbCBSZWFjdCBub2RlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1hYmxlVUkoaW5pdGlhbFZhbHVlPzogUmVhY3QuUmVhY3ROb2RlKSB7XG4gIGxldCBjdXJyZW50VmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gIGxldCBjbG9zZWQgPSBmYWxzZTtcbiAgbGV0IHsgcm93LCByZXNvbHZlLCByZWplY3QgfSA9IGNyZWF0ZVN1c3BlbmRlZENodW5rKGluaXRpYWxWYWx1ZSk7XG5cbiAgZnVuY3Rpb24gYXNzZXJ0U3RyZWFtKG1ldGhvZDogc3RyaW5nKSB7XG4gICAgaWYgKGNsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1ldGhvZCArICc6IFVJIHN0cmVhbSBpcyBhbHJlYWR5IGNsb3NlZC4nKTtcbiAgICB9XG4gIH1cblxuICBsZXQgd2FybmluZ1RpbWVvdXQ6IE5vZGVKUy5UaW1lb3V0IHwgdW5kZWZpbmVkO1xuICBmdW5jdGlvbiB3YXJuVW5jbG9zZWRTdHJlYW0oKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBpZiAod2FybmluZ1RpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHdhcm5pbmdUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIHdhcm5pbmdUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAnVGhlIHN0cmVhbWFibGUgVUkgaGFzIGJlZW4gc2xvdyB0byB1cGRhdGUuIFRoaXMgbWF5IGJlIGEgYnVnIG9yIGEgcGVyZm9ybWFuY2UgaXNzdWUgb3IgeW91IGZvcmdvdCB0byBjYWxsIGAuZG9uZSgpYC4nLFxuICAgICAgICApO1xuICAgICAgfSwgSEFOR0lOR19TVFJFQU1fV0FSTklOR19USU1FX01TKTtcbiAgICB9XG4gIH1cbiAgd2FyblVuY2xvc2VkU3RyZWFtKCk7XG5cbiAgY29uc3Qgc3RyZWFtYWJsZTogU3RyZWFtYWJsZVVJV3JhcHBlciA9IHtcbiAgICB2YWx1ZTogcm93LFxuICAgIHVwZGF0ZSh2YWx1ZTogUmVhY3QuUmVhY3ROb2RlKSB7XG4gICAgICBhc3NlcnRTdHJlYW0oJy51cGRhdGUoKScpO1xuXG4gICAgICAvLyBUaGVyZSBpcyBubyBuZWVkIHRvIHVwZGF0ZSB0aGUgdmFsdWUgaWYgaXQncyByZWZlcmVudGlhbGx5IGVxdWFsLlxuICAgICAgaWYgKHZhbHVlID09PSBjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgd2FyblVuY2xvc2VkU3RyZWFtKCk7XG4gICAgICAgIHJldHVybiBzdHJlYW1hYmxlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNvbHZhYmxlID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuXG4gICAgICByZXNvbHZlKHsgdmFsdWU6IGN1cnJlbnRWYWx1ZSwgZG9uZTogZmFsc2UsIG5leHQ6IHJlc29sdmFibGUucHJvbWlzZSB9KTtcbiAgICAgIHJlc29sdmUgPSByZXNvbHZhYmxlLnJlc29sdmU7XG4gICAgICByZWplY3QgPSByZXNvbHZhYmxlLnJlamVjdDtcblxuICAgICAgd2FyblVuY2xvc2VkU3RyZWFtKCk7XG5cbiAgICAgIHJldHVybiBzdHJlYW1hYmxlO1xuICAgIH0sXG4gICAgYXBwZW5kKHZhbHVlOiBSZWFjdC5SZWFjdE5vZGUpIHtcbiAgICAgIGFzc2VydFN0cmVhbSgnLmFwcGVuZCgpJyk7XG5cbiAgICAgIGNvbnN0IHJlc29sdmFibGUgPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgICAgY3VycmVudFZhbHVlID0gdmFsdWU7XG5cbiAgICAgIHJlc29sdmUoeyB2YWx1ZSwgZG9uZTogZmFsc2UsIGFwcGVuZDogdHJ1ZSwgbmV4dDogcmVzb2x2YWJsZS5wcm9taXNlIH0pO1xuICAgICAgcmVzb2x2ZSA9IHJlc29sdmFibGUucmVzb2x2ZTtcbiAgICAgIHJlamVjdCA9IHJlc29sdmFibGUucmVqZWN0O1xuXG4gICAgICB3YXJuVW5jbG9zZWRTdHJlYW0oKTtcblxuICAgICAgcmV0dXJuIHN0cmVhbWFibGU7XG4gICAgfSxcbiAgICBlcnJvcihlcnJvcjogYW55KSB7XG4gICAgICBhc3NlcnRTdHJlYW0oJy5lcnJvcigpJyk7XG5cbiAgICAgIGlmICh3YXJuaW5nVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQod2FybmluZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgIHJlamVjdChlcnJvcik7XG5cbiAgICAgIHJldHVybiBzdHJlYW1hYmxlO1xuICAgIH0sXG4gICAgZG9uZSguLi5hcmdzOiBbXSB8IFtSZWFjdC5SZWFjdE5vZGVdKSB7XG4gICAgICBhc3NlcnRTdHJlYW0oJy5kb25lKCknKTtcblxuICAgICAgaWYgKHdhcm5pbmdUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh3YXJuaW5nVGltZW91dCk7XG4gICAgICB9XG4gICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIHJlc29sdmUoeyB2YWx1ZTogYXJnc1swXSwgZG9uZTogdHJ1ZSB9KTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbWFibGU7XG4gICAgICB9XG4gICAgICByZXNvbHZlKHsgdmFsdWU6IGN1cnJlbnRWYWx1ZSwgZG9uZTogdHJ1ZSB9KTtcblxuICAgICAgcmV0dXJuIHN0cmVhbWFibGU7XG4gICAgfSxcbiAgfTtcblxuICByZXR1cm4gc3RyZWFtYWJsZTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlU3RyZWFtYWJsZVVJIH07XG4iLCJpbXBvcnQgdHlwZSBPcGVuQUkgZnJvbSAnb3BlbmFpJztcbmltcG9ydCB0eXBlIHsgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgeiB9IGZyb20gJ3pvZCc7XG5pbXBvcnQgem9kVG9Kc29uU2NoZW1hIGZyb20gJ3pvZC10by1qc29uLXNjaGVtYSc7XG5pbXBvcnQgeyBPcGVuQUlTdHJlYW0gfSBmcm9tICcuLi8uLi9zdHJlYW1zJztcbmltcG9ydCB7IGNvbnN1bWVTdHJlYW0gfSBmcm9tICcuLi8uLi91dGlsL2NvbnN1bWUtc3RyZWFtJztcbmltcG9ydCB7IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlIH0gZnJvbSAnLi4vLi4vdXRpbC9jcmVhdGUtcmVzb2x2YWJsZS1wcm9taXNlJztcbmltcG9ydCB7IGNyZWF0ZVN0cmVhbWFibGVVSSB9IGZyb20gJy4uL3N0cmVhbWFibGUtdWkvY3JlYXRlLXN0cmVhbWFibGUtdWknO1xuXG50eXBlIFN0cmVhbWFibGUgPSBSZWFjdE5vZGUgfCBQcm9taXNlPFJlYWN0Tm9kZT47XG50eXBlIFJlbmRlcmVyPFQ+ID0gKFxuICBwcm9wczogVCxcbikgPT5cbiAgfCBTdHJlYW1hYmxlXG4gIHwgR2VuZXJhdG9yPFN0cmVhbWFibGUsIFN0cmVhbWFibGUsIHZvaWQ+XG4gIHwgQXN5bmNHZW5lcmF0b3I8U3RyZWFtYWJsZSwgU3RyZWFtYWJsZSwgdm9pZD47XG5cbi8qKlxuICogYHJlbmRlcmAgaXMgYSBoZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGEgc3RyZWFtYWJsZSBVSSBmcm9tIHNvbWUgTExNcy5cbiAqIFRoaXMgQVBJIG9ubHkgc3VwcG9ydHMgT3BlbkFJJ3MgR1BUIG1vZGVscyB3aXRoIEZ1bmN0aW9uIENhbGxpbmcgYW5kIEFzc2lzdGFudHMgVG9vbHMsXG4gKiBwbGVhc2UgdXNlIGBzdHJlYW1VSWAgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBvdGhlciBwcm92aWRlcnMuXG4gKlxuICogQGRlcHJlY2F0ZWQgSXQncyByZWNvbW1lbmRlZCB0byB1c2UgdGhlIGBzdHJlYW1VSWAgQVBJIGZvciBjb21wYXRpYmlsaXR5IHdpdGggQUkgU0RLIENvcmUgQVBJc1xuICogYW5kIGZ1dHVyZSBmZWF0dXJlcy4gVGhpcyBBUEkgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXI8XG4gIFRTIGV4dGVuZHMge1xuICAgIFtuYW1lOiBzdHJpbmddOiB6LlNjaGVtYTtcbiAgfSA9IHt9LFxuICBGUyBleHRlbmRzIHtcbiAgICBbbmFtZTogc3RyaW5nXTogei5TY2hlbWE7XG4gIH0gPSB7fSxcbj4ob3B0aW9uczoge1xuICAvKipcbiAgICogVGhlIG1vZGVsIG5hbWUgdG8gdXNlLiBNdXN0IGJlIE9wZW5BSSBTREsgY29tcGF0aWJsZS4gVG9vbHMgYW5kIEZ1bmN0aW9ucyBhcmUgb25seSBzdXBwb3J0ZWRcbiAgICogR1BUIG1vZGVscyAoMy41LzQpLCBPcGVuQUkgQXNzaXN0YW50cywgTWlzdHJhbCBzbWFsbCBhbmQgbGFyZ2UsIGFuZCBGaXJld29ya3MgZmlyZWZ1bmN0aW9uLXYxLlxuICAgKlxuICAgKiBAZXhhbXBsZSBcImdwdC0zLjUtdHVyYm9cIlxuICAgKi9cbiAgbW9kZWw6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBwcm92aWRlciBpbnN0YW5jZSB0byB1c2UuIEN1cnJlbnRseSB0aGUgb25seSBwcm92aWRlciBhdmFpbGFibGUgaXMgT3BlbkFJLlxuICAgKiBUaGlzIG5lZWRzIHRvIG1hdGNoIHRoZSBtb2RlbCBuYW1lLlxuICAgKi9cbiAgcHJvdmlkZXI6IE9wZW5BSTtcbiAgbWVzc2FnZXM6IFBhcmFtZXRlcnM8XG4gICAgdHlwZW9mIE9wZW5BSS5wcm90b3R5cGUuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGVcbiAgPlswXVsnbWVzc2FnZXMnXTtcbiAgdGV4dD86IFJlbmRlcmVyPHtcbiAgICAvKipcbiAgICAgKiBUaGUgZnVsbCB0ZXh0IGNvbnRlbnQgZnJvbSB0aGUgbW9kZWwgc28gZmFyLlxuICAgICAqL1xuICAgIGNvbnRlbnQ6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgbmV3IGFwcGVuZGVkIHRleHQgY29udGVudCBmcm9tIHRoZSBtb2RlbCBzaW5jZSB0aGUgbGFzdCBgdGV4dGAgY2FsbC5cbiAgICAgKi9cbiAgICBkZWx0YTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIG1vZGVsIGlzIGRvbmUgZ2VuZXJhdGluZyB0ZXh0LlxuICAgICAqIElmIGB0cnVlYCwgdGhlIGBjb250ZW50YCB3aWxsIGJlIHRoZSBmaW5hbCBvdXRwdXQgYW5kIHRoaXMgY2FsbCB3aWxsIGJlIHRoZSBsYXN0LlxuICAgICAqL1xuICAgIGRvbmU6IGJvb2xlYW47XG4gIH0+O1xuICB0b29scz86IHtcbiAgICBbbmFtZSBpbiBrZXlvZiBUU106IHtcbiAgICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICAgICAgcGFyYW1ldGVyczogVFNbbmFtZV07XG4gICAgICByZW5kZXI6IFJlbmRlcmVyPHouaW5mZXI8VFNbbmFtZV0+PjtcbiAgICB9O1xuICB9O1xuICBmdW5jdGlvbnM/OiB7XG4gICAgW25hbWUgaW4ga2V5b2YgRlNdOiB7XG4gICAgICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgICAgIHBhcmFtZXRlcnM6IEZTW25hbWVdO1xuICAgICAgcmVuZGVyOiBSZW5kZXJlcjx6LmluZmVyPEZTW25hbWVdPj47XG4gICAgfTtcbiAgfTtcbiAgaW5pdGlhbD86IFJlYWN0Tm9kZTtcbiAgdGVtcGVyYXR1cmU/OiBudW1iZXI7XG59KTogUmVhY3ROb2RlIHtcbiAgY29uc3QgdWkgPSBjcmVhdGVTdHJlYW1hYmxlVUkob3B0aW9ucy5pbml0aWFsKTtcblxuICAvLyBUaGUgZGVmYXVsdCB0ZXh0IHJlbmRlcmVyIGp1c3QgcmV0dXJucyB0aGUgY29udGVudCBhcyBzdHJpbmcuXG4gIGNvbnN0IHRleHQgPSBvcHRpb25zLnRleHRcbiAgICA/IG9wdGlvbnMudGV4dFxuICAgIDogKHsgY29udGVudCB9OiB7IGNvbnRlbnQ6IHN0cmluZyB9KSA9PiBjb250ZW50O1xuXG4gIGNvbnN0IGZ1bmN0aW9ucyA9IG9wdGlvbnMuZnVuY3Rpb25zXG4gICAgPyBPYmplY3QuZW50cmllcyhvcHRpb25zLmZ1bmN0aW9ucykubWFwKFxuICAgICAgICAoW25hbWUsIHsgZGVzY3JpcHRpb24sIHBhcmFtZXRlcnMgfV0pID0+IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogem9kVG9Kc29uU2NoZW1hKHBhcmFtZXRlcnMpIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICApXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgY29uc3QgdG9vbHMgPSBvcHRpb25zLnRvb2xzXG4gICAgPyBPYmplY3QuZW50cmllcyhvcHRpb25zLnRvb2xzKS5tYXAoXG4gICAgICAgIChbbmFtZSwgeyBkZXNjcmlwdGlvbiwgcGFyYW1ldGVycyB9XSkgPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nIGFzIGNvbnN0LFxuICAgICAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHpvZFRvSnNvblNjaGVtYShwYXJhbWV0ZXJzKSBhcyBSZWNvcmQ8XG4gICAgICAgICAgICAgICAgc3RyaW5nLFxuICAgICAgICAgICAgICAgIHVua25vd25cbiAgICAgICAgICAgICAgPixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgIClcbiAgICA6IHVuZGVmaW5lZDtcblxuICBpZiAoZnVuY3Rpb25zICYmIHRvb2xzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJZb3UgY2FuJ3QgaGF2ZSBib3RoIGZ1bmN0aW9ucyBhbmQgdG9vbHMgZGVmaW5lZC4gUGxlYXNlIGNob29zZSBvbmUgb3IgdGhlIG90aGVyLlwiLFxuICAgICk7XG4gIH1cblxuICBsZXQgZmluaXNoZWQ6IFByb21pc2U8dm9pZD4gfCB1bmRlZmluZWQ7XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlUmVuZGVyKFxuICAgIGFyZ3M6IGFueSxcbiAgICByZW5kZXJlcjogdW5kZWZpbmVkIHwgUmVuZGVyZXI8YW55PixcbiAgICByZXM6IFJldHVyblR5cGU8dHlwZW9mIGNyZWF0ZVN0cmVhbWFibGVVST4sXG4gICkge1xuICAgIGlmICghcmVuZGVyZXIpIHJldHVybjtcblxuICAgIGNvbnN0IHJlc29sdmFibGUgPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZTx2b2lkPigpO1xuXG4gICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICBmaW5pc2hlZCA9IGZpbmlzaGVkLnRoZW4oKCkgPT4gcmVzb2x2YWJsZS5wcm9taXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmluaXNoZWQgPSByZXNvbHZhYmxlLnByb21pc2U7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWUgPSByZW5kZXJlcihhcmdzKTtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UgfHxcbiAgICAgICh2YWx1ZSAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICd0aGVuJyBpbiB2YWx1ZSAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJylcbiAgICApIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBhd2FpdCAodmFsdWUgYXMgUHJvbWlzZTxSZWFjdC5SZWFjdE5vZGU+KTtcbiAgICAgIHJlcy51cGRhdGUobm9kZSk7XG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUodm9pZCAwKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdmFsdWUgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgIFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIHZhbHVlXG4gICAgKSB7XG4gICAgICBjb25zdCBpdCA9IHZhbHVlIGFzIEFzeW5jR2VuZXJhdG9yPFxuICAgICAgICBSZWFjdC5SZWFjdE5vZGUsXG4gICAgICAgIFJlYWN0LlJlYWN0Tm9kZSxcbiAgICAgICAgdm9pZFxuICAgICAgPjtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IGl0Lm5leHQoKTtcbiAgICAgICAgcmVzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgIGlmIChkb25lKSBicmVhaztcbiAgICAgIH1cbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh2b2lkIDApO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gdmFsdWUpIHtcbiAgICAgIGNvbnN0IGl0ID0gdmFsdWUgYXMgR2VuZXJhdG9yPFJlYWN0LlJlYWN0Tm9kZSwgUmVhY3QuUmVhY3ROb2RlLCB2b2lkPjtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGl0Lm5leHQoKTtcbiAgICAgICAgcmVzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgIGlmIChkb25lKSBicmVhaztcbiAgICAgIH1cbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh2b2lkIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMudXBkYXRlKHZhbHVlKTtcbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh2b2lkIDApO1xuICAgIH1cbiAgfVxuXG4gIChhc3luYyAoKSA9PiB7XG4gICAgbGV0IGhhc0Z1bmN0aW9uID0gZmFsc2U7XG4gICAgbGV0IGNvbnRlbnQgPSAnJztcblxuICAgIGNvbnN1bWVTdHJlYW0oXG4gICAgICBPcGVuQUlTdHJlYW0oXG4gICAgICAgIChhd2FpdCBvcHRpb25zLnByb3ZpZGVyLmNoYXQuY29tcGxldGlvbnMuY3JlYXRlKHtcbiAgICAgICAgICBtb2RlbDogb3B0aW9ucy5tb2RlbCxcbiAgICAgICAgICBtZXNzYWdlczogb3B0aW9ucy5tZXNzYWdlcyxcbiAgICAgICAgICB0ZW1wZXJhdHVyZTogb3B0aW9ucy50ZW1wZXJhdHVyZSxcbiAgICAgICAgICBzdHJlYW06IHRydWUsXG4gICAgICAgICAgLi4uKGZ1bmN0aW9uc1xuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25zLFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAuLi4odG9vbHNcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgfSkpIGFzIGFueSxcbiAgICAgICAge1xuICAgICAgICAgIC4uLihmdW5jdGlvbnNcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIGFzeW5jIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbChmdW5jdGlvbkNhbGxQYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICBoYXNGdW5jdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBoYW5kbGVSZW5kZXIoXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uQ2FsbFBheWxvYWQuYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmZ1bmN0aW9ucz8uW2Z1bmN0aW9uQ2FsbFBheWxvYWQubmFtZSBhcyBhbnldXG4gICAgICAgICAgICAgICAgICAgICAgPy5yZW5kZXIsXG4gICAgICAgICAgICAgICAgICAgIHVpLFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAuLi4odG9vbHNcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIGFzeW5jIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKHRvb2xDYWxsUGF5bG9hZDogYW55KSB7XG4gICAgICAgICAgICAgICAgICBoYXNGdW5jdGlvbiA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFdlIG1pZ2h0IG5lZWQgUHJvbWlzZS5hbGwgaGVyZT9cbiAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbCBvZiB0b29sQ2FsbFBheWxvYWQudG9vbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlUmVuZGVyKFxuICAgICAgICAgICAgICAgICAgICAgIHRvb2wuZnVuYy5hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy50b29scz8uW3Rvb2wuZnVuYy5uYW1lIGFzIGFueV0/LnJlbmRlcixcbiAgICAgICAgICAgICAgICAgICAgICB1aSxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICBvblRleHQoY2h1bmspIHtcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gY2h1bms7XG4gICAgICAgICAgICBoYW5kbGVSZW5kZXIoeyBjb250ZW50LCBkb25lOiBmYWxzZSwgZGVsdGE6IGNodW5rIH0sIHRleHQsIHVpKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFzeW5jIG9uRmluYWwoKSB7XG4gICAgICAgICAgICBpZiAoaGFzRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgYXdhaXQgZmluaXNoZWQ7XG4gICAgICAgICAgICAgIHVpLmRvbmUoKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoYW5kbGVSZW5kZXIoeyBjb250ZW50LCBkb25lOiB0cnVlIH0sIHRleHQsIHVpKTtcbiAgICAgICAgICAgIGF3YWl0IGZpbmlzaGVkO1xuICAgICAgICAgICAgdWkuZG9uZSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICApLFxuICAgICk7XG4gIH0pKCk7XG5cbiAgcmV0dXJuIHVpLnZhbHVlO1xufVxuIiwiaW1wb3J0IHtcbiAgY3JlYXRlUGFyc2VyLFxuICB0eXBlIEV2ZW50U291cmNlUGFyc2VyLFxuICB0eXBlIFBhcnNlZEV2ZW50LFxuICB0eXBlIFJlY29ubmVjdEludGVydmFsLFxufSBmcm9tICdldmVudHNvdXJjZS1wYXJzZXInO1xuaW1wb3J0IHsgT3BlbkFJU3RyZWFtQ2FsbGJhY2tzIH0gZnJvbSAnLi9vcGVuYWktc3RyZWFtJztcblxuZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbkNhbGxQYXlsb2FkIHtcbiAgbmFtZTogc3RyaW5nO1xuICBhcmd1bWVudHM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xufVxuZXhwb3J0IGludGVyZmFjZSBUb29sQ2FsbFBheWxvYWQge1xuICB0b29sczoge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgdHlwZTogJ2Z1bmN0aW9uJztcbiAgICBmdW5jOiB7XG4gICAgICBuYW1lOiBzdHJpbmc7XG4gICAgICBhcmd1bWVudHM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAgIH07XG4gIH1bXTtcbn1cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9wdGlvbnMgYW5kIGhlbHBlciBjYWxsYmFjayBtZXRob2RzIGZvciBBSVN0cmVhbSBzdHJlYW0gbGlmZWN5Y2xlIGV2ZW50cy5cbiAqIEBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBSVN0cmVhbUNhbGxiYWNrc0FuZE9wdGlvbnMge1xuICAvKiogYG9uU3RhcnRgOiBDYWxsZWQgb25jZSB3aGVuIHRoZSBzdHJlYW0gaXMgaW5pdGlhbGl6ZWQuICovXG4gIG9uU3RhcnQ/OiAoKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcbiAgLyoqIGBvbkNvbXBsZXRpb25gOiBDYWxsZWQgZm9yIGVhY2ggdG9rZW5pemVkIG1lc3NhZ2UuICovXG4gIG9uQ29tcGxldGlvbj86IChjb21wbGV0aW9uOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD4gfCB2b2lkO1xuICAvKiogYG9uRmluYWxgOiBDYWxsZWQgb25jZSB3aGVuIHRoZSBzdHJlYW0gaXMgY2xvc2VkIHdpdGggdGhlIGZpbmFsIGNvbXBsZXRpb24gbWVzc2FnZS4gKi9cbiAgb25GaW5hbD86IChjb21wbGV0aW9uOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD4gfCB2b2lkO1xuICAvKiogYG9uVG9rZW5gOiBDYWxsZWQgZm9yIGVhY2ggdG9rZW5pemVkIG1lc3NhZ2UuICovXG4gIG9uVG9rZW4/OiAodG9rZW46IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQ7XG4gIC8qKiBgb25UZXh0YDogQ2FsbGVkIGZvciBlYWNoIHRleHQgY2h1bmsuICovXG4gIG9uVGV4dD86ICh0ZXh0OiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD4gfCB2b2lkO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVGhpcyBmbGFnIGlzIG5vIGxvbmdlciB1c2VkIGFuZCBvbmx5IHJldGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICogWW91IGNhbiByZW1vdmUgaXQgZnJvbSB5b3VyIGNvZGUuXG4gICAqL1xuICBleHBlcmltZW50YWxfc3RyZWFtRGF0YT86IGJvb2xlYW47XG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgdGhlIEFJU3RyZWFtUGFyc2VyLlxuICogQGludGVyZmFjZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGV2ZW50IC0gVGhlIGV2ZW50ICh0eXBlKSBmcm9tIHRoZSBzZXJ2ZXIgc2lkZSBldmVudCBzdHJlYW0uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQUlTdHJlYW1QYXJzZXJPcHRpb25zIHtcbiAgZXZlbnQ/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogQ3VzdG9tIHBhcnNlciBmb3IgQUlTdHJlYW0gZGF0YS5cbiAqIEBpbnRlcmZhY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIC0gVGhlIGRhdGEgdG8gYmUgcGFyc2VkLlxuICogQHBhcmFtIHtBSVN0cmVhbVBhcnNlck9wdGlvbnN9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIHBhcnNlci5cbiAqIEByZXR1cm5zIHtzdHJpbmcgfCB2b2lkfSBUaGUgcGFyc2VkIGRhdGEgb3Igdm9pZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBSVN0cmVhbVBhcnNlciB7XG4gIChkYXRhOiBzdHJpbmcsIG9wdGlvbnM6IEFJU3RyZWFtUGFyc2VyT3B0aW9ucyk6XG4gICAgfCBzdHJpbmdcbiAgICB8IHZvaWRcbiAgICB8IHsgaXNUZXh0OiBmYWxzZTsgY29udGVudDogc3RyaW5nIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFRyYW5zZm9ybVN0cmVhbSB0aGF0IHBhcnNlcyBldmVudHMgZnJvbSBhbiBFdmVudFNvdXJjZSBzdHJlYW0gdXNpbmcgYSBjdXN0b20gcGFyc2VyLlxuICogQHBhcmFtIHtBSVN0cmVhbVBhcnNlcn0gY3VzdG9tUGFyc2VyIC0gRnVuY3Rpb24gdG8gaGFuZGxlIGV2ZW50IGRhdGEuXG4gKiBAcmV0dXJucyB7VHJhbnNmb3JtU3RyZWFtPFVpbnQ4QXJyYXksIHN0cmluZz59IFRyYW5zZm9ybVN0cmVhbSBwYXJzaW5nIGV2ZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUV2ZW50U3RyZWFtVHJhbnNmb3JtZXIoXG4gIGN1c3RvbVBhcnNlcj86IEFJU3RyZWFtUGFyc2VyLFxuKTogVHJhbnNmb3JtU3RyZWFtPFVpbnQ4QXJyYXksIHN0cmluZyB8IHsgaXNUZXh0OiBmYWxzZTsgY29udGVudDogc3RyaW5nIH0+IHtcbiAgY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgbGV0IGV2ZW50U291cmNlUGFyc2VyOiBFdmVudFNvdXJjZVBhcnNlcjtcblxuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgZXZlbnRTb3VyY2VQYXJzZXIgPSBjcmVhdGVQYXJzZXIoXG4gICAgICAgIChldmVudDogUGFyc2VkRXZlbnQgfCBSZWNvbm5lY3RJbnRlcnZhbCkgPT4ge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICgnZGF0YScgaW4gZXZlbnQgJiZcbiAgICAgICAgICAgICAgZXZlbnQudHlwZSA9PT0gJ2V2ZW50JyAmJlxuICAgICAgICAgICAgICBldmVudC5kYXRhID09PSAnW0RPTkVdJykgfHxcbiAgICAgICAgICAgIC8vIFJlcGxpY2F0ZSBkb2Vzbid0IHNlbmQgW0RPTkVdIGJ1dCBkb2VzIHNlbmQgYSAnZG9uZScgZXZlbnRcbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9yZXBsaWNhdGUuY29tL2RvY3Mvc3RyZWFtaW5nXG4gICAgICAgICAgICAoZXZlbnQgYXMgYW55KS5ldmVudCA9PT0gJ2RvbmUnXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgnZGF0YScgaW4gZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZE1lc3NhZ2UgPSBjdXN0b21QYXJzZXJcbiAgICAgICAgICAgICAgPyBjdXN0b21QYXJzZXIoZXZlbnQuZGF0YSwge1xuICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LmV2ZW50LFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIDogZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRNZXNzYWdlKSBjb250cm9sbGVyLmVucXVldWUocGFyc2VkTWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgdHJhbnNmb3JtKGNodW5rKSB7XG4gICAgICBldmVudFNvdXJjZVBhcnNlci5mZWVkKHRleHREZWNvZGVyLmRlY29kZShjaHVuaykpO1xuICAgIH0sXG4gIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB0cmFuc2Zvcm0gc3RyZWFtIHRoYXQgZW5jb2RlcyBpbnB1dCBtZXNzYWdlcyBhbmQgaW52b2tlcyBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbnMuXG4gKiBUaGUgdHJhbnNmb3JtIHN0cmVhbSB1c2VzIHRoZSBwcm92aWRlZCBjYWxsYmFja3MgdG8gZXhlY3V0ZSBjdXN0b20gbG9naWMgYXQgZGlmZmVyZW50IHN0YWdlcyBvZiB0aGUgc3RyZWFtJ3MgbGlmZWN5Y2xlLlxuICogLSBgb25TdGFydGA6IENhbGxlZCBvbmNlIHdoZW4gdGhlIHN0cmVhbSBpcyBpbml0aWFsaXplZC5cbiAqIC0gYG9uVG9rZW5gOiBDYWxsZWQgZm9yIGVhY2ggdG9rZW5pemVkIG1lc3NhZ2UuXG4gKiAtIGBvbkNvbXBsZXRpb25gOiBDYWxsZWQgZXZlcnkgdGltZSBhbiBBSVN0cmVhbSBjb21wbGV0aW9uIG1lc3NhZ2UgaXMgcmVjZWl2ZWQuIFRoaXMgY2FuIG9jY3VyIG11bHRpcGxlIHRpbWVzIHdoZW4gdXNpbmcgZS5nLiBPcGVuQUkgZnVuY3Rpb25zXG4gKiAtIGBvbkZpbmFsYDogQ2FsbGVkIG9uY2Ugd2hlbiB0aGUgc3RyZWFtIGlzIGNsb3NlZCB3aXRoIHRoZSBmaW5hbCBjb21wbGV0aW9uIG1lc3NhZ2UuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBwcm9jZXNzIGEgc3RyZWFtIG9mIG1lc3NhZ2VzIGFuZCBwZXJmb3JtIHNwZWNpZmljIGFjdGlvbnMgZHVyaW5nIHRoZSBzdHJlYW0ncyBsaWZlY3ljbGUuXG4gKlxuICogQHBhcmFtIHtBSVN0cmVhbUNhbGxiYWNrc0FuZE9wdGlvbnN9IFtjYWxsYmFja3NdIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAqIEByZXR1cm4ge1RyYW5zZm9ybVN0cmVhbTxzdHJpbmcsIFVpbnQ4QXJyYXk+fSBBIHRyYW5zZm9ybSBzdHJlYW0gdGhhdCBlbmNvZGVzIGlucHV0IG1lc3NhZ2VzIGFzIFVpbnQ4QXJyYXkgYW5kIGFsbG93cyB0aGUgZXhlY3V0aW9uIG9mIGN1c3RvbSBsb2dpYyB0aHJvdWdoIGNhbGxiYWNrcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgY2FsbGJhY2tzID0ge1xuICogICBvblN0YXJ0OiBhc3luYyAoKSA9PiBjb25zb2xlLmxvZygnU3RyZWFtIHN0YXJ0ZWQnKSxcbiAqICAgb25Ub2tlbjogYXN5bmMgKHRva2VuKSA9PiBjb25zb2xlLmxvZyhgVG9rZW46ICR7dG9rZW59YCksXG4gKiAgIG9uQ29tcGxldGlvbjogYXN5bmMgKGNvbXBsZXRpb24pID0+IGNvbnNvbGUubG9nKGBDb21wbGV0aW9uOiAke2NvbXBsZXRpb259YClcbiAqICAgb25GaW5hbDogYXN5bmMgKCkgPT4gZGF0YS5jbG9zZSgpXG4gKiB9O1xuICogY29uc3QgdHJhbnNmb3JtZXIgPSBjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpO1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoXG4gIGNiOiBBSVN0cmVhbUNhbGxiYWNrc0FuZE9wdGlvbnMgfCBPcGVuQUlTdHJlYW1DYWxsYmFja3MgfCB1bmRlZmluZWQsXG4pOiBUcmFuc2Zvcm1TdHJlYW08c3RyaW5nIHwgeyBpc1RleHQ6IGZhbHNlOyBjb250ZW50OiBzdHJpbmcgfSwgVWludDhBcnJheT4ge1xuICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBsZXQgYWdncmVnYXRlZFJlc3BvbnNlID0gJyc7XG4gIGNvbnN0IGNhbGxiYWNrcyA9IGNiIHx8IHt9O1xuXG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGlmIChjYWxsYmFja3Mub25TdGFydCkgYXdhaXQgY2FsbGJhY2tzLm9uU3RhcnQoKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgdHJhbnNmb3JtKG1lc3NhZ2UsIGNvbnRyb2xsZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgPyBtZXNzYWdlIDogbWVzc2FnZS5jb250ZW50O1xuXG4gICAgICBjb250cm9sbGVyLmVucXVldWUodGV4dEVuY29kZXIuZW5jb2RlKGNvbnRlbnQpKTtcblxuICAgICAgYWdncmVnYXRlZFJlc3BvbnNlICs9IGNvbnRlbnQ7XG5cbiAgICAgIGlmIChjYWxsYmFja3Mub25Ub2tlbikgYXdhaXQgY2FsbGJhY2tzLm9uVG9rZW4oY29udGVudCk7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uVGV4dCAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uVGV4dChtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXN5bmMgZmx1c2goKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBjb25zdCBpc09wZW5BSUNhbGxiYWNrcyA9IGlzT2ZUeXBlT3BlbkFJU3RyZWFtQ2FsbGJhY2tzKGNhbGxiYWNrcyk7XG4gICAgICAvLyBJZiBpdCdzIE9wZW5BSUNhbGxiYWNrcywgaXQgaGFzIGFuIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCB3aGljaCBtZWFucyB0aGF0IHRoZSBjcmVhdGVGdW5jdGlvbkNhbGxUcmFuc2Zvcm1lclxuICAgICAgLy8gd2lsbCBoYW5kbGUgY2FsbGluZyBvbkNvbXBsZXRlLlxuICAgICAgaWYgKGNhbGxiYWNrcy5vbkNvbXBsZXRpb24pIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uQ29tcGxldGlvbihhZ2dyZWdhdGVkUmVzcG9uc2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FsbGJhY2tzLm9uRmluYWwgJiYgIWlzT3BlbkFJQ2FsbGJhY2tzKSB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkZpbmFsKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICB9XG4gICAgfSxcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGlzT2ZUeXBlT3BlbkFJU3RyZWFtQ2FsbGJhY2tzKFxuICBjYWxsYmFja3M6IEFJU3RyZWFtQ2FsbGJhY2tzQW5kT3B0aW9ucyB8IE9wZW5BSVN0cmVhbUNhbGxiYWNrcyxcbik6IGNhbGxiYWNrcyBpcyBPcGVuQUlTdHJlYW1DYWxsYmFja3Mge1xuICByZXR1cm4gJ2V4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCcgaW4gY2FsbGJhY2tzO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgc3RhdGVmdWwgZnVuY3Rpb24gdGhhdCwgd2hlbiBpbnZva2VkLCB0cmltcyBsZWFkaW5nIHdoaXRlc3BhY2VcbiAqIGZyb20gdGhlIGlucHV0IHRleHQuIFRoZSB0cmltbWluZyBvbmx5IG9jY3VycyBvbiB0aGUgZmlyc3QgaW52b2NhdGlvbiwgZW5zdXJpbmcgdGhhdFxuICogc3Vic2VxdWVudCBjYWxscyBkbyBub3QgYWx0ZXIgdGhlIGlucHV0IHRleHQuIFRoaXMgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBpbiBzY2VuYXJpb3NcbiAqIHdoZXJlIGEgdGV4dCBzdHJlYW0gaXMgYmVpbmcgcHJvY2Vzc2VkIGFuZCBvbmx5IHRoZSBpbml0aWFsIHdoaXRlc3BhY2Ugc2hvdWxkIGJlIHJlbW92ZWQuXG4gKlxuICogQHJldHVybiB7ZnVuY3Rpb24oc3RyaW5nKTogc3RyaW5nfSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBzdHJpbmcgYXMgaW5wdXQgYW5kIHJldHVybnMgYSBzdHJpbmdcbiAqIHdpdGggbGVhZGluZyB3aGl0ZXNwYWNlIHJlbW92ZWQgaWYgaXQgaXMgdGhlIGZpcnN0IGludm9jYXRpb247IG90aGVyd2lzZSwgaXQgcmV0dXJucyB0aGUgaW5wdXQgdW5jaGFuZ2VkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCB0cmltU3RhcnQgPSB0cmltU3RhcnRPZlN0cmVhbUhlbHBlcigpO1xuICogY29uc3Qgb3V0cHV0MSA9IHRyaW1TdGFydChcIiAgIHRleHRcIik7IC8vIFwidGV4dFwiXG4gKiBjb25zdCBvdXRwdXQyID0gdHJpbVN0YXJ0KFwiICAgdGV4dFwiKTsgLy8gXCIgICB0ZXh0XCJcbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltU3RhcnRPZlN0cmVhbUhlbHBlcigpOiAodGV4dDogc3RyaW5nKSA9PiBzdHJpbmcge1xuICBsZXQgaXNTdHJlYW1TdGFydCA9IHRydWU7XG5cbiAgcmV0dXJuICh0ZXh0OiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgIGlmIChpc1N0cmVhbVN0YXJ0KSB7XG4gICAgICB0ZXh0ID0gdGV4dC50cmltU3RhcnQoKTtcbiAgICAgIGlmICh0ZXh0KSBpc1N0cmVhbVN0YXJ0ID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xuICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBSZWFkYWJsZVN0cmVhbSBjcmVhdGVkIGZyb20gdGhlIHJlc3BvbnNlLCBwYXJzZWQgYW5kIGhhbmRsZWQgd2l0aCBjdXN0b20gbG9naWMuXG4gKiBUaGUgc3RyZWFtIGdvZXMgdGhyb3VnaCB0d28gdHJhbnNmb3JtYXRpb24gc3RhZ2VzLCBmaXJzdCBwYXJzaW5nIHRoZSBldmVudHMgYW5kIHRoZW5cbiAqIGludm9raW5nIHRoZSBwcm92aWRlZCBjYWxsYmFja3MuXG4gKlxuICogRm9yIDJ4eCBIVFRQIHJlc3BvbnNlczpcbiAqIC0gVGhlIGZ1bmN0aW9uIGNvbnRpbnVlcyB3aXRoIHN0YW5kYXJkIHN0cmVhbSBwcm9jZXNzaW5nLlxuICpcbiAqIEZvciBub24tMnh4IEhUVFAgcmVzcG9uc2VzOlxuICogLSBJZiB0aGUgcmVzcG9uc2UgYm9keSBpcyBkZWZpbmVkLCBpdCBhc3luY2hyb25vdXNseSBleHRyYWN0cyBhbmQgZGVjb2RlcyB0aGUgcmVzcG9uc2UgYm9keS5cbiAqIC0gSXQgdGhlbiBjcmVhdGVzIGEgY3VzdG9tIFJlYWRhYmxlU3RyZWFtIHRvIHByb3BhZ2F0ZSBhIGRldGFpbGVkIGVycm9yIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIHtSZXNwb25zZX0gcmVzcG9uc2UgLSBUaGUgcmVzcG9uc2UuXG4gKiBAcGFyYW0ge0FJU3RyZWFtUGFyc2VyfSBjdXN0b21QYXJzZXIgLSBUaGUgY3VzdG9tIHBhcnNlciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QUlTdHJlYW1DYWxsYmFja3NBbmRPcHRpb25zfSBjYWxsYmFja3MgLSBUaGUgY2FsbGJhY2tzLlxuICogQHJldHVybiB7UmVhZGFibGVTdHJlYW19IFRoZSBBSVN0cmVhbS5cbiAqIEB0aHJvd3MgV2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgcmVzcG9uc2UgaXMgbm90IE9LLlxuICovXG5leHBvcnQgZnVuY3Rpb24gQUlTdHJlYW0oXG4gIHJlc3BvbnNlOiBSZXNwb25zZSxcbiAgY3VzdG9tUGFyc2VyPzogQUlTdHJlYW1QYXJzZXIsXG4gIGNhbGxiYWNrcz86IEFJU3RyZWFtQ2FsbGJhY2tzQW5kT3B0aW9ucyxcbik6IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+IHtcbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIGlmIChyZXNwb25zZS5ib2R5KSB7XG4gICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IobmV3IEVycm9yKGBSZXNwb25zZSBlcnJvcjogJHtlcnJvclRleHR9YCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IobmV3IEVycm9yKCdSZXNwb25zZSBlcnJvcjogTm8gcmVzcG9uc2UgYm9keScpKTtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHJlc3BvbnNlQm9keVN0cmVhbSA9IHJlc3BvbnNlLmJvZHkgfHwgY3JlYXRlRW1wdHlSZWFkYWJsZVN0cmVhbSgpO1xuXG4gIHJldHVybiByZXNwb25zZUJvZHlTdHJlYW1cbiAgICAucGlwZVRocm91Z2goY3JlYXRlRXZlbnRTdHJlYW1UcmFuc2Zvcm1lcihjdXN0b21QYXJzZXIpKVxuICAgIC5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKTtcbn1cblxuLy8gb3V0cHV0cyBsaW5lcyBsaWtlXG4vLyAwOiBjaHVua1xuLy8gMDogbW9yZSBjaHVua1xuLy8gMTogYSBmY3QgY2FsbFxuLy8gejogYWRkZWQgZGF0YSBmcm9tIERhdGFcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVtcHR5IFJlYWRhYmxlU3RyZWFtIHRoYXQgaW1tZWRpYXRlbHkgY2xvc2VzIHVwb24gY3JlYXRpb24uXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYXMgYSBmYWxsYmFjayBmb3IgY3JlYXRpbmcgYSBSZWFkYWJsZVN0cmVhbSB3aGVuIHRoZSByZXNwb25zZSBib2R5IGlzIG51bGwgb3IgdW5kZWZpbmVkLFxuICogZW5zdXJpbmcgdGhhdCB0aGUgc3Vic2VxdWVudCBwaXBlbGluZSBwcm9jZXNzaW5nIGRvZXNuJ3QgZmFpbCBkdWUgdG8gYSBsYWNrIG9mIGEgc3RyZWFtLlxuICpcbiAqIEByZXR1cm5zIHtSZWFkYWJsZVN0cmVhbX0gQW4gZW1wdHkgYW5kIGNsb3NlZCBSZWFkYWJsZVN0cmVhbSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRW1wdHlSZWFkYWJsZVN0cmVhbSgpOiBSZWFkYWJsZVN0cmVhbSB7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB9LFxuICB9KTtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIFJlYWRhYmxlU3RyZWFtLmZyb20oYXN5bmNJdGVyYWJsZSksIHdoaWNoIGlzbid0IGRvY3VtZW50ZWQgaW4gTUROIGFuZCBpc24ndCBpbXBsZW1lbnRlZCBpbiBub2RlLlxuICogaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9zdHJlYW1zL2NvbW1pdC84ZDdhMGJmMjZlYjJjYzIzZTg4NGRkYmFhYzdjMWRhNGI5MWNmMmJjXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlPFQ+KGl0ZXJhYmxlOiBBc3luY0l0ZXJhYmxlPFQ+KSB7XG4gIGxldCBpdCA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtPFQ+KHtcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IGl0Lm5leHQoKTtcbiAgICAgIGlmIChkb25lKSBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICBlbHNlIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgfSxcblxuICAgIGFzeW5jIGNhbmNlbChyZWFzb24pIHtcbiAgICAgIGF3YWl0IGl0LnJldHVybj8uKHJlYXNvbik7XG4gICAgfSxcbiAgfSk7XG59XG4iLCJpbXBvcnQgeyBKU09OVmFsdWUsIGZvcm1hdFN0cmVhbVBhcnQgfSBmcm9tICdAYWktc2RrL3VpLXV0aWxzJztcbmltcG9ydCB7IEhBTkdJTkdfU1RSRUFNX1dBUk5JTkdfVElNRV9NUyB9IGZyb20gJy4uL3V0aWwvY29uc3RhbnRzJztcblxuLyoqXG4gKiBBIHN0cmVhbSB3cmFwcGVyIHRvIHNlbmQgY3VzdG9tIEpTT04tZW5jb2RlZCBkYXRhIGJhY2sgdG8gdGhlIGNsaWVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmVhbURhdGEge1xuICBwcml2YXRlIGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcblxuICBwcml2YXRlIGNvbnRyb2xsZXI6IFJlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjxVaW50OEFycmF5PiB8IG51bGwgPSBudWxsO1xuICBwdWJsaWMgc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PjtcblxuICBwcml2YXRlIGlzQ2xvc2VkOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgd2FybmluZ1RpbWVvdXQ6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLnN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICBzdGFydDogYXN5bmMgY29udHJvbGxlciA9PiB7XG4gICAgICAgIHNlbGYuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG5cbiAgICAgICAgLy8gU2V0IGEgdGltZW91dCB0byBzaG93IGEgd2FybmluZyBpZiB0aGUgc3RyZWFtIGlzIG5vdCBjbG9zZWQgd2l0aGluIDMgc2Vjb25kc1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICBzZWxmLndhcm5pbmdUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICdUaGUgZGF0YSBzdHJlYW0gaXMgaGFuZ2luZy4gRGlkIHlvdSBmb3JnZXQgdG8gY2xvc2UgaXQgd2l0aCBgZGF0YS5jbG9zZSgpYD8nLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9LCBIQU5HSU5HX1NUUkVBTV9XQVJOSU5HX1RJTUVfTVMpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHVsbDogY29udHJvbGxlciA9PiB7XG4gICAgICAgIC8vIE5vLW9wOiB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nIHNwZWNpYWwgb24gcHVsbFxuICAgICAgfSxcbiAgICAgIGNhbmNlbDogcmVhc29uID0+IHtcbiAgICAgICAgdGhpcy5pc0Nsb3NlZCA9IHRydWU7XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgY2xvc2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBTdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmNvbnRyb2xsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3RyZWFtIGNvbnRyb2xsZXIgaXMgbm90IGluaXRpYWxpemVkLicpO1xuICAgIH1cblxuICAgIHRoaXMuY29udHJvbGxlci5jbG9zZSgpO1xuICAgIHRoaXMuaXNDbG9zZWQgPSB0cnVlO1xuXG4gICAgLy8gQ2xlYXIgdGhlIHdhcm5pbmcgdGltZW91dCBpZiB0aGUgc3RyZWFtIGlzIGNsb3NlZFxuICAgIGlmICh0aGlzLndhcm5pbmdUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy53YXJuaW5nVGltZW91dCk7XG4gICAgfVxuICB9XG5cbiAgYXBwZW5kKHZhbHVlOiBKU09OVmFsdWUpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIFN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC4nKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuY29udHJvbGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHJlYW0gY29udHJvbGxlciBpcyBub3QgaW5pdGlhbGl6ZWQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5jb250cm9sbGVyLmVucXVldWUoXG4gICAgICB0aGlzLmVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQoJ2RhdGEnLCBbdmFsdWVdKSksXG4gICAgKTtcbiAgfVxuXG4gIGFwcGVuZE1lc3NhZ2VBbm5vdGF0aW9uKHZhbHVlOiBKU09OVmFsdWUpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIFN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC4nKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuY29udHJvbGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHJlYW0gY29udHJvbGxlciBpcyBub3QgaW5pdGlhbGl6ZWQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5jb250cm9sbGVyLmVucXVldWUoXG4gICAgICB0aGlzLmVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQoJ21lc3NhZ2VfYW5ub3RhdGlvbnMnLCBbdmFsdWVdKSksXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEEgVHJhbnNmb3JtU3RyZWFtIGZvciBMTE1zIHRoYXQgZG8gbm90IGhhdmUgdGhlaXIgb3duIHRyYW5zZm9ybSBzdHJlYW0gaGFuZGxlcnMgbWFuYWdpbmcgZW5jb2RpbmcgKGUuZy4gT3BlbkFJU3RyZWFtIGhhcyBvbmUgZm9yIGZ1bmN0aW9uIGNhbGwgaGFuZGxpbmcpLlxuICogVGhpcyBhc3N1bWVzIGV2ZXJ5IGNodW5rIGlzIGEgJ3RleHQnIGNodW5rLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkge1xuICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIHRyYW5zZm9ybTogYXN5bmMgKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZGVjb2Rlci5kZWNvZGUoY2h1bmspO1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQoJ3RleHQnLCBtZXNzYWdlKSkpO1xuICAgIH0sXG4gIH0pO1xufVxuXG4vKipcbkBkZXByZWNhdGVkIFVzZSBgU3RyZWFtRGF0YWAgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGNsYXNzIGV4cGVyaW1lbnRhbF9TdHJlYW1EYXRhIGV4dGVuZHMgU3RyZWFtRGF0YSB7fVxuIiwiaW1wb3J0IHtcbiAgQ3JlYXRlTWVzc2FnZSxcbiAgRnVuY3Rpb25DYWxsLFxuICBKU09OVmFsdWUsXG4gIFRvb2xDYWxsLFxuICBjcmVhdGVDaHVua0RlY29kZXIsXG4gIGZvcm1hdFN0cmVhbVBhcnQsXG59IGZyb20gJ0BhaS1zZGsvdWktdXRpbHMnO1xuaW1wb3J0IHtcbiAgQUlTdHJlYW0sXG4gIEZ1bmN0aW9uQ2FsbFBheWxvYWQsXG4gIFRvb2xDYWxsUGF5bG9hZCxcbiAgY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIsXG4gIHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUsXG4gIHRyaW1TdGFydE9mU3RyZWFtSGVscGVyLFxuICB0eXBlIEFJU3RyZWFtQ2FsbGJhY2tzQW5kT3B0aW9ucyxcbn0gZnJvbSAnLi9haS1zdHJlYW0nO1xuaW1wb3J0IHsgQXp1cmVDaGF0Q29tcGxldGlvbnMgfSBmcm9tICcuL2F6dXJlLW9wZW5haS10eXBlcyc7XG5pbXBvcnQgeyBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIgfSBmcm9tICcuL3N0cmVhbS1kYXRhJztcblxuZXhwb3J0IHR5cGUgT3BlbkFJU3RyZWFtQ2FsbGJhY2tzID0gQUlTdHJlYW1DYWxsYmFja3NBbmRPcHRpb25zICYge1xuICAvKipcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBvcGVuYWkuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoe1xuICAgKiAgIG1vZGVsOiAnZ3B0LTMuNS10dXJiby0wNjEzJyxcbiAgICogICBzdHJlYW06IHRydWUsXG4gICAqICAgbWVzc2FnZXMsXG4gICAqICAgZnVuY3Rpb25zLFxuICAgKiB9KVxuICAgKlxuICAgKiBjb25zdCBzdHJlYW0gPSBPcGVuQUlTdHJlYW0ocmVzcG9uc2UsIHtcbiAgICogICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGw6IGFzeW5jIChmdW5jdGlvbkNhbGxQYXlsb2FkLCBjcmVhdGVGdW5jdGlvbkNhbGxNZXNzYWdlcykgPT4ge1xuICAgKiAgICAgLy8gLi4uIHJ1biB5b3VyIGN1c3RvbSBsb2dpYyBoZXJlXG4gICAqICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBteUZ1bmN0aW9uKGZ1bmN0aW9uQ2FsbFBheWxvYWQpXG4gICAqXG4gICAqICAgICAvLyBBc2sgZm9yIGFub3RoZXIgY29tcGxldGlvbiwgb3IgcmV0dXJuIGEgc3RyaW5nIHRvIHNlbmQgdG8gdGhlIGNsaWVudCBhcyBhbiBhc3Npc3RhbnQgbWVzc2FnZS5cbiAgICogICAgIHJldHVybiBhd2FpdCBvcGVuYWkuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoe1xuICAgKiAgICAgICBtb2RlbDogJ2dwdC0zLjUtdHVyYm8tMDYxMycsXG4gICAqICAgICAgIHN0cmVhbTogdHJ1ZSxcbiAgICogICAgICAgLy8gQXBwZW5kIHRoZSByZWxldmFudCBcImFzc2lzdGFudFwiIGFuZCBcImZ1bmN0aW9uXCIgY2FsbCBtZXNzYWdlc1xuICAgKiAgICAgICBtZXNzYWdlczogWy4uLm1lc3NhZ2VzLCAuLi5jcmVhdGVGdW5jdGlvbkNhbGxNZXNzYWdlcyhyZXN1bHQpXSxcbiAgICogICAgICAgZnVuY3Rpb25zLFxuICAgKiAgICAgfSlcbiAgICogICB9XG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsPzogKFxuICAgIGZ1bmN0aW9uQ2FsbFBheWxvYWQ6IEZ1bmN0aW9uQ2FsbFBheWxvYWQsXG4gICAgY3JlYXRlRnVuY3Rpb25DYWxsTWVzc2FnZXM6IChcbiAgICAgIGZ1bmN0aW9uQ2FsbFJlc3VsdDogSlNPTlZhbHVlLFxuICAgICkgPT4gQ3JlYXRlTWVzc2FnZVtdLFxuICApID0+IFByb21pc2U8XG4gICAgUmVzcG9uc2UgfCB1bmRlZmluZWQgfCB2b2lkIHwgc3RyaW5nIHwgQXN5bmNJdGVyYWJsZU9wZW5BSVN0cmVhbVJldHVyblR5cGVzXG4gID47XG4gIC8qKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAqICAgbW9kZWw6ICdncHQtMy41LXR1cmJvLTExMDYnLCAvLyBvciBncHQtNC0xMTA2LXByZXZpZXdcbiAgICogICBzdHJlYW06IHRydWUsXG4gICAqICAgbWVzc2FnZXMsXG4gICAqICAgdG9vbHMsXG4gICAqICAgdG9vbF9jaG9pY2U6IFwiYXV0b1wiLCAvLyBhdXRvIGlzIGRlZmF1bHQsIGJ1dCB3ZSdsbCBiZSBleHBsaWNpdFxuICAgKiB9KVxuICAgKlxuICAgKiBjb25zdCBzdHJlYW0gPSBPcGVuQUlTdHJlYW0ocmVzcG9uc2UsIHtcbiAgICogICBleHBlcmltZW50YWxfb25Ub29sQ2FsbDogYXN5bmMgKHRvb2xDYWxsUGF5bG9hZCwgYXBwZW5kVG9vbENhbGxNZXNzYWdlcykgPT4ge1xuICAgKiAgICBsZXQgbWVzc2FnZXM6IENyZWF0ZU1lc3NhZ2VbXSA9IFtdXG4gICAqICAgIC8vICAgVGhlcmUgbWlnaHQgYmUgbXVsdGlwbGUgdG9vbCBjYWxscywgc28gd2UgbmVlZCB0byBpdGVyYXRlIHRocm91Z2ggdGhlbVxuICAgKiAgICBmb3IgKGNvbnN0IHRvb2wgb2YgdG9vbENhbGxQYXlsb2FkLnRvb2xzKSB7XG4gICAqICAgICAvLyAuLi4gcnVuIHlvdXIgY3VzdG9tIGxvZ2ljIGhlcmVcbiAgICogICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG15RnVuY3Rpb24odG9vbC5mdW5jdGlvbilcbiAgICogICAgLy8gQXBwZW5kIHRoZSByZWxldmFudCBcImFzc2lzdGFudFwiIGFuZCBcInRvb2xcIiBjYWxsIG1lc3NhZ2VzXG4gICAqICAgICBhcHBlbmRUb29sQ2FsbE1lc3NhZ2Uoe3Rvb2xfY2FsbF9pZDp0b29sLmlkLCBmdW5jdGlvbl9uYW1lOnRvb2wuZnVuY3Rpb24ubmFtZSwgdG9vbF9jYWxsX3Jlc3VsdDpyZXN1bHR9KVxuICAgKiAgICB9XG4gICAqICAgICAvLyBBc2sgZm9yIGFub3RoZXIgY29tcGxldGlvbiwgb3IgcmV0dXJuIGEgc3RyaW5nIHRvIHNlbmQgdG8gdGhlIGNsaWVudCBhcyBhbiBhc3Npc3RhbnQgbWVzc2FnZS5cbiAgICogICAgIHJldHVybiBhd2FpdCBvcGVuYWkuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoe1xuICAgKiAgICAgICBtb2RlbDogJ2dwdC0zLjUtdHVyYm8tMTEwNicsIC8vIG9yIGdwdC00LTExMDYtcHJldmlld1xuICAgKiAgICAgICBzdHJlYW06IHRydWUsXG4gICAqICAgICAgIC8vIEFwcGVuZCB0aGUgcmVzdWx0cyBtZXNzYWdlcywgY2FsbGluZyBhcHBlbmRUb29sQ2FsbE1lc3NhZ2Ugd2l0aG91dFxuICAgKiAgICAgICAvLyBhbnkgYXJndW1lbnRzIHdpbGwganN1dCByZXR1cm4gdGhlIGFjY3VtdWxhdGVkIG1lc3NhZ2VzXG4gICAqICAgICAgIG1lc3NhZ2VzOiBbLi4ubWVzc2FnZXMsIC4uLmFwcGVuZFRvb2xDYWxsTWVzc2FnZSgpXSxcbiAgICogICAgICAgdG9vbHMsXG4gICAqICAgICAgICB0b29sX2Nob2ljZTogXCJhdXRvXCIsIC8vIGF1dG8gaXMgZGVmYXVsdCwgYnV0IHdlJ2xsIGJlIGV4cGxpY2l0XG4gICAqICAgICB9KVxuICAgKiAgIH1cbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBleHBlcmltZW50YWxfb25Ub29sQ2FsbD86IChcbiAgICB0b29sQ2FsbFBheWxvYWQ6IFRvb2xDYWxsUGF5bG9hZCxcbiAgICBhcHBlbmRUb29sQ2FsbE1lc3NhZ2U6IChyZXN1bHQ/OiB7XG4gICAgICB0b29sX2NhbGxfaWQ6IHN0cmluZztcbiAgICAgIGZ1bmN0aW9uX25hbWU6IHN0cmluZztcbiAgICAgIHRvb2xfY2FsbF9yZXN1bHQ6IEpTT05WYWx1ZTtcbiAgICB9KSA9PiBDcmVhdGVNZXNzYWdlW10sXG4gICkgPT4gUHJvbWlzZTxcbiAgICBSZXNwb25zZSB8IHVuZGVmaW5lZCB8IHZvaWQgfCBzdHJpbmcgfCBBc3luY0l0ZXJhYmxlT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXNcbiAgPjtcbn07XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvYmxvYi8wN2IzNTA0ZTFjNDBmZDkyOWY0YWFlMTY1MWI4M2FmYzE5ZTNiYWY4L3NyYy9yZXNvdXJjZXMvY2hhdC9jb21wbGV0aW9ucy50cyNMMjgtTDQwXG5pbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25DaHVuayB7XG4gIGlkOiBzdHJpbmc7XG4gIGNob2ljZXM6IEFycmF5PENoYXRDb21wbGV0aW9uQ2h1bmtDaG9pY2U+O1xuICBjcmVhdGVkOiBudW1iZXI7XG4gIG1vZGVsOiBzdHJpbmc7XG4gIG9iamVjdDogc3RyaW5nO1xufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1ub2RlL2Jsb2IvMDdiMzUwNGUxYzQwZmQ5MjlmNGFhZTE2NTFiODNhZmMxOWUzYmFmOC9zcmMvcmVzb3VyY2VzL2NoYXQvY29tcGxldGlvbnMudHMjTDQzLUw0OVxuLy8gVXBkYXRlZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9jb21taXQvZjEwYzc1N2Q4MzFkOTA0MDdiYTQ3YjQ2NTlkOWNkMzRiMWEzNWIxZFxuLy8gVXBkYXRlZCB0byBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1ub2RlL2NvbW1pdC84NGI0MzI4MDA4OWVhY2RmMThmMTcxNzIzNTkxODU2ODExYmVkZGNlXG5pbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25DaHVua0Nob2ljZSB7XG4gIGRlbHRhOiBDaG9pY2VEZWx0YTtcbiAgZmluaXNoX3JlYXNvbjpcbiAgICB8ICdzdG9wJ1xuICAgIHwgJ2xlbmd0aCdcbiAgICB8ICd0b29sX2NhbGxzJ1xuICAgIHwgJ2NvbnRlbnRfZmlsdGVyJ1xuICAgIHwgJ2Z1bmN0aW9uX2NhbGwnXG4gICAgfCBudWxsO1xuICBpbmRleDogbnVtYmVyO1xufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1ub2RlL2Jsb2IvMDdiMzUwNGUxYzQwZmQ5MjlmNGFhZTE2NTFiODNhZmMxOWUzYmFmOC9zcmMvcmVzb3VyY2VzL2NoYXQvY29tcGxldGlvbnMudHMjTDEyMy1MMTM5XG4vLyBVcGRhdGVkIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvY29tbWl0Lzg0YjQzMjgwMDg5ZWFjZGYxOGYxNzE3MjM1OTE4NTY4MTFiZWRkY2VcbmludGVyZmFjZSBDaG9pY2VEZWx0YSB7XG4gIC8qKlxuICAgKiBUaGUgY29udGVudHMgb2YgdGhlIGNodW5rIG1lc3NhZ2UuXG4gICAqL1xuICBjb250ZW50Pzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG5hbWUgYW5kIGFyZ3VtZW50cyBvZiBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCwgYXMgZ2VuZXJhdGVkIGJ5IHRoZVxuICAgKiBtb2RlbC5cbiAgICovXG4gIGZ1bmN0aW9uX2NhbGw/OiBGdW5jdGlvbkNhbGw7XG5cbiAgLyoqXG4gICAqIFRoZSByb2xlIG9mIHRoZSBhdXRob3Igb2YgdGhpcyBtZXNzYWdlLlxuICAgKi9cbiAgcm9sZT86ICdzeXN0ZW0nIHwgJ3VzZXInIHwgJ2Fzc2lzdGFudCcgfCAndG9vbCc7XG5cbiAgdG9vbF9jYWxscz86IEFycmF5PERlbHRhVG9vbENhbGw+O1xufVxuXG4vLyBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvYmxvYi9tYXN0ZXIvc3JjL3Jlc291cmNlcy9jaGF0L2NvbXBsZXRpb25zLnRzXG4vLyBVcGRhdGVkIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvY29tbWl0Lzg0YjQzMjgwMDg5ZWFjZGYxOGYxNzE3MjM1OTE4NTY4MTFiZWRkY2VcbmludGVyZmFjZSBEZWx0YVRvb2xDYWxsIHtcbiAgaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSB0b29sIGNhbGwuXG4gICAqL1xuICBpZD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGZ1bmN0aW9uIHRoYXQgdGhlIG1vZGVsIGNhbGxlZC5cbiAgICovXG4gIGZ1bmN0aW9uPzogVG9vbENhbGxGdW5jdGlvbjtcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdGhlIHRvb2wuIEN1cnJlbnRseSwgb25seSBgZnVuY3Rpb25gIGlzIHN1cHBvcnRlZC5cbiAgICovXG4gIHR5cGU/OiAnZnVuY3Rpb24nO1xufVxuXG4vLyBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvYmxvYi9tYXN0ZXIvc3JjL3Jlc291cmNlcy9jaGF0L2NvbXBsZXRpb25zLnRzXG4vLyBVcGRhdGVkIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvY29tbWl0Lzg0YjQzMjgwMDg5ZWFjZGYxOGYxNzE3MjM1OTE4NTY4MTFiZWRkY2VcbmludGVyZmFjZSBUb29sQ2FsbEZ1bmN0aW9uIHtcbiAgLyoqXG4gICAqIFRoZSBhcmd1bWVudHMgdG8gY2FsbCB0aGUgZnVuY3Rpb24gd2l0aCwgYXMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCBpbiBKU09OXG4gICAqIGZvcm1hdC4gTm90ZSB0aGF0IHRoZSBtb2RlbCBkb2VzIG5vdCBhbHdheXMgZ2VuZXJhdGUgdmFsaWQgSlNPTiwgYW5kIG1heVxuICAgKiBoYWxsdWNpbmF0ZSBwYXJhbWV0ZXJzIG5vdCBkZWZpbmVkIGJ5IHlvdXIgZnVuY3Rpb24gc2NoZW1hLiBWYWxpZGF0ZSB0aGVcbiAgICogYXJndW1lbnRzIGluIHlvdXIgY29kZSBiZWZvcmUgY2FsbGluZyB5b3VyIGZ1bmN0aW9uLlxuICAgKi9cbiAgYXJndW1lbnRzPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAgICovXG4gIG5hbWU/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9ibG9iLzNlYzQzZWU3OTBhMmViNmEwY2NkZDVmMjVmYWEyMzI1MWIwZjliOGUvc3JjL3Jlc291cmNlcy9jb21wbGV0aW9ucy50cyNMMjhDMS1MNjRDMVxuICogQ29tcGxldGlvbnMgQVBJLiBTdHJlYW1lZCBhbmQgbm9uLXN0cmVhbWVkIHJlc3BvbnNlcyBhcmUgdGhlIHNhbWUuXG4gKi9cbmludGVyZmFjZSBDb21wbGV0aW9uIHtcbiAgLyoqXG4gICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBjb21wbGV0aW9uLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2YgY29tcGxldGlvbiBjaG9pY2VzIHRoZSBtb2RlbCBnZW5lcmF0ZWQgZm9yIHRoZSBpbnB1dCBwcm9tcHQuXG4gICAqL1xuICBjaG9pY2VzOiBBcnJheTxDb21wbGV0aW9uQ2hvaWNlPjtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIG9mIHdoZW4gdGhlIGNvbXBsZXRpb24gd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVkOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBtb2RlbCB1c2VkIGZvciBjb21wbGV0aW9uLlxuICAgKi9cbiAgbW9kZWw6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgXCJ0ZXh0X2NvbXBsZXRpb25cIlxuICAgKi9cbiAgb2JqZWN0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFVzYWdlIHN0YXRpc3RpY3MgZm9yIHRoZSBjb21wbGV0aW9uIHJlcXVlc3QuXG4gICAqL1xuICB1c2FnZT86IENvbXBsZXRpb25Vc2FnZTtcbn1cblxuaW50ZXJmYWNlIENvbXBsZXRpb25DaG9pY2Uge1xuICAvKipcbiAgICogVGhlIHJlYXNvbiB0aGUgbW9kZWwgc3RvcHBlZCBnZW5lcmF0aW5nIHRva2Vucy4gVGhpcyB3aWxsIGJlIGBzdG9wYCBpZiB0aGUgbW9kZWxcbiAgICogaGl0IGEgbmF0dXJhbCBzdG9wIHBvaW50IG9yIGEgcHJvdmlkZWQgc3RvcCBzZXF1ZW5jZSwgb3IgYGxlbmd0aGAgaWYgdGhlIG1heGltdW1cbiAgICogbnVtYmVyIG9mIHRva2VucyBzcGVjaWZpZWQgaW4gdGhlIHJlcXVlc3Qgd2FzIHJlYWNoZWQuXG4gICAqL1xuICBmaW5pc2hfcmVhc29uOiAnc3RvcCcgfCAnbGVuZ3RoJyB8ICdjb250ZW50X2ZpbHRlcic7XG5cbiAgaW5kZXg6IG51bWJlcjtcblxuICAvLyBlZGl0ZWQ6IFJlbW92ZWQgQ29tcGxldGlvbkNob2ljZS5sb2dQcm9icyBhbmQgcmVwbGFjZWQgd2l0aCBhbnlcbiAgbG9ncHJvYnM6IGFueSB8IG51bGw7XG5cbiAgdGV4dDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBsZXRpb25Vc2FnZSB7XG4gIC8qKlxuICAgKiBVc2FnZSBzdGF0aXN0aWNzIGZvciB0aGUgY29tcGxldGlvbiByZXF1ZXN0LlxuICAgKi9cblxuICAvKipcbiAgICogTnVtYmVyIG9mIHRva2VucyBpbiB0aGUgZ2VuZXJhdGVkIGNvbXBsZXRpb24uXG4gICAqL1xuICBjb21wbGV0aW9uX3Rva2VuczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgdG9rZW5zIGluIHRoZSBwcm9tcHQuXG4gICAqL1xuICBwcm9tcHRfdG9rZW5zOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRvdGFsIG51bWJlciBvZiB0b2tlbnMgdXNlZCBpbiB0aGUgcmVxdWVzdCAocHJvbXB0ICsgY29tcGxldGlvbikuXG4gICAqL1xuICB0b3RhbF90b2tlbnM6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgcGFyc2VyIGZ1bmN0aW9uIGZvciBwcm9jZXNzaW5nIHRoZSBPcGVuQUkgc3RyZWFtIGRhdGEuXG4gKiBUaGUgcGFyc2VyIGV4dHJhY3RzIGFuZCB0cmltcyB0ZXh0IGNvbnRlbnQgZnJvbSB0aGUgSlNPTiBkYXRhLiBUaGlzIHBhcnNlclxuICogY2FuIGhhbmRsZSBkYXRhIGZvciBjaGF0IG9yIGNvbXBsZXRpb24gbW9kZWxzLlxuICpcbiAqIEByZXR1cm4geyhkYXRhOiBzdHJpbmcpID0+IHN0cmluZyB8IHZvaWR8IHsgaXNUZXh0OiBmYWxzZTsgY29udGVudDogc3RyaW5nIH19XG4gKiBBIHBhcnNlciBmdW5jdGlvbiB0aGF0IHRha2VzIGEgSlNPTiBzdHJpbmcgYXMgaW5wdXQgYW5kIHJldHVybnMgdGhlIGV4dHJhY3RlZCB0ZXh0IGNvbnRlbnQsXG4gKiBhIGNvbXBsZXggb2JqZWN0IHdpdGggaXNUZXh0OiBmYWxzZSBmb3IgZnVuY3Rpb24vdG9vbCBjYWxscywgb3Igbm90aGluZy5cbiAqL1xuZnVuY3Rpb24gcGFyc2VPcGVuQUlTdHJlYW0oKTogKFxuICBkYXRhOiBzdHJpbmcsXG4pID0+IHN0cmluZyB8IHZvaWQgfCB7IGlzVGV4dDogZmFsc2U7IGNvbnRlbnQ6IHN0cmluZyB9IHtcbiAgY29uc3QgZXh0cmFjdCA9IGNodW5rVG9UZXh0KCk7XG4gIHJldHVybiBkYXRhID0+IGV4dHJhY3QoSlNPTi5wYXJzZShkYXRhKSBhcyBPcGVuQUlTdHJlYW1SZXR1cm5UeXBlcyk7XG59XG5cbi8qKlxuICogUmVhZHMgY2h1bmtzIGZyb20gT3BlbkFJJ3MgbmV3IFN0cmVhbWFibGUgaW50ZXJmYWNlLCB3aGljaCBpcyBlc3NlbnRpYWxseVxuICogdGhlIHNhbWUgYXMgdGhlIG9sZCBSZXNwb25zZSBib2R5IGludGVyZmFjZSB3aXRoIGFuIGluY2x1ZGVkIFNTRSBwYXJzZXJcbiAqIGRvaW5nIHRoZSBwYXJzaW5nIGZvciB1cy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbWFibGUoc3RyZWFtOiBBc3luY0l0ZXJhYmxlT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXMpIHtcbiAgY29uc3QgZXh0cmFjdCA9IGNodW5rVG9UZXh0KCk7XG5cbiAgZm9yIGF3YWl0IChsZXQgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgLy8gY29udmVydCBjaHVuayBpZiBpdCBpcyBhbiBBenVyZSBjaGF0IGNvbXBsZXRpb24uIEF6dXJlIGRvZXMgbm90IGV4cG9zZSBhbGxcbiAgICAvLyBwcm9wZXJ0aWVzIGluIHRoZSBpbnRlcmZhY2VzLCBhbmQgYWxzbyB1c2VzIGNhbWVsQ2FzZSBpbnN0ZWFkIG9mIHNuYWtlX2Nhc2VcbiAgICBpZiAoJ3Byb21wdEZpbHRlclJlc3VsdHMnIGluIGNodW5rKSB7XG4gICAgICBjaHVuayA9IHtcbiAgICAgICAgaWQ6IGNodW5rLmlkLFxuICAgICAgICBjcmVhdGVkOiBjaHVuay5jcmVhdGVkLmdldERhdGUoKSxcbiAgICAgICAgb2JqZWN0OiAoY2h1bmsgYXMgYW55KS5vYmplY3QsIC8vIG5vdCBleHBvc2VkIGJ5IEF6dXJlIEFQSVxuICAgICAgICBtb2RlbDogKGNodW5rIGFzIGFueSkubW9kZWwsIC8vIG5vdCBleHBvc2VkIGJ5IEF6dXJlIEFQSVxuICAgICAgICBjaG9pY2VzOiBjaHVuay5jaG9pY2VzLm1hcChjaG9pY2UgPT4gKHtcbiAgICAgICAgICBkZWx0YToge1xuICAgICAgICAgICAgY29udGVudDogY2hvaWNlLmRlbHRhPy5jb250ZW50LFxuICAgICAgICAgICAgZnVuY3Rpb25fY2FsbDogY2hvaWNlLmRlbHRhPy5mdW5jdGlvbkNhbGwsXG4gICAgICAgICAgICByb2xlOiBjaG9pY2UuZGVsdGE/LnJvbGUgYXMgYW55LFxuICAgICAgICAgICAgdG9vbF9jYWxsczogY2hvaWNlLmRlbHRhPy50b29sQ2FsbHM/Lmxlbmd0aFxuICAgICAgICAgICAgICA/IGNob2ljZS5kZWx0YT8udG9vbENhbGxzPy5tYXAoKHRvb2xDYWxsLCBpbmRleCkgPT4gKHtcbiAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgaWQ6IHRvb2xDYWxsLmlkLFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb246IHRvb2xDYWxsLmZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgICAgdHlwZTogdG9vbENhbGwudHlwZSxcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBmaW5pc2hfcmVhc29uOiBjaG9pY2UuZmluaXNoUmVhc29uIGFzIGFueSxcbiAgICAgICAgICBpbmRleDogY2hvaWNlLmluZGV4LFxuICAgICAgICB9KSksXG4gICAgICB9IHNhdGlzZmllcyBDaGF0Q29tcGxldGlvbkNodW5rO1xuICAgIH1cblxuICAgIGNvbnN0IHRleHQgPSBleHRyYWN0KGNodW5rKTtcblxuICAgIGlmICh0ZXh0KSB5aWVsZCB0ZXh0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGNodW5rVG9UZXh0KCk6IChcbiAgY2h1bms6IE9wZW5BSVN0cmVhbVJldHVyblR5cGVzLFxuKSA9PiBzdHJpbmcgfCB7IGlzVGV4dDogZmFsc2U7IGNvbnRlbnQ6IHN0cmluZyB9IHwgdm9pZCB7XG4gIGNvbnN0IHRyaW1TdGFydE9mU3RyZWFtID0gdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIoKTtcbiAgbGV0IGlzRnVuY3Rpb25TdHJlYW1pbmdJbjogYm9vbGVhbjtcbiAgcmV0dXJuIGpzb24gPT4ge1xuICAgIGlmIChpc0NoYXRDb21wbGV0aW9uQ2h1bmsoanNvbikpIHtcbiAgICAgIGNvbnN0IGRlbHRhID0ganNvbi5jaG9pY2VzWzBdPy5kZWx0YTtcbiAgICAgIGlmIChkZWx0YS5mdW5jdGlvbl9jYWxsPy5uYW1lKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IHRydWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICBjb250ZW50OiBge1wiZnVuY3Rpb25fY2FsbFwiOiB7XCJuYW1lXCI6IFwiJHtkZWx0YS5mdW5jdGlvbl9jYWxsLm5hbWV9XCIsIFwiYXJndW1lbnRzXCI6IFwiYCxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoZGVsdGEudG9vbF9jYWxscz8uWzBdPy5mdW5jdGlvbj8ubmFtZSkge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSB0cnVlO1xuICAgICAgICBjb25zdCB0b29sQ2FsbCA9IGRlbHRhLnRvb2xfY2FsbHNbMF07XG4gICAgICAgIGlmICh0b29sQ2FsbC5pbmRleCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgICAgY29udGVudDogYHtcInRvb2xfY2FsbHNcIjpbIHtcImlkXCI6IFwiJHt0b29sQ2FsbC5pZH1cIiwgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwiJHt0b29sQ2FsbC5mdW5jdGlvbj8ubmFtZX1cIiwgXCJhcmd1bWVudHNcIjogXCJgLFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgICBjb250ZW50OiBgXCJ9fSwge1wiaWRcIjogXCIke3Rvb2xDYWxsLmlkfVwiLCBcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCIke3Rvb2xDYWxsLmZ1bmN0aW9uPy5uYW1lfVwiLCBcImFyZ3VtZW50c1wiOiBcImAsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkZWx0YS5mdW5jdGlvbl9jYWxsPy5hcmd1bWVudHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6IGNsZWFudXBBcmd1bWVudHMoZGVsdGEuZnVuY3Rpb25fY2FsbD8uYXJndW1lbnRzKSxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoZGVsdGEudG9vbF9jYWxscz8uWzBdPy5mdW5jdGlvbj8uYXJndW1lbnRzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICBjb250ZW50OiBjbGVhbnVwQXJndW1lbnRzKGRlbHRhLnRvb2xfY2FsbHM/LlswXT8uZnVuY3Rpb24/LmFyZ3VtZW50cyksXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gJiZcbiAgICAgICAgKGpzb24uY2hvaWNlc1swXT8uZmluaXNoX3JlYXNvbiA9PT0gJ2Z1bmN0aW9uX2NhbGwnIHx8XG4gICAgICAgICAganNvbi5jaG9pY2VzWzBdPy5maW5pc2hfcmVhc29uID09PSAnc3RvcCcpXG4gICAgICApIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gZmFsc2U7IC8vIFJlc2V0IHRoZSBmbGFnXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICBjb250ZW50OiAnXCJ9fScsXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gJiZcbiAgICAgICAganNvbi5jaG9pY2VzWzBdPy5maW5pc2hfcmVhc29uID09PSAndG9vbF9jYWxscydcbiAgICAgICkge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTsgLy8gUmVzZXQgdGhlIGZsYWdcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6ICdcIn19XX0nLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHRleHQgPSB0cmltU3RhcnRPZlN0cmVhbShcbiAgICAgIGlzQ2hhdENvbXBsZXRpb25DaHVuayhqc29uKSAmJiBqc29uLmNob2ljZXNbMF0uZGVsdGEuY29udGVudFxuICAgICAgICA/IGpzb24uY2hvaWNlc1swXS5kZWx0YS5jb250ZW50XG4gICAgICAgIDogaXNDb21wbGV0aW9uKGpzb24pXG4gICAgICAgID8ganNvbi5jaG9pY2VzWzBdLnRleHRcbiAgICAgICAgOiAnJyxcbiAgICApO1xuXG4gICAgcmV0dXJuIHRleHQ7XG4gIH07XG5cbiAgZnVuY3Rpb24gY2xlYW51cEFyZ3VtZW50cyhhcmd1bWVudENodW5rOiBzdHJpbmcpIHtcbiAgICBsZXQgZXNjYXBlZFBhcnRpYWxKc29uID0gYXJndW1lbnRDaHVua1xuICAgICAgLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykgLy8gUmVwbGFjZSBiYWNrc2xhc2hlcyBmaXJzdCB0byBwcmV2ZW50IGRvdWJsZSBlc2NhcGluZ1xuICAgICAgLnJlcGxhY2UoL1xcLy9nLCAnXFxcXC8nKSAvLyBFc2NhcGUgc2xhc2hlc1xuICAgICAgLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKSAvLyBFc2NhcGUgZG91YmxlIHF1b3Rlc1xuICAgICAgLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKSAvLyBFc2NhcGUgbmV3IGxpbmVzXG4gICAgICAucmVwbGFjZSgvXFxyL2csICdcXFxccicpIC8vIEVzY2FwZSBjYXJyaWFnZSByZXR1cm5zXG4gICAgICAucmVwbGFjZSgvXFx0L2csICdcXFxcdCcpIC8vIEVzY2FwZSB0YWJzXG4gICAgICAucmVwbGFjZSgvXFxmL2csICdcXFxcZicpOyAvLyBFc2NhcGUgZm9ybSBmZWVkc1xuXG4gICAgcmV0dXJuIGAke2VzY2FwZWRQYXJ0aWFsSnNvbn1gO1xuICB9XG59XG5cbmNvbnN0IF9faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2wgPSBTeW1ib2woXG4gICdpbnRlcm5hbF9vcGVuYWlfZm5fbWVzc2FnZXMnLFxuKTtcblxudHlwZSBBc3luY0l0ZXJhYmxlT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXMgPVxuICB8IEFzeW5jSXRlcmFibGU8Q2hhdENvbXBsZXRpb25DaHVuaz5cbiAgfCBBc3luY0l0ZXJhYmxlPENvbXBsZXRpb24+XG4gIHwgQXN5bmNJdGVyYWJsZTxBenVyZUNoYXRDb21wbGV0aW9ucz47XG5cbnR5cGUgRXh0cmFjdFR5cGU8VD4gPSBUIGV4dGVuZHMgQXN5bmNJdGVyYWJsZTxpbmZlciBVPiA/IFUgOiBuZXZlcjtcblxudHlwZSBPcGVuQUlTdHJlYW1SZXR1cm5UeXBlcyA9XG4gIEV4dHJhY3RUeXBlPEFzeW5jSXRlcmFibGVPcGVuQUlTdHJlYW1SZXR1cm5UeXBlcz47XG5cbmZ1bmN0aW9uIGlzQ2hhdENvbXBsZXRpb25DaHVuayhcbiAgZGF0YTogT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXMsXG4pOiBkYXRhIGlzIENoYXRDb21wbGV0aW9uQ2h1bmsge1xuICByZXR1cm4gKFxuICAgICdjaG9pY2VzJyBpbiBkYXRhICYmXG4gICAgZGF0YS5jaG9pY2VzICYmXG4gICAgZGF0YS5jaG9pY2VzWzBdICYmXG4gICAgJ2RlbHRhJyBpbiBkYXRhLmNob2ljZXNbMF1cbiAgKTtcbn1cblxuZnVuY3Rpb24gaXNDb21wbGV0aW9uKGRhdGE6IE9wZW5BSVN0cmVhbVJldHVyblR5cGVzKTogZGF0YSBpcyBDb21wbGV0aW9uIHtcbiAgcmV0dXJuIChcbiAgICAnY2hvaWNlcycgaW4gZGF0YSAmJlxuICAgIGRhdGEuY2hvaWNlcyAmJlxuICAgIGRhdGEuY2hvaWNlc1swXSAmJlxuICAgICd0ZXh0JyBpbiBkYXRhLmNob2ljZXNbMF1cbiAgKTtcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgdGhlIFtPcGVuQUkgcHJvdmlkZXJdKGh0dHBzOi8vc2RrLnZlcmNlbC5haS9wcm92aWRlcnMvYWktc2RrLXByb3ZpZGVycy9vcGVuYWkpIGluc3RlYWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBPcGVuQUlTdHJlYW0oXG4gIHJlczogUmVzcG9uc2UgfCBBc3luY0l0ZXJhYmxlT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXMsXG4gIGNhbGxiYWNrcz86IE9wZW5BSVN0cmVhbUNhbGxiYWNrcyxcbik6IFJlYWRhYmxlU3RyZWFtIHtcbiAgLy8gQW5ub3RhdGUgdGhlIGludGVybmFsIGBtZXNzYWdlc2AgcHJvcGVydHkgZm9yIHJlY3Vyc2l2ZSBmdW5jdGlvbiBjYWxsc1xuICBjb25zdCBjYjpcbiAgICB8IHVuZGVmaW5lZFxuICAgIHwgKE9wZW5BSVN0cmVhbUNhbGxiYWNrcyAmIHtcbiAgICAgICAgW19faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2xdPzogQ3JlYXRlTWVzc2FnZVtdO1xuICAgICAgfSkgPSBjYWxsYmFja3M7XG5cbiAgbGV0IHN0cmVhbTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT47XG4gIGlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiByZXMpIHtcbiAgICBzdHJlYW0gPSByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKHN0cmVhbWFibGUocmVzKSkucGlwZVRocm91Z2goXG4gICAgICBjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihcbiAgICAgICAgY2I/LmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCB8fCBjYj8uZXhwZXJpbWVudGFsX29uVG9vbENhbGxcbiAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgLi4uY2IsXG4gICAgICAgICAgICAgIG9uRmluYWw6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgLi4uY2IsXG4gICAgICAgICAgICB9LFxuICAgICAgKSxcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbSA9IEFJU3RyZWFtKFxuICAgICAgcmVzLFxuICAgICAgcGFyc2VPcGVuQUlTdHJlYW0oKSxcbiAgICAgIGNiPy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgfHwgY2I/LmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsXG4gICAgICAgID8ge1xuICAgICAgICAgICAgLi4uY2IsXG4gICAgICAgICAgICBvbkZpbmFsOiB1bmRlZmluZWQsXG4gICAgICAgICAgfVxuICAgICAgICA6IHtcbiAgICAgICAgICAgIC4uLmNiLFxuICAgICAgICAgIH0sXG4gICAgKTtcbiAgfVxuXG4gIGlmIChjYiAmJiAoY2IuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHx8IGNiLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSkge1xuICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyID0gY3JlYXRlRnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIoY2IpO1xuICAgIHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2goZnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyKFxuICBjYWxsYmFja3M6IE9wZW5BSVN0cmVhbUNhbGxiYWNrcyAmIHtcbiAgICBbX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbF0/OiBDcmVhdGVNZXNzYWdlW107XG4gIH0sXG4pOiBUcmFuc2Zvcm1TdHJlYW08VWludDhBcnJheSwgVWludDhBcnJheT4ge1xuICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBsZXQgaXNGaXJzdENodW5rID0gdHJ1ZTtcbiAgbGV0IGFnZ3JlZ2F0ZWRSZXNwb25zZSA9ICcnO1xuICBsZXQgYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlID0gJyc7XG4gIGxldCBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTtcblxuICBsZXQgZnVuY3Rpb25DYWxsTWVzc2FnZXM6IENyZWF0ZU1lc3NhZ2VbXSA9XG4gICAgY2FsbGJhY2tzW19faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2xdIHx8IFtdO1xuXG4gIGNvbnN0IGRlY29kZSA9IGNyZWF0ZUNodW5rRGVjb2RlcigpO1xuXG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBkZWNvZGUoY2h1bmspO1xuICAgICAgYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlICs9IG1lc3NhZ2U7XG5cbiAgICAgIGNvbnN0IHNob3VsZEhhbmRsZUFzRnVuY3Rpb24gPVxuICAgICAgICBpc0ZpcnN0Q2h1bmsgJiZcbiAgICAgICAgKG1lc3NhZ2Uuc3RhcnRzV2l0aCgne1wiZnVuY3Rpb25fY2FsbFwiOicpIHx8XG4gICAgICAgICAgbWVzc2FnZS5zdGFydHNXaXRoKCd7XCJ0b29sX2NhbGxzXCI6JykpO1xuXG4gICAgICBpZiAoc2hvdWxkSGFuZGxlQXNGdW5jdGlvbikge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSB0cnVlO1xuICAgICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gbWVzc2FnZTtcbiAgICAgICAgaXNGaXJzdENodW5rID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gU3RyZWFtIGFzIG5vcm1hbFxuICAgICAgaWYgKCFpc0Z1bmN0aW9uU3RyZWFtaW5nSW4pIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0KCd0ZXh0JywgbWVzc2FnZSkpLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gbWVzc2FnZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzeW5jIGZsdXNoKGNvbnRyb2xsZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhaXNGaXJzdENodW5rICYmXG4gICAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luICYmXG4gICAgICAgICAgKGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgfHxcbiAgICAgICAgICAgIGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25Ub29sQ2FsbClcbiAgICAgICAgKSB7XG4gICAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gZmFsc2U7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UoYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgICAgICAvLyBBcHBlbmQgdGhlIGZ1bmN0aW9uIGNhbGwgbWVzc2FnZSB0byB0aGUgbGlzdFxuICAgICAgICAgIGxldCBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlczogQ3JlYXRlTWVzc2FnZVtdID0gW1xuICAgICAgICAgICAgLi4uZnVuY3Rpb25DYWxsTWVzc2FnZXMsXG4gICAgICAgICAgXTtcblxuICAgICAgICAgIGxldCBmdW5jdGlvblJlc3BvbnNlOlxuICAgICAgICAgICAgfCBSZXNwb25zZVxuICAgICAgICAgICAgfCB1bmRlZmluZWRcbiAgICAgICAgICAgIHwgdm9pZFxuICAgICAgICAgICAgfCBzdHJpbmdcbiAgICAgICAgICAgIHwgQXN5bmNJdGVyYWJsZU9wZW5BSVN0cmVhbVJldHVyblR5cGVzXG4gICAgICAgICAgICB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAvLyBUaGlzIGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgY2hlY2sgc2hvdWxkIG5vdCBiZSBuZWNlc3NhcnkgYnV0IFRTIGNvbXBsYWluc1xuICAgICAgICAgIGlmIChjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBpcyB1c2luZyB0aGUgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIGNhbGxiYWNrLCB0aGV5IHNob3VsZCBub3QgYmUgdXNpbmcgdG9vbHNcbiAgICAgICAgICAgIC8vIGlmIHBheWxvYWQuZnVuY3Rpb25fY2FsbCBpcyBub3QgZGVmaW5lZCBieSB0aW1lIHdlIGdldCBoZXJlIHdlIG11c3QgaGF2ZSBnb3R0ZW4gYSB0b29sIHJlc3BvbnNlXG4gICAgICAgICAgICAvLyBhbmQgdGhlIHVzZXIgaGFkIGRlZmluZWQgZXhwZXJpbWVudGFsX29uVG9vbENhbGxcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLmZ1bmN0aW9uX2NhbGwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgJ2V4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCBzaG91bGQgbm90IGJlIGRlZmluZWQgd2hlbiB1c2luZyB0b29scycsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGFyZ3VtZW50c1BheWxvYWQgPSBKU09OLnBhcnNlKFxuICAgICAgICAgICAgICBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZSA9IGF3YWl0IGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwoXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwubmFtZSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6IGFyZ3VtZW50c1BheWxvYWQsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBmdW5jdGlvbiBjYWxsIHJlcXVlc3QgYW5kIHJlc3VsdCBtZXNzYWdlcyB0byB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzID0gW1xuICAgICAgICAgICAgICAgICAgLi4uZnVuY3Rpb25DYWxsTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fY2FsbDogcGF5bG9hZC5mdW5jdGlvbl9jYWxsLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcGF5bG9hZC5mdW5jdGlvbl9jYWxsLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHJlc3VsdCksXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGl0IHRvIHRoZSB1c2VyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkge1xuICAgICAgICAgICAgY29uc3QgdG9vbENhbGxzOiBUb29sQ2FsbFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgIHRvb2xzOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2wgb2YgcGF5bG9hZC50b29sX2NhbGxzKSB7XG4gICAgICAgICAgICAgIHRvb2xDYWxscy50b29scy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogdG9vbC5pZCxcbiAgICAgICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgIGZ1bmM6IHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IHRvb2wuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogSlNPTi5wYXJzZSh0b29sLmZ1bmN0aW9uLmFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzcG9uc2VJbmRleCA9IDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlID0gYXdhaXQgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKFxuICAgICAgICAgICAgICAgIHRvb2xDYWxscyxcbiAgICAgICAgICAgICAgICByZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRvb2xfY2FsbF9pZCwgZnVuY3Rpb25fbmFtZSwgdG9vbF9jYWxsX3Jlc3VsdCB9ID1cbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgZnVuY3Rpb24gY2FsbCByZXF1ZXN0IGFuZCByZXN1bHQgbWVzc2FnZXMgdG8gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgLi4ubmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhcHBlbmQgdGhlIGFzc2lzdGFudCBtZXNzYWdlIGlmIGl0J3MgdGhlIGZpcnN0IHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgICAgLi4uKHJlc3BvbnNlSW5kZXggPT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnIGFzIGNvbnN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sX2NhbGxzOiBwYXlsb2FkLnRvb2xfY2FsbHMubWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGM6IFRvb2xDYWxsKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0Yy5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0Yy5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugc2VuZCB0aGUgYXJndW1lbnRzIGFuIG9iamVjdCB0byB0aGUgdXNlciwgYnV0IGFzIHRoZSBBUEkgZXhwZWN0cyBhIHN0cmluZywgd2UgbmVlZCB0byBzdHJpbmdpZnkgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRjLmZ1bmN0aW9uLmFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogW10pLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgZnVuY3Rpb24gY2FsbCByZXN1bHQgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6ICd0b29sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xfY2FsbF9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uX25hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeSh0b29sX2NhbGxfcmVzdWx0KSxcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gaXQgdG8gdGhlIHVzZXJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjYWxsaW5nIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsOicsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghZnVuY3Rpb25SZXNwb25zZSkge1xuICAgICAgICAgICAgLy8gVGhlIHVzZXIgZGlkbid0IGRvIGFueXRoaW5nIHdpdGggdGhlIGZ1bmN0aW9uIGNhbGwgb24gdGhlIHNlcnZlciBhbmQgd2FudHNcbiAgICAgICAgICAgIC8vIHRvIGVpdGhlciBkbyBub3RoaW5nIG9yIHJ1biBpdCBvbiB0aGUgY2xpZW50XG4gICAgICAgICAgICAvLyBzbyB3ZSBqdXN0IHJldHVybiB0aGUgZnVuY3Rpb24gY2FsbCBhcyBhIG1lc3NhZ2VcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXG4gICAgICAgICAgICAgICAgICBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwgPyAnZnVuY3Rpb25fY2FsbCcgOiAndG9vbF9jYWxscycsXG4gICAgICAgICAgICAgICAgICAvLyBwYXJzZSB0byBwcmV2ZW50IGRvdWJsZS1lbmNvZGluZzpcbiAgICAgICAgICAgICAgICAgIEpTT04ucGFyc2UoYWdncmVnYXRlZFJlc3BvbnNlKSxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmdW5jdGlvblJlc3BvbnNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gVGhlIHVzZXIgcmV0dXJuZWQgYSBzdHJpbmcsIHNvIHdlIGp1c3QgcmV0dXJuIGl0IGFzIGEgbWVzc2FnZVxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydCgndGV4dCcsIGZ1bmN0aW9uUmVzcG9uc2UpKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UgPSBmdW5jdGlvblJlc3BvbnNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5OlxuXG4gICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byB0cmlnZ2VyIG9uU3RhcnQgb3Igb25Db21wbGV0ZSByZWN1cnNpdmVseVxuICAgICAgICAgIC8vIHNvIHdlIHJlbW92ZSB0aGVtIGZyb20gdGhlIGNhbGxiYWNrc1xuICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL2FpL2lzc3Vlcy8zNTFcbiAgICAgICAgICBjb25zdCBmaWx0ZXJlZENhbGxiYWNrczogT3BlbkFJU3RyZWFtQ2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgLi4uY2FsbGJhY2tzLFxuICAgICAgICAgICAgb25TdGFydDogdW5kZWZpbmVkLFxuICAgICAgICAgIH07XG4gICAgICAgICAgLy8gV2Ugb25seSB3YW50IG9uRmluYWwgdG8gYmUgY2FsbGVkIHRoZSBfbGFzdF8gdGltZVxuICAgICAgICAgIGNhbGxiYWNrcy5vbkZpbmFsID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgY29uc3Qgb3BlbkFJU3RyZWFtID0gT3BlbkFJU3RyZWFtKGZ1bmN0aW9uUmVzcG9uc2UsIHtcbiAgICAgICAgICAgIC4uLmZpbHRlcmVkQ2FsbGJhY2tzLFxuICAgICAgICAgICAgW19faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2xdOiBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyxcbiAgICAgICAgICB9IGFzIEFJU3RyZWFtQ2FsbGJhY2tzQW5kT3B0aW9ucyk7XG5cbiAgICAgICAgICBjb25zdCByZWFkZXIgPSBvcGVuQUlTdHJlYW0uZ2V0UmVhZGVyKCk7XG5cbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChjYWxsYmFja3Mub25GaW5hbCAmJiBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UpIHtcbiAgICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25GaW5hbChhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgfSk7XG59XG4iLCIvKipcbiAqIENvbnN1bWVzIGEgUmVhZGFibGVTdHJlYW0gdW50aWwgaXQncyBmdWxseSByZWFkLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gcmVhZHMgdGhlIHN0cmVhbSBjaHVuayBieSBjaHVuayB1bnRpbCB0aGUgc3RyZWFtIGlzIGV4aGF1c3RlZC5cbiAqIEl0IGRvZXNuJ3QgcHJvY2VzcyBvciByZXR1cm4gdGhlIGRhdGEgZnJvbSB0aGUgc3RyZWFtOyBpdCBzaW1wbHkgZW5zdXJlc1xuICogdGhhdCB0aGUgZW50aXJlIHN0cmVhbSBpcyByZWFkLlxuICpcbiAqIEBwYXJhbSB7UmVhZGFibGVTdHJlYW19IHN0cmVhbSAtIFRoZSBSZWFkYWJsZVN0cmVhbSB0byBiZSBjb25zdW1lZC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBzdHJlYW0gaXMgZnVsbHkgY29uc3VtZWQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb25zdW1lU3RyZWFtKHN0cmVhbTogUmVhZGFibGVTdHJlYW0pOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHsgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkgYnJlYWs7XG4gIH1cbn1cbiIsImV4cG9ydCBjb25zdCBTVFJFQU1BQkxFX1ZBTFVFX1RZUEUgPSBTeW1ib2wuZm9yKCd1aS5zdHJlYW1hYmxlLnZhbHVlJyk7XG5cbmV4cG9ydCB0eXBlIFN0cmVhbWFibGVQYXRjaCA9IHVuZGVmaW5lZCB8IFswLCBzdHJpbmddOyAvLyBBcHBlbmQgc3RyaW5nLlxuXG5kZWNsYXJlIGNvbnN0IF9faW50ZXJuYWxfY3VycjogdW5pcXVlIHN5bWJvbDtcbmRlY2xhcmUgY29uc3QgX19pbnRlcm5hbF9lcnJvcjogdW5pcXVlIHN5bWJvbDtcblxuLyoqXG4gKiBTdHJlYW1hYmxlVmFsdWUgaXMgYSB2YWx1ZSB0aGF0IGNhbiBiZSBzdHJlYW1lZCBvdmVyIHRoZSBuZXR3b3JrIHZpYSBBSSBBY3Rpb25zLlxuICogVG8gcmVhZCB0aGUgc3RyZWFtZWQgdmFsdWVzLCB1c2UgdGhlIGByZWFkU3RyZWFtYWJsZVZhbHVlYCBvciBgdXNlU3RyZWFtYWJsZVZhbHVlYCBBUElzLlxuICovXG5leHBvcnQgdHlwZSBTdHJlYW1hYmxlVmFsdWU8VCA9IGFueSwgRSA9IGFueT4gPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgVXNlIGByZWFkU3RyZWFtYWJsZVZhbHVlYCB0byByZWFkIHRoZSB2YWx1ZXMuXG4gICAqL1xuICB0eXBlPzogdHlwZW9mIFNUUkVBTUFCTEVfVkFMVUVfVFlQRTtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBVc2UgYHJlYWRTdHJlYW1hYmxlVmFsdWVgIHRvIHJlYWQgdGhlIHZhbHVlcy5cbiAgICovXG4gIGN1cnI/OiBUO1xuICAvKipcbiAgICogQGludGVybmFsIFVzZSBgcmVhZFN0cmVhbWFibGVWYWx1ZWAgdG8gcmVhZCB0aGUgdmFsdWVzLlxuICAgKi9cbiAgZXJyb3I/OiBFO1xuICAvKipcbiAgICogQGludGVybmFsIFVzZSBgcmVhZFN0cmVhbWFibGVWYWx1ZWAgdG8gcmVhZCB0aGUgdmFsdWVzLlxuICAgKi9cbiAgZGlmZj86IFN0cmVhbWFibGVQYXRjaDtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBVc2UgYHJlYWRTdHJlYW1hYmxlVmFsdWVgIHRvIHJlYWQgdGhlIHZhbHVlcy5cbiAgICovXG4gIG5leHQ/OiBQcm9taXNlPFN0cmVhbWFibGVWYWx1ZTxULCBFPj47XG5cbiAgLy8gYnJhbmRlZCB0eXBlcyB0byBtYWludGFpbiB0eXBlIHNpZ25hdHVyZSBhZnRlciBpbnRlcm5hbCBwcm9wZXJ0aWVzIGFyZSBzdHJpcHBlZC5cbiAgW19faW50ZXJuYWxfY3Vycl0/OiBUO1xuICBbX19pbnRlcm5hbF9lcnJvcl0/OiBFO1xufTtcbiIsImltcG9ydCB7IEhBTkdJTkdfU1RSRUFNX1dBUk5JTkdfVElNRV9NUyB9IGZyb20gJy4uLy4uL3V0aWwvY29uc3RhbnRzJztcbmltcG9ydCB7IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlIH0gZnJvbSAnLi4vLi4vdXRpbC9jcmVhdGUtcmVzb2x2YWJsZS1wcm9taXNlJztcbmltcG9ydCB7XG4gIFNUUkVBTUFCTEVfVkFMVUVfVFlQRSxcbiAgU3RyZWFtYWJsZVBhdGNoLFxuICBTdHJlYW1hYmxlVmFsdWUsXG59IGZyb20gJy4vc3RyZWFtYWJsZS12YWx1ZSc7XG5cbmNvbnN0IFNUUkVBTUFCTEVfVkFMVUVfSU5URVJOQUxfTE9DSyA9IFN5bWJvbCgnc3RyZWFtYWJsZS52YWx1ZS5sb2NrJyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgd3JhcHBlZCwgY2hhbmdlYWJsZSB2YWx1ZSB0aGF0IGNhbiBiZSBzdHJlYW1lZCB0byB0aGUgY2xpZW50LlxuICogT24gdGhlIGNsaWVudCBzaWRlLCB0aGUgdmFsdWUgY2FuIGJlIGFjY2Vzc2VkIHZpYSB0aGUgcmVhZFN0cmVhbWFibGVWYWx1ZSgpIEFQSS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3RyZWFtYWJsZVZhbHVlPFQgPSBhbnksIEUgPSBhbnk+KFxuICBpbml0aWFsVmFsdWU/OiBUIHwgUmVhZGFibGVTdHJlYW08VD4sXG4pIHtcbiAgY29uc3QgaXNSZWFkYWJsZVN0cmVhbSA9XG4gICAgaW5pdGlhbFZhbHVlIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0gfHxcbiAgICAodHlwZW9mIGluaXRpYWxWYWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgIGluaXRpYWxWYWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgJ2dldFJlYWRlcicgaW4gaW5pdGlhbFZhbHVlICYmXG4gICAgICB0eXBlb2YgaW5pdGlhbFZhbHVlLmdldFJlYWRlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgJ2xvY2tlZCcgaW4gaW5pdGlhbFZhbHVlICYmXG4gICAgICB0eXBlb2YgaW5pdGlhbFZhbHVlLmxvY2tlZCA9PT0gJ2Jvb2xlYW4nKTtcblxuICBpZiAoIWlzUmVhZGFibGVTdHJlYW0pIHtcbiAgICByZXR1cm4gY3JlYXRlU3RyZWFtYWJsZVZhbHVlSW1wbDxULCBFPihpbml0aWFsVmFsdWUpO1xuICB9XG5cbiAgY29uc3Qgc3RyZWFtYWJsZVZhbHVlID0gY3JlYXRlU3RyZWFtYWJsZVZhbHVlSW1wbDxULCBFPigpO1xuXG4gIC8vIFNpbmNlIHRoZSBzdHJlYW1hYmxlIHZhbHVlIHdpbGwgYmUgZnJvbSBhIHJlYWRhYmxlIHN0cmVhbSwgaXQncyBub3QgYWxsb3dlZFxuICAvLyB0byB1cGRhdGUgdGhlIHZhbHVlIG1hbnVhbGx5IGFzIHRoYXQgaW50cm9kdWNlcyByYWNlIGNvbmRpdGlvbnMgYW5kXG4gIC8vIHVuZXhwZWN0ZWQgYmVoYXZpb3IuXG4gIC8vIFdlIGxvY2sgdGhlIHZhbHVlIHRvIHByZXZlbnQgYW55IHVwZGF0ZXMgZnJvbSB0aGUgdXNlci5cbiAgc3RyZWFtYWJsZVZhbHVlW1NUUkVBTUFCTEVfVkFMVUVfSU5URVJOQUxfTE9DS10gPSB0cnVlO1xuXG4gIChhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENvbnN1bWUgdGhlIHJlYWRhYmxlIHN0cmVhbSBhbmQgdXBkYXRlIHRoZSB2YWx1ZS5cbiAgICAgIGNvbnN0IHJlYWRlciA9IGluaXRpYWxWYWx1ZS5nZXRSZWFkZXIoKTtcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVubG9jayB0aGUgdmFsdWUgdG8gYWxsb3cgdXBkYXRlcy5cbiAgICAgICAgc3RyZWFtYWJsZVZhbHVlW1NUUkVBTUFCTEVfVkFMVUVfSU5URVJOQUxfTE9DS10gPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBzdHJlYW1hYmxlVmFsdWUuYXBwZW5kKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW1hYmxlVmFsdWUudXBkYXRlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMb2NrIHRoZSB2YWx1ZSBhZ2Fpbi5cbiAgICAgICAgc3RyZWFtYWJsZVZhbHVlW1NUUkVBTUFCTEVfVkFMVUVfSU5URVJOQUxfTE9DS10gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBzdHJlYW1hYmxlVmFsdWVbU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLXSA9IGZhbHNlO1xuICAgICAgc3RyZWFtYWJsZVZhbHVlLmRvbmUoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzdHJlYW1hYmxlVmFsdWVbU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLXSA9IGZhbHNlO1xuICAgICAgc3RyZWFtYWJsZVZhbHVlLmVycm9yKGUpO1xuICAgIH1cbiAgfSkoKTtcblxuICByZXR1cm4gc3RyZWFtYWJsZVZhbHVlO1xufVxuXG4vLyBJdCdzIG5lY2Vzc2FyeSB0byBkZWZpbmUgdGhlIHR5cGUgbWFudWFsbHkgaGVyZSwgb3RoZXJ3aXNlIFR5cGVTY3JpcHQgY29tcGlsZXJcbi8vIHdpbGwgbm90IGJlIGFibGUgdG8gaW5mZXIgdGhlIGNvcnJlY3QgcmV0dXJuIHR5cGUgYXMgaXQncyBjaXJjdWxhci5cbnR5cGUgU3RyZWFtYWJsZVZhbHVlV3JhcHBlcjxULCBFPiA9IHtcbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSBvZiB0aGUgc3RyZWFtYWJsZS4gVGhpcyBjYW4gYmUgcmV0dXJuZWQgZnJvbSBhIFNlcnZlciBBY3Rpb24gYW5kXG4gICAqIHJlY2VpdmVkIGJ5IHRoZSBjbGllbnQuIFRvIHJlYWQgdGhlIHN0cmVhbWVkIHZhbHVlcywgdXNlIHRoZVxuICAgKiBgcmVhZFN0cmVhbWFibGVWYWx1ZWAgb3IgYHVzZVN0cmVhbWFibGVWYWx1ZWAgQVBJcy5cbiAgICovXG4gIHJlYWRvbmx5IHZhbHVlOiBTdHJlYW1hYmxlVmFsdWU8VCwgRT47XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHVwZGF0ZXMgdGhlIGN1cnJlbnQgdmFsdWUgd2l0aCBhIG5ldyBvbmUuXG4gICAqL1xuICB1cGRhdGUodmFsdWU6IFQpOiBTdHJlYW1hYmxlVmFsdWVXcmFwcGVyPFQsIEU+O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGFwcGVuZCBhIGRlbHRhIHN0cmluZyB0byB0aGUgY3VycmVudCB2YWx1ZS4gSXRcbiAgICogcmVxdWlyZXMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHN0cmVhbWFibGUgdG8gYmUgYSBzdHJpbmcuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzeFxuICAgKiBjb25zdCBzdHJlYW1hYmxlID0gY3JlYXRlU3RyZWFtYWJsZVZhbHVlKCdoZWxsbycpO1xuICAgKiBzdHJlYW1hYmxlLmFwcGVuZCgnIHdvcmxkJyk7XG4gICAqXG4gICAqIC8vIFRoZSB2YWx1ZSB3aWxsIGJlICdoZWxsbyB3b3JsZCdcbiAgICogYGBgXG4gICAqL1xuICBhcHBlbmQodmFsdWU6IFQpOiBTdHJlYW1hYmxlVmFsdWVXcmFwcGVyPFQsIEU+O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIHNpZ25hbCB0aGF0IHRoZXJlIGlzIGFuIGVycm9yIGluIHRoZSB2YWx1ZSBzdHJlYW0uXG4gICAqIEl0IHdpbGwgYmUgdGhyb3duIG9uIHRoZSBjbGllbnQgc2lkZSB3aGVuIGNvbnN1bWVkIHZpYVxuICAgKiBgcmVhZFN0cmVhbWFibGVWYWx1ZWAgb3IgYHVzZVN0cmVhbWFibGVWYWx1ZWAuXG4gICAqL1xuICBlcnJvcihlcnJvcjogYW55KTogU3RyZWFtYWJsZVZhbHVlV3JhcHBlcjxULCBFPjtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgbWFya3MgdGhlIHZhbHVlIGFzIGZpbmFsaXplZC4gWW91IGNhbiBlaXRoZXIgY2FsbCBpdCB3aXRob3V0XG4gICAqIGFueSBwYXJhbWV0ZXJzIG9yIHdpdGggYSBuZXcgdmFsdWUgYXMgdGhlIGZpbmFsIHN0YXRlLlxuICAgKiBPbmNlIGNhbGxlZCwgdGhlIHZhbHVlIGNhbm5vdCBiZSB1cGRhdGVkIG9yIGFwcGVuZGVkIGFueW1vcmUuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGFsd2F5cyAqKnJlcXVpcmVkKiogdG8gYmUgY2FsbGVkLCBvdGhlcndpc2UgdGhlIHJlc3BvbnNlXG4gICAqIHdpbGwgYmUgc3R1Y2sgaW4gYSBsb2FkaW5nIHN0YXRlLlxuICAgKi9cbiAgZG9uZSguLi5hcmdzOiBbVF0gfCBbXSk6IFN0cmVhbWFibGVWYWx1ZVdyYXBwZXI8VCwgRT47XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBUaGlzIGlzIGFuIGludGVybmFsIGxvY2sgdG8gcHJldmVudCB0aGUgdmFsdWUgZnJvbSBiZWluZ1xuICAgKiB1cGRhdGVkIGJ5IHRoZSB1c2VyLlxuICAgKi9cbiAgW1NUUkVBTUFCTEVfVkFMVUVfSU5URVJOQUxfTE9DS106IGJvb2xlYW47XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1hYmxlVmFsdWVJbXBsPFQgPSBhbnksIEUgPSBhbnk+KGluaXRpYWxWYWx1ZT86IFQpIHtcbiAgbGV0IGNsb3NlZCA9IGZhbHNlO1xuICBsZXQgbG9ja2VkID0gZmFsc2U7XG4gIGxldCByZXNvbHZhYmxlID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2U8U3RyZWFtYWJsZVZhbHVlPFQsIEU+PigpO1xuXG4gIGxldCBjdXJyZW50VmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gIGxldCBjdXJyZW50RXJyb3I6IEUgfCB1bmRlZmluZWQ7XG4gIGxldCBjdXJyZW50UHJvbWlzZTogdHlwZW9mIHJlc29sdmFibGUucHJvbWlzZSB8IHVuZGVmaW5lZCA9XG4gICAgcmVzb2x2YWJsZS5wcm9taXNlO1xuICBsZXQgY3VycmVudFBhdGNoVmFsdWU6IFN0cmVhbWFibGVQYXRjaDtcblxuICBmdW5jdGlvbiBhc3NlcnRTdHJlYW0obWV0aG9kOiBzdHJpbmcpIHtcbiAgICBpZiAoY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kICsgJzogVmFsdWUgc3RyZWFtIGlzIGFscmVhZHkgY2xvc2VkLicpO1xuICAgIH1cbiAgICBpZiAobG9ja2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIG1ldGhvZCArICc6IFZhbHVlIHN0cmVhbSBpcyBsb2NrZWQgYW5kIGNhbm5vdCBiZSB1cGRhdGVkLicsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGxldCB3YXJuaW5nVGltZW91dDogTm9kZUpTLlRpbWVvdXQgfCB1bmRlZmluZWQ7XG4gIGZ1bmN0aW9uIHdhcm5VbmNsb3NlZFN0cmVhbSgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGlmICh3YXJuaW5nVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQod2FybmluZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgICAgd2FybmluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdUaGUgc3RyZWFtYWJsZSB2YWx1ZSBoYXMgYmVlbiBzbG93IHRvIHVwZGF0ZS4gVGhpcyBtYXkgYmUgYSBidWcgb3IgYSBwZXJmb3JtYW5jZSBpc3N1ZSBvciB5b3UgZm9yZ290IHRvIGNhbGwgYC5kb25lKClgLicsXG4gICAgICAgICk7XG4gICAgICB9LCBIQU5HSU5HX1NUUkVBTV9XQVJOSU5HX1RJTUVfTVMpO1xuICAgIH1cbiAgfVxuICB3YXJuVW5jbG9zZWRTdHJlYW0oKTtcblxuICBmdW5jdGlvbiBjcmVhdGVXcmFwcGVkKGluaXRpYWxDaHVuaz86IGJvb2xlYW4pOiBTdHJlYW1hYmxlVmFsdWU8VCwgRT4ge1xuICAgIC8vIFRoaXMgbWFrZXMgdGhlIHBheWxvYWQgbXVjaCBzbWFsbGVyIGlmIHRoZXJlJ3JlIG11dGF0aXZlIHVwZGF0ZXMgYmVmb3JlIHRoZSBmaXJzdCByZWFkLlxuICAgIGxldCBpbml0OiBQYXJ0aWFsPFN0cmVhbWFibGVWYWx1ZTxULCBFPj47XG5cbiAgICBpZiAoY3VycmVudEVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGluaXQgPSB7IGVycm9yOiBjdXJyZW50RXJyb3IgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGN1cnJlbnRQYXRjaFZhbHVlICYmICFpbml0aWFsQ2h1bmspIHtcbiAgICAgICAgaW5pdCA9IHsgZGlmZjogY3VycmVudFBhdGNoVmFsdWUgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluaXQgPSB7IGN1cnI6IGN1cnJlbnRWYWx1ZSB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjdXJyZW50UHJvbWlzZSkge1xuICAgICAgaW5pdC5uZXh0ID0gY3VycmVudFByb21pc2U7XG4gICAgfVxuXG4gICAgaWYgKGluaXRpYWxDaHVuaykge1xuICAgICAgaW5pdC50eXBlID0gU1RSRUFNQUJMRV9WQUxVRV9UWVBFO1xuICAgIH1cblxuICAgIHJldHVybiBpbml0O1xuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSBpbnRlcm5hbCBgY3VycmVudFZhbHVlYCBhbmQgYGN1cnJlbnRQYXRjaFZhbHVlYCBpZiBuZWVkZWQuXG4gIGZ1bmN0aW9uIHVwZGF0ZVZhbHVlU3RhdGVzKHZhbHVlOiBUKSB7XG4gICAgLy8gSWYgd2UgY2FuIG9ubHkgc2VuZCBhIHBhdGNoIG92ZXIgdGhlIHdpcmUsIGl0J3MgYmV0dGVyIHRvIGRvIHNvLlxuICAgIGN1cnJlbnRQYXRjaFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodHlwZW9mIGN1cnJlbnRWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoY3VycmVudFZhbHVlKSkge1xuICAgICAgICAgIGN1cnJlbnRQYXRjaFZhbHVlID0gWzAsIHZhbHVlLnNsaWNlKGN1cnJlbnRWYWx1ZS5sZW5ndGgpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgY29uc3Qgc3RyZWFtYWJsZTogU3RyZWFtYWJsZVZhbHVlV3JhcHBlcjxULCBFPiA9IHtcbiAgICBzZXQgW1NUUkVBTUFCTEVfVkFMVUVfSU5URVJOQUxfTE9DS10oc3RhdGU6IGJvb2xlYW4pIHtcbiAgICAgIGxvY2tlZCA9IHN0YXRlO1xuICAgIH0sXG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZWQodHJ1ZSk7XG4gICAgfSxcbiAgICB1cGRhdGUodmFsdWU6IFQpIHtcbiAgICAgIGFzc2VydFN0cmVhbSgnLnVwZGF0ZSgpJyk7XG5cbiAgICAgIGNvbnN0IHJlc29sdmVQcmV2aW91cyA9IHJlc29sdmFibGUucmVzb2x2ZTtcbiAgICAgIHJlc29sdmFibGUgPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuXG4gICAgICB1cGRhdGVWYWx1ZVN0YXRlcyh2YWx1ZSk7XG4gICAgICBjdXJyZW50UHJvbWlzZSA9IHJlc29sdmFibGUucHJvbWlzZTtcbiAgICAgIHJlc29sdmVQcmV2aW91cyhjcmVhdGVXcmFwcGVkKCkpO1xuXG4gICAgICB3YXJuVW5jbG9zZWRTdHJlYW0oKTtcblxuICAgICAgcmV0dXJuIHN0cmVhbWFibGU7XG4gICAgfSxcbiAgICBhcHBlbmQodmFsdWU6IFQpIHtcbiAgICAgIGFzc2VydFN0cmVhbSgnLmFwcGVuZCgpJyk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIGN1cnJlbnRWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICAgICAgdHlwZW9mIGN1cnJlbnRWYWx1ZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYC5hcHBlbmQoKTogVGhlIGN1cnJlbnQgdmFsdWUgaXMgbm90IGEgc3RyaW5nLiBSZWNlaXZlZDogJHt0eXBlb2YgY3VycmVudFZhbHVlfWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYC5hcHBlbmQoKTogVGhlIHZhbHVlIGlzIG5vdCBhIHN0cmluZy4gUmVjZWl2ZWQ6ICR7dHlwZW9mIHZhbHVlfWAsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc29sdmVQcmV2aW91cyA9IHJlc29sdmFibGUucmVzb2x2ZTtcbiAgICAgIHJlc29sdmFibGUgPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuXG4gICAgICBpZiAodHlwZW9mIGN1cnJlbnRWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY3VycmVudFBhdGNoVmFsdWUgPSBbMCwgdmFsdWVdO1xuICAgICAgICAoY3VycmVudFZhbHVlIGFzIHN0cmluZykgPSBjdXJyZW50VmFsdWUgKyB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRQYXRjaFZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICBjdXJyZW50VmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudFByb21pc2UgPSByZXNvbHZhYmxlLnByb21pc2U7XG4gICAgICByZXNvbHZlUHJldmlvdXMoY3JlYXRlV3JhcHBlZCgpKTtcblxuICAgICAgd2FyblVuY2xvc2VkU3RyZWFtKCk7XG5cbiAgICAgIHJldHVybiBzdHJlYW1hYmxlO1xuICAgIH0sXG4gICAgZXJyb3IoZXJyb3I6IGFueSkge1xuICAgICAgYXNzZXJ0U3RyZWFtKCcuZXJyb3IoKScpO1xuXG4gICAgICBpZiAod2FybmluZ1RpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHdhcm5pbmdUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICBjdXJyZW50RXJyb3IgPSBlcnJvcjtcbiAgICAgIGN1cnJlbnRQcm9taXNlID0gdW5kZWZpbmVkO1xuXG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUoeyBlcnJvciB9KTtcblxuICAgICAgcmV0dXJuIHN0cmVhbWFibGU7XG4gICAgfSxcbiAgICBkb25lKC4uLmFyZ3M6IFtdIHwgW1RdKSB7XG4gICAgICBhc3NlcnRTdHJlYW0oJy5kb25lKCknKTtcblxuICAgICAgaWYgKHdhcm5pbmdUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh3YXJuaW5nVGltZW91dCk7XG4gICAgICB9XG4gICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgY3VycmVudFByb21pc2UgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCkge1xuICAgICAgICB1cGRhdGVWYWx1ZVN0YXRlcyhhcmdzWzBdKTtcbiAgICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKGNyZWF0ZVdyYXBwZWQoKSk7XG4gICAgICAgIHJldHVybiBzdHJlYW1hYmxlO1xuICAgICAgfVxuXG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUoe30pO1xuXG4gICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICB9LFxuICB9O1xuXG4gIHJldHVybiBzdHJlYW1hYmxlO1xufVxuXG5leHBvcnQgeyBjcmVhdGVTdHJlYW1hYmxlVmFsdWUgfTtcbiJdLCJuYW1lcyI6WyJfYSIsIm5hbWUiLCJBSVNES0Vycm9yIiwibWFya2VyIiwic3ltYm9sIiwieiIsImdldEVycm9yTWVzc2FnZSIsImpzeCIsInN0cmVhbWFibGUiLCJyZW5kZXIiLCJmb3JtYXRTdHJlYW1QYXJ0IiwidmFsdWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ai/rsc/dist/rsc-server.mjs\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ai/rsc/dist/rsc-shared.mjs":
/*!*************************************************!*\
  !*** ./node_modules/ai/rsc/dist/rsc-shared.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InternalAIProvider: () => (/* binding */ InternalAIProvider),
/* harmony export */   readStreamableValue: () => (/* binding */ readStreamableValue),
/* harmony export */   useAIState: () => (/* binding */ useAIState),
/* harmony export */   useActions: () => (/* binding */ useActions),
/* harmony export */   useStreamableValue: () => (/* binding */ useStreamableValue),
/* harmony export */   useSyncUIState: () => (/* binding */ useSyncUIState),
/* harmony export */   useUIState: () => (/* binding */ useUIState)
/* harmony export */ });
/* harmony import */ var react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-server-dom-webpack/server.edge */ "(action-browser)/./node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-webpack-server-edge.js");

const InternalAIProvider = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call InternalAIProvider() from the server but InternalAIProvider is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/lorenzorasmussen/Projects/GooGledatanexus-ai/pinecone-assistant/node_modules/ai/rsc/dist/rsc-shared.mjs",
"InternalAIProvider",
);const readStreamableValue = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call readStreamableValue() from the server but readStreamableValue is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/lorenzorasmussen/Projects/GooGledatanexus-ai/pinecone-assistant/node_modules/ai/rsc/dist/rsc-shared.mjs",
"readStreamableValue",
);const useAIState = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useAIState() from the server but useAIState is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/lorenzorasmussen/Projects/GooGledatanexus-ai/pinecone-assistant/node_modules/ai/rsc/dist/rsc-shared.mjs",
"useAIState",
);const useActions = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useActions() from the server but useActions is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/lorenzorasmussen/Projects/GooGledatanexus-ai/pinecone-assistant/node_modules/ai/rsc/dist/rsc-shared.mjs",
"useActions",
);const useStreamableValue = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useStreamableValue() from the server but useStreamableValue is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/lorenzorasmussen/Projects/GooGledatanexus-ai/pinecone-assistant/node_modules/ai/rsc/dist/rsc-shared.mjs",
"useStreamableValue",
);const useSyncUIState = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useSyncUIState() from the server but useSyncUIState is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/lorenzorasmussen/Projects/GooGledatanexus-ai/pinecone-assistant/node_modules/ai/rsc/dist/rsc-shared.mjs",
"useSyncUIState",
);const useUIState = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useUIState() from the server but useUIState is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/lorenzorasmussen/Projects/GooGledatanexus-ai/pinecone-assistant/node_modules/ai/rsc/dist/rsc-shared.mjs",
"useUIState",
);

/***/ }),

/***/ "(ssr)/./node_modules/ai/rsc/dist/rsc-shared.mjs":
/*!*************************************************!*\
  !*** ./node_modules/ai/rsc/dist/rsc-shared.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InternalAIProvider: () => (/* binding */ InternalAIProvider),\n/* harmony export */   readStreamableValue: () => (/* binding */ readStreamableValue),\n/* harmony export */   useAIState: () => (/* binding */ useAIState),\n/* harmony export */   useActions: () => (/* binding */ useActions),\n/* harmony export */   useStreamableValue: () => (/* binding */ useStreamableValue),\n/* harmony export */   useSyncUIState: () => (/* binding */ useSyncUIState),\n/* harmony export */   useUIState: () => (/* binding */ useUIState)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jsondiffpatch */ \"(ssr)/./node_modules/jsondiffpatch/lib/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* __next_internal_client_entry_do_not_use__ InternalAIProvider,readStreamableValue,useAIState,useActions,useStreamableValue,useSyncUIState,useUIState auto */ // rsc/streamable-value/streamable-value.ts\nvar STREAMABLE_VALUE_TYPE = Symbol.for(\"ui.streamable.value\");\n// rsc/streamable-value/is-streamable-value.ts\nfunction isStreamableValue(value) {\n    return value != null && typeof value === \"object\" && \"type\" in value && value.type === STREAMABLE_VALUE_TYPE;\n}\n// rsc/streamable-value/read-streamable-value.tsx\nfunction readStreamableValue(streamableValue) {\n    if (!isStreamableValue(streamableValue)) {\n        throw new Error(\"Invalid value: this hook only accepts values created via `createStreamableValue`.\");\n    }\n    return {\n        [Symbol.asyncIterator] () {\n            let row = streamableValue;\n            let value = row.curr;\n            let isDone = false;\n            let isFirstIteration = true;\n            return {\n                async next () {\n                    if (isDone) return {\n                        value,\n                        done: true\n                    };\n                    row = await row;\n                    if (row.error !== void 0) {\n                        throw row.error;\n                    }\n                    if (\"curr\" in row || row.diff) {\n                        if (row.diff) {\n                            if (row.diff[0] === 0) {\n                                if (typeof value !== \"string\") {\n                                    throw new Error(\"Invalid patch: can only append to string types. This is a bug in the AI SDK.\");\n                                }\n                                value = value + row.diff[1];\n                            }\n                        } else {\n                            value = row.curr;\n                        }\n                        if (!row.next) {\n                            isDone = true;\n                            return {\n                                value,\n                                done: false\n                            };\n                        }\n                    }\n                    if (row.next === void 0) {\n                        return {\n                            value,\n                            done: true\n                        };\n                    }\n                    row = row.next;\n                    if (isFirstIteration) {\n                        isFirstIteration = false;\n                        if (value === void 0) {\n                            return this.next();\n                        }\n                    }\n                    return {\n                        value,\n                        done: false\n                    };\n                }\n            };\n        }\n    };\n}\n// rsc/streamable-value/use-streamable-value.tsx\n\nfunction checkStreamableValue(value) {\n    const hasSignature = isStreamableValue(value);\n    if (!hasSignature && value !== void 0) {\n        throw new Error(\"Invalid value: this hook only accepts values created via `createStreamableValue`.\");\n    }\n    return hasSignature;\n}\nfunction useStreamableValue(streamableValue) {\n    const [curr, setCurr] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(checkStreamableValue(streamableValue) ? streamableValue.curr : void 0);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(checkStreamableValue(streamableValue) ? streamableValue.error : void 0);\n    const [pending, setPending] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(checkStreamableValue(streamableValue) ? !!streamableValue.next : false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)({\n        \"useStreamableValue.useLayoutEffect\": ()=>{\n            if (!checkStreamableValue(streamableValue)) return;\n            let cancelled = false;\n            const iterator = readStreamableValue(streamableValue);\n            if (streamableValue.next) {\n                (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)({\n                    \"useStreamableValue.useLayoutEffect\": ()=>{\n                        if (cancelled) return;\n                        setPending(true);\n                    }\n                }[\"useStreamableValue.useLayoutEffect\"]);\n            }\n            ({\n                \"useStreamableValue.useLayoutEffect\": async ()=>{\n                    try {\n                        for await (const value of iterator){\n                            if (cancelled) return;\n                            (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)({\n                                \"useStreamableValue.useLayoutEffect\": ()=>{\n                                    if (cancelled) return;\n                                    setCurr(value);\n                                }\n                            }[\"useStreamableValue.useLayoutEffect\"]);\n                        }\n                    } catch (e) {\n                        if (cancelled) return;\n                        (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)({\n                            \"useStreamableValue.useLayoutEffect\": ()=>{\n                                if (cancelled) return;\n                                setError(e);\n                            }\n                        }[\"useStreamableValue.useLayoutEffect\"]);\n                    } finally{\n                        if (cancelled) return;\n                        (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)({\n                            \"useStreamableValue.useLayoutEffect\": ()=>{\n                                if (cancelled) return;\n                                setPending(false);\n                            }\n                        }[\"useStreamableValue.useLayoutEffect\"]);\n                    }\n                }\n            })[\"useStreamableValue.useLayoutEffect\"]();\n            return ({\n                \"useStreamableValue.useLayoutEffect\": ()=>{\n                    cancelled = true;\n                }\n            })[\"useStreamableValue.useLayoutEffect\"];\n        }\n    }[\"useStreamableValue.useLayoutEffect\"], [\n        streamableValue\n    ]);\n    return [\n        curr,\n        error,\n        pending\n    ];\n}\n// rsc/shared-client/context.tsx\n\n\n// util/is-function.ts\nvar isFunction = (value)=>typeof value === \"function\";\n// rsc/shared-client/context.tsx\n\nvar InternalUIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar InternalAIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);\nvar InternalActionProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar InternalSyncUIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction InternalAIProvider({ children, initialUIState, initialAIState, initialAIStatePatch, wrappedActions, wrappedSyncUIState }) {\n    if (!(\"use\" in /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2))))) {\n        throw new Error(\"Unsupported React version.\");\n    }\n    const uiState = react__WEBPACK_IMPORTED_MODULE_0__.useState(initialUIState);\n    const setUIState = uiState[1];\n    const resolvedInitialAIStatePatch = initialAIStatePatch ? react__WEBPACK_IMPORTED_MODULE_0__.use(initialAIStatePatch) : void 0;\n    initialAIState = react__WEBPACK_IMPORTED_MODULE_0__.useMemo({\n        \"InternalAIProvider.useMemo\": ()=>{\n            if (resolvedInitialAIStatePatch) {\n                return jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(initialAIState), resolvedInitialAIStatePatch);\n            }\n            return initialAIState;\n        }\n    }[\"InternalAIProvider.useMemo\"], [\n        initialAIState,\n        resolvedInitialAIStatePatch\n    ]);\n    const aiState = react__WEBPACK_IMPORTED_MODULE_0__.useState(initialAIState);\n    const setAIState = aiState[1];\n    const aiStateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(aiState[0]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect({\n        \"InternalAIProvider.useEffect\": ()=>{\n            aiStateRef.current = aiState[0];\n        }\n    }[\"InternalAIProvider.useEffect\"], [\n        aiState[0]\n    ]);\n    const clientWrappedActions = react__WEBPACK_IMPORTED_MODULE_0__.useMemo({\n        \"InternalAIProvider.useMemo[clientWrappedActions]\": ()=>Object.fromEntries(Object.entries(wrappedActions).map({\n                \"InternalAIProvider.useMemo[clientWrappedActions]\": ([key, action])=>[\n                        key,\n                        {\n                            \"InternalAIProvider.useMemo[clientWrappedActions]\": async (...args)=>{\n                                const aiStateSnapshot = aiStateRef.current;\n                                const [aiStateDelta, result] = await action(aiStateSnapshot, ...args);\n                                ({\n                                    \"InternalAIProvider.useMemo[clientWrappedActions]\": async ()=>{\n                                        const delta = await aiStateDelta;\n                                        if (delta !== void 0) {\n                                            aiState[1](jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(aiStateSnapshot), delta));\n                                        }\n                                    }\n                                })[\"InternalAIProvider.useMemo[clientWrappedActions]\"]();\n                                return result;\n                            }\n                        }[\"InternalAIProvider.useMemo[clientWrappedActions]\"]\n                    ]\n            }[\"InternalAIProvider.useMemo[clientWrappedActions]\"]))\n    }[\"InternalAIProvider.useMemo[clientWrappedActions]\"], [\n        wrappedActions\n    ]);\n    const clientWrappedSyncUIStateAction = react__WEBPACK_IMPORTED_MODULE_0__.useMemo({\n        \"InternalAIProvider.useMemo[clientWrappedSyncUIStateAction]\": ()=>{\n            if (!wrappedSyncUIState) {\n                return ({\n                    \"InternalAIProvider.useMemo[clientWrappedSyncUIStateAction]\": ()=>{}\n                })[\"InternalAIProvider.useMemo[clientWrappedSyncUIStateAction]\"];\n            }\n            return ({\n                \"InternalAIProvider.useMemo[clientWrappedSyncUIStateAction]\": async ()=>{\n                    const aiStateSnapshot = aiStateRef.current;\n                    const [aiStateDelta, uiState2] = await wrappedSyncUIState(aiStateSnapshot);\n                    if (uiState2 !== void 0) {\n                        setUIState(uiState2);\n                    }\n                    const delta = await aiStateDelta;\n                    if (delta !== void 0) {\n                        const patchedAiState = jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(aiStateSnapshot), delta);\n                        setAIState(patchedAiState);\n                    }\n                }\n            })[\"InternalAIProvider.useMemo[clientWrappedSyncUIStateAction]\"];\n        }\n    }[\"InternalAIProvider.useMemo[clientWrappedSyncUIStateAction]\"], [\n        wrappedSyncUIState\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalAIStateProvider.Provider, {\n        value: aiState,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalUIStateProvider.Provider, {\n            value: uiState,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalActionProvider.Provider, {\n                value: clientWrappedActions,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalSyncUIStateProvider.Provider, {\n                    value: clientWrappedSyncUIStateAction,\n                    children\n                })\n            })\n        })\n    });\n}\nfunction useUIState() {\n    const state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalUIStateProvider);\n    if (state === null) {\n        throw new Error(\"`useUIState` must be used inside an <AI> provider.\");\n    }\n    if (!Array.isArray(state)) {\n        throw new Error(\"Invalid state\");\n    }\n    if (state[0] === void 0) {\n        throw new Error(\"`initialUIState` must be provided to `createAI` or `<AI>`\");\n    }\n    return state;\n}\nfunction useAIState(...args) {\n    const state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalAIStateProvider);\n    if (state === null) {\n        throw new Error(\"`useAIState` must be used inside an <AI> provider.\");\n    }\n    if (!Array.isArray(state)) {\n        throw new Error(\"Invalid state\");\n    }\n    if (state[0] === void 0) {\n        throw new Error(\"`initialAIState` must be provided to `createAI` or `<AI>`\");\n    }\n    if (args.length >= 1 && typeof state[0] !== \"object\") {\n        throw new Error(\"When using `useAIState` with a key, the AI state must be an object.\");\n    }\n    const key = args[0];\n    const setter = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(typeof key === \"undefined\" ? state[1] : ({\n        \"useAIState.useCallback[setter]\": (newState)=>{\n            if (isFunction(newState)) {\n                return state[1]({\n                    \"useAIState.useCallback[setter]\": (s)=>{\n                        return {\n                            ...s,\n                            [key]: newState(s[key])\n                        };\n                    }\n                }[\"useAIState.useCallback[setter]\"]);\n            } else {\n                return state[1]({\n                    ...state[0],\n                    [key]: newState\n                });\n            }\n        }\n    })[\"useAIState.useCallback[setter]\"], [\n        key\n    ]);\n    if (args.length === 0) {\n        return state;\n    } else {\n        return [\n            state[0][args[0]],\n            setter\n        ];\n    }\n}\nfunction useActions() {\n    const actions = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalActionProvider);\n    return actions;\n}\nfunction useSyncUIState() {\n    const syncUIState = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalSyncUIStateProvider);\n    if (syncUIState === null) {\n        throw new Error(\"`useSyncUIState` must be used inside an <AI> provider.\");\n    }\n    return syncUIState;\n}\n //# sourceMappingURL=rsc-shared.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvcnNjL2Rpc3QvcnNjLXNoYXJlZC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQU8sSUFBTSx3QkFBd0IsT0FBTyxJQUFJLHFCQUFxQjs7QUNFOUQsU0FBUyxrQkFBa0IsT0FBMEM7SUFDMUUsT0FDRSxTQUFTLFFBQ1QsT0FBTyxVQUFVLFlBQ2pCLFVBQVUsU0FDVixNQUFNLFNBQVM7QUFFbkI7O0FDd0JPLFNBQVMsb0JBQ2QsaUJBQzhCO0lBQzlCLElBQUksQ0FBQyxrQkFBa0IsZUFBZSxHQUFHO1FBQ3ZDLE1BQU0sSUFBSSxNQUNSO0lBRUo7SUFFQSxPQUFPO1FBQ0wsQ0FBQyxPQUFPLGFBQWEsSUFBSTtZQUN2QixJQUFJLE1BQ0Y7WUFDRixJQUFJLFFBQVEsSUFBSTtZQUNoQixJQUFJLFNBQVM7WUFDYixJQUFJLG1CQUFtQjtZQUV2QixPQUFPO2dCQUNMLE1BQU0sT0FBTztvQkFFWCxJQUFJLFFBQVEsT0FBTzt3QkFBRTt3QkFBTyxNQUFNO29CQUFLO29CQUd2QyxNQUFNLE1BQU07b0JBR1osSUFBSSxJQUFJLFVBQVUsUUFBVzt3QkFDM0IsTUFBTSxJQUFJO29CQUNaO29CQUdBLElBQUksVUFBVSxPQUFPLElBQUksTUFBTTt3QkFDN0IsSUFBSSxJQUFJLE1BQU07NEJBRVosSUFBSSxJQUFJLEtBQUssQ0FBQyxNQUFNLEdBQUc7Z0NBQ3JCLElBQUksT0FBTyxVQUFVLFVBQVU7b0NBQzdCLE1BQU0sSUFBSSxNQUNSO2dDQUVKO2dDQUdDLFFBQW1CLFFBQVEsSUFBSSxLQUFLLENBQUM7NEJBQ3hDO3dCQUNGLE9BQU87NEJBRUwsUUFBUSxJQUFJO3dCQUNkO3dCQUlBLElBQUksQ0FBQyxJQUFJLE1BQU07NEJBQ2IsU0FBUzs0QkFDVCxPQUFPO2dDQUFFO2dDQUFPLE1BQU07NEJBQU07d0JBQzlCO29CQUNGO29CQUdBLElBQUksSUFBSSxTQUFTLFFBQVc7d0JBQzFCLE9BQU87NEJBQUU7NEJBQU8sTUFBTTt3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O1FBQ0Y7MENBQ0o7UUFBQyxHQUFHO0tBQUE7SUFHTixJQUFJLEtBQUssV0FBVyxHQUFHO1FBQ3JCLE9BQU87SUFDVCxPQUFPO1FBQ0wsT0FBTztZQUFDLE1BQU0sQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQUcsTUFBTTtTQUFBO0lBQ25DO0FBQ0Y7QUFFTyxTQUFTLGFBQTBDO0lBR3hELE1BQU0sVUFBZ0IsOENBQWMsc0JBQXNCO0lBQzFELE9BQU87QUFDVDtBQUVPLFNBQVMsaUJBQWlCO0lBQy9CLE1BQU0sY0FBb0IsOENBQ3hCO0lBR0YsSUFBSSxnQkFBZ0IsTUFBTTtRQUN4QixNQUFNLElBQUksTUFBTSx3REFBd0Q7SUFDMUU7SUFFQSxPQUFPO0FBQ1QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9sb3JlbnpvcmFzbXVzc2VuL1Byb2plY3RzL0dvb0dsZWRhdGFuZXh1cy1haS9zdHJlYW1hYmxlLXZhbHVlL3N0cmVhbWFibGUtdmFsdWUudHMiLCIvVXNlcnMvbG9yZW56b3Jhc211c3Nlbi9Qcm9qZWN0cy9Hb29HbGVkYXRhbmV4dXMtYWkvc3RyZWFtYWJsZS12YWx1ZS9pcy1zdHJlYW1hYmxlLXZhbHVlLnRzIiwiL1VzZXJzL2xvcmVuem9yYXNtdXNzZW4vUHJvamVjdHMvR29vR2xlZGF0YW5leHVzLWFpL3N0cmVhbWFibGUtdmFsdWUvcmVhZC1zdHJlYW1hYmxlLXZhbHVlLnRzeCIsIi9Vc2Vycy9sb3JlbnpvcmFzbXVzc2VuL1Byb2plY3RzL0dvb0dsZWRhdGFuZXh1cy1haS9zdHJlYW1hYmxlLXZhbHVlL3VzZS1zdHJlYW1hYmxlLXZhbHVlLnRzeCIsIi9Vc2Vycy9sb3JlbnpvcmFzbXVzc2VuL1Byb2plY3RzL0dvb0dsZWRhdGFuZXh1cy1haS9zaGFyZWQtY2xpZW50L2NvbnRleHQudHN4IiwiL1VzZXJzL2xvcmVuem9yYXNtdXNzZW4vUHJvamVjdHMvdXRpbC9pcy1mdW5jdGlvbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgU1RSRUFNQUJMRV9WQUxVRV9UWVBFID0gU3ltYm9sLmZvcigndWkuc3RyZWFtYWJsZS52YWx1ZScpO1xuXG5leHBvcnQgdHlwZSBTdHJlYW1hYmxlUGF0Y2ggPSB1bmRlZmluZWQgfCBbMCwgc3RyaW5nXTsgLy8gQXBwZW5kIHN0cmluZy5cblxuZGVjbGFyZSBjb25zdCBfX2ludGVybmFsX2N1cnI6IHVuaXF1ZSBzeW1ib2w7XG5kZWNsYXJlIGNvbnN0IF9faW50ZXJuYWxfZXJyb3I6IHVuaXF1ZSBzeW1ib2w7XG5cbi8qKlxuICogU3RyZWFtYWJsZVZhbHVlIGlzIGEgdmFsdWUgdGhhdCBjYW4gYmUgc3RyZWFtZWQgb3ZlciB0aGUgbmV0d29yayB2aWEgQUkgQWN0aW9ucy5cbiAqIFRvIHJlYWQgdGhlIHN0cmVhbWVkIHZhbHVlcywgdXNlIHRoZSBgcmVhZFN0cmVhbWFibGVWYWx1ZWAgb3IgYHVzZVN0cmVhbWFibGVWYWx1ZWAgQVBJcy5cbiAqL1xuZXhwb3J0IHR5cGUgU3RyZWFtYWJsZVZhbHVlPFQgPSBhbnksIEUgPSBhbnk+ID0ge1xuICAvKipcbiAgICogQGludGVybmFsIFVzZSBgcmVhZFN0cmVhbWFibGVWYWx1ZWAgdG8gcmVhZCB0aGUgdmFsdWVzLlxuICAgKi9cbiAgdHlwZT86IHR5cGVvZiBTVFJFQU1BQkxFX1ZBTFVFX1RZUEU7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgVXNlIGByZWFkU3RyZWFtYWJsZVZhbHVlYCB0byByZWFkIHRoZSB2YWx1ZXMuXG4gICAqL1xuICBjdXJyPzogVDtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBVc2UgYHJlYWRTdHJlYW1hYmxlVmFsdWVgIHRvIHJlYWQgdGhlIHZhbHVlcy5cbiAgICovXG4gIGVycm9yPzogRTtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBVc2UgYHJlYWRTdHJlYW1hYmxlVmFsdWVgIHRvIHJlYWQgdGhlIHZhbHVlcy5cbiAgICovXG4gIGRpZmY/OiBTdHJlYW1hYmxlUGF0Y2g7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgVXNlIGByZWFkU3RyZWFtYWJsZVZhbHVlYCB0byByZWFkIHRoZSB2YWx1ZXMuXG4gICAqL1xuICBuZXh0PzogUHJvbWlzZTxTdHJlYW1hYmxlVmFsdWU8VCwgRT4+O1xuXG4gIC8vIGJyYW5kZWQgdHlwZXMgdG8gbWFpbnRhaW4gdHlwZSBzaWduYXR1cmUgYWZ0ZXIgaW50ZXJuYWwgcHJvcGVydGllcyBhcmUgc3RyaXBwZWQuXG4gIFtfX2ludGVybmFsX2N1cnJdPzogVDtcbiAgW19faW50ZXJuYWxfZXJyb3JdPzogRTtcbn07XG4iLCJpbXBvcnQgeyBTVFJFQU1BQkxFX1ZBTFVFX1RZUEUsIFN0cmVhbWFibGVWYWx1ZSB9IGZyb20gJy4vc3RyZWFtYWJsZS12YWx1ZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmVhbWFibGVWYWx1ZSh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFN0cmVhbWFibGVWYWx1ZSB7XG4gIHJldHVybiAoXG4gICAgdmFsdWUgIT0gbnVsbCAmJlxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAndHlwZScgaW4gdmFsdWUgJiZcbiAgICB2YWx1ZS50eXBlID09PSBTVFJFQU1BQkxFX1ZBTFVFX1RZUEVcbiAgKTtcbn1cbiIsImltcG9ydCB7IGlzU3RyZWFtYWJsZVZhbHVlIH0gZnJvbSAnLi9pcy1zdHJlYW1hYmxlLXZhbHVlJztcbmltcG9ydCB7IFN0cmVhbWFibGVWYWx1ZSB9IGZyb20gJy4vc3RyZWFtYWJsZS12YWx1ZSc7XG5cbi8qKlxuICogYHJlYWRTdHJlYW1hYmxlVmFsdWVgIHRha2VzIGEgc3RyZWFtYWJsZSB2YWx1ZSBjcmVhdGVkIHZpYSB0aGUgYGNyZWF0ZVN0cmVhbWFibGVWYWx1ZSgpLnZhbHVlYCBBUEksXG4gKiBhbmQgcmV0dXJucyBhbiBhc3luYyBpdGVyYXRvci5cbiAqXG4gKiBgYGBqc1xuICogLy8gSW5zaWRlIHlvdXIgQUkgYWN0aW9uOlxuICpcbiAqIGFzeW5jIGZ1bmN0aW9uIGFjdGlvbigpIHtcbiAqICAgJ3VzZSBzZXJ2ZXInXG4gKiAgIGNvbnN0IHN0cmVhbWFibGUgPSBjcmVhdGVTdHJlYW1hYmxlVmFsdWUoKTtcbiAqXG4gKiAgIHN0cmVhbWFibGUudXBkYXRlKDEpO1xuICogICBzdHJlYW1hYmxlLnVwZGF0ZSgyKTtcbiAqICAgc3RyZWFtYWJsZS5kb25lKDMpO1xuICogICAvLyAuLi5cbiAqICAgcmV0dXJuIHN0cmVhbWFibGUudmFsdWU7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBBbmQgdG8gcmVhZCB0aGUgdmFsdWU6XG4gKlxuICogYGBganNcbiAqIGNvbnN0IHN0cmVhbWFibGVWYWx1ZSA9IGF3YWl0IGFjdGlvbigpXG4gKiBmb3IgYXdhaXQgKGNvbnN0IHYgb2YgcmVhZFN0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpKSB7XG4gKiAgIGNvbnNvbGUubG9nKHYpXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBUaGlzIGxvZ3Mgb3V0IDEsIDIsIDMgb24gY29uc29sZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRTdHJlYW1hYmxlVmFsdWU8VCA9IHVua25vd24+KFxuICBzdHJlYW1hYmxlVmFsdWU6IFN0cmVhbWFibGVWYWx1ZTxUPixcbik6IEFzeW5jSXRlcmFibGU8VCB8IHVuZGVmaW5lZD4ge1xuICBpZiAoIWlzU3RyZWFtYWJsZVZhbHVlKHN0cmVhbWFibGVWYWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnSW52YWxpZCB2YWx1ZTogdGhpcyBob29rIG9ubHkgYWNjZXB0cyB2YWx1ZXMgY3JlYXRlZCB2aWEgYGNyZWF0ZVN0cmVhbWFibGVWYWx1ZWAuJyxcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgbGV0IHJvdzogU3RyZWFtYWJsZVZhbHVlPFQ+IHwgUHJvbWlzZTxTdHJlYW1hYmxlVmFsdWU8VD4+ID1cbiAgICAgICAgc3RyZWFtYWJsZVZhbHVlO1xuICAgICAgbGV0IHZhbHVlID0gcm93LmN1cnI7IC8vIHRoZSBjdXJyZW50IHZhbHVlXG4gICAgICBsZXQgaXNEb25lID0gZmFsc2U7XG4gICAgICBsZXQgaXNGaXJzdEl0ZXJhdGlvbiA9IHRydWU7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICAgICAgLy8gdGhlIGl0ZXJhdGlvbiBpcyBkb25lIGFscmVhZHksIHJldHVybiB0aGUgbGFzdCB2YWx1ZTpcbiAgICAgICAgICBpZiAoaXNEb25lKSByZXR1cm4geyB2YWx1ZSwgZG9uZTogdHJ1ZSB9O1xuXG4gICAgICAgICAgLy8gcmVzb2x2ZSB0aGUgcHJvbWlzZSBhdCB0aGUgYmVnaW5uaW5nIG9mIGVhY2ggaXRlcmF0aW9uOlxuICAgICAgICAgIHJvdyA9IGF3YWl0IHJvdztcblxuICAgICAgICAgIC8vIHRocm93IGVycm9yIGlmIGFueTpcbiAgICAgICAgICBpZiAocm93LmVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IHJvdy5lcnJvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHZhbHVlIG9yIGEgcGF0Y2gsIHVzZSBpdDpcbiAgICAgICAgICBpZiAoJ2N1cnInIGluIHJvdyB8fCByb3cuZGlmZikge1xuICAgICAgICAgICAgaWYgKHJvdy5kaWZmKSB7XG4gICAgICAgICAgICAgIC8vIHN0cmVhbWFibGUgcGF0Y2ggKHRleHQgb25seSk6XG4gICAgICAgICAgICAgIGlmIChyb3cuZGlmZlswXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICdJbnZhbGlkIHBhdGNoOiBjYW4gb25seSBhcHBlbmQgdG8gc3RyaW5nIHR5cGVzLiBUaGlzIGlzIGEgYnVnIGluIHRoZSBBSSBTREsuJyxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY2FzdGluZyByZXF1aXJlZCB0byByZW1vdmUgVCAmIHN0cmluZyBsaW1pdGF0aW9uXG4gICAgICAgICAgICAgICAgKHZhbHVlIGFzIHN0cmluZykgPSB2YWx1ZSArIHJvdy5kaWZmWzFdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyByZXBsYWNlIHRoZSB2YWx1ZSAoZnVsbCBuZXcgdmFsdWUpXG4gICAgICAgICAgICAgIHZhbHVlID0gcm93LmN1cnI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoZSBsYXN0IGVtaXR0ZWQgeyBkb25lOiB0cnVlIH0gd29uJ3QgYmUgdXNlZCBhcyB0aGUgdmFsdWVcbiAgICAgICAgICAgIC8vIGJ5IHRoZSBmb3IgYXdhaXQuLi5vZiBzeW50YXguXG4gICAgICAgICAgICBpZiAoIXJvdy5uZXh0KSB7XG4gICAgICAgICAgICAgIGlzRG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHRoZXJlIGFyZSBubyBmdXJ0aGVyIHJvd3MgdG8gaXRlcmF0ZSBvdmVyOlxuICAgICAgICAgIGlmIChyb3cubmV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJvdyA9IHJvdy5uZXh0O1xuXG4gICAgICAgICAgaWYgKGlzRmlyc3RJdGVyYXRpb24pIHtcbiAgICAgICAgICAgIGlzRmlyc3RJdGVyYXRpb24gPSBmYWxzZTsgLy8gVE9ETyBzaG91bGQgdGhpcyBiZSBzZXQgZm9yIGV2ZXJ5IHJldHVybj9cblxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgaW5pdGlhbCBjaHVuayBhbmQgdGhlcmUgaXNuJ3QgYW4gaW5pdGlhbCB2YWx1ZSB5ZXQuXG4gICAgICAgICAgICAgIC8vIExldCdzIHNraXAgdGhpcyBvbmUuXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSxcbiAgfTtcbn1cbiIsImltcG9ydCB7IHN0YXJ0VHJhbnNpdGlvbiwgdXNlTGF5b3V0RWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHJlYWRTdHJlYW1hYmxlVmFsdWUgfSBmcm9tICcuL3JlYWQtc3RyZWFtYWJsZS12YWx1ZSc7XG5pbXBvcnQgeyBTdHJlYW1hYmxlVmFsdWUgfSBmcm9tICcuL3N0cmVhbWFibGUtdmFsdWUnO1xuaW1wb3J0IHsgaXNTdHJlYW1hYmxlVmFsdWUgfSBmcm9tICcuL2lzLXN0cmVhbWFibGUtdmFsdWUnO1xuXG5mdW5jdGlvbiBjaGVja1N0cmVhbWFibGVWYWx1ZSh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFN0cmVhbWFibGVWYWx1ZSB7XG4gIGNvbnN0IGhhc1NpZ25hdHVyZSA9IGlzU3RyZWFtYWJsZVZhbHVlKHZhbHVlKTtcblxuICBpZiAoIWhhc1NpZ25hdHVyZSAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0ludmFsaWQgdmFsdWU6IHRoaXMgaG9vayBvbmx5IGFjY2VwdHMgdmFsdWVzIGNyZWF0ZWQgdmlhIGBjcmVhdGVTdHJlYW1hYmxlVmFsdWVgLicsXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBoYXNTaWduYXR1cmU7XG59XG5cbi8qKlxuICogYHVzZVN0cmVhbWFibGVWYWx1ZWAgaXMgYSBSZWFjdCBob29rIHRoYXQgdGFrZXMgYSBzdHJlYW1hYmxlIHZhbHVlIGNyZWF0ZWQgdmlhIHRoZSBgY3JlYXRlU3RyZWFtYWJsZVZhbHVlKCkudmFsdWVgIEFQSSxcbiAqIGFuZCByZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlLCBlcnJvciwgYW5kIHBlbmRpbmcgc3RhdGUuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIGNvbnN1bWluZyBzdHJlYW1hYmxlIHZhbHVlcyByZWNlaXZlZCBmcm9tIGEgY29tcG9uZW50J3MgcHJvcHMuIEZvciBleGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiBmdW5jdGlvbiBNeUNvbXBvbmVudCh7IHN0cmVhbWFibGVWYWx1ZSB9KSB7XG4gKiAgIGNvbnN0IFtkYXRhLCBlcnJvciwgcGVuZGluZ10gPSB1c2VTdHJlYW1hYmxlVmFsdWUoc3RyZWFtYWJsZVZhbHVlKTtcbiAqXG4gKiAgIGlmIChwZW5kaW5nKSByZXR1cm4gPGRpdj5Mb2FkaW5nLi4uPC9kaXY+O1xuICogICBpZiAoZXJyb3IpIHJldHVybiA8ZGl2PkVycm9yOiB7ZXJyb3IubWVzc2FnZX08L2Rpdj47XG4gKlxuICogICByZXR1cm4gPGRpdj5EYXRhOiB7ZGF0YX08L2Rpdj47XG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0cmVhbWFibGVWYWx1ZTxUID0gdW5rbm93biwgRXJyb3IgPSB1bmtub3duPihcbiAgc3RyZWFtYWJsZVZhbHVlPzogU3RyZWFtYWJsZVZhbHVlPFQ+LFxuKTogW2RhdGE6IFQgfCB1bmRlZmluZWQsIGVycm9yOiBFcnJvciB8IHVuZGVmaW5lZCwgcGVuZGluZzogYm9vbGVhbl0ge1xuICBjb25zdCBbY3Vyciwgc2V0Q3Vycl0gPSB1c2VTdGF0ZTxUIHwgdW5kZWZpbmVkPihcbiAgICBjaGVja1N0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpID8gc3RyZWFtYWJsZVZhbHVlLmN1cnIgOiB1bmRlZmluZWQsXG4gICk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8RXJyb3IgfCB1bmRlZmluZWQ+KFxuICAgIGNoZWNrU3RyZWFtYWJsZVZhbHVlKHN0cmVhbWFibGVWYWx1ZSkgPyBzdHJlYW1hYmxlVmFsdWUuZXJyb3IgOiB1bmRlZmluZWQsXG4gICk7XG4gIGNvbnN0IFtwZW5kaW5nLCBzZXRQZW5kaW5nXSA9IHVzZVN0YXRlPGJvb2xlYW4+KFxuICAgIGNoZWNrU3RyZWFtYWJsZVZhbHVlKHN0cmVhbWFibGVWYWx1ZSkgPyAhIXN0cmVhbWFibGVWYWx1ZS5uZXh0IDogZmFsc2UsXG4gICk7XG5cbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNoZWNrU3RyZWFtYWJsZVZhbHVlKHN0cmVhbWFibGVWYWx1ZSkpIHJldHVybjtcblxuICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcblxuICAgIGNvbnN0IGl0ZXJhdG9yID0gcmVhZFN0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpO1xuICAgIGlmIChzdHJlYW1hYmxlVmFsdWUubmV4dCkge1xuICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICBzZXRQZW5kaW5nKHRydWUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgaXRlcmF0b3IpIHtcbiAgICAgICAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgICAgIHNldEN1cnIodmFsdWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgICAgc2V0RXJyb3IoZSBhcyBFcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgICBzZXRQZW5kaW5nKGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSkoKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgIH07XG4gIH0sIFtzdHJlYW1hYmxlVmFsdWVdKTtcblxuICByZXR1cm4gW2N1cnIsIGVycm9yLCBwZW5kaW5nXTtcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwcyAqL1xuJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCAqIGFzIGpzb25kaWZmcGF0Y2ggZnJvbSAnanNvbmRpZmZwYXRjaCc7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi4vLi4vdXRpbC9pcy1mdW5jdGlvbic7XG5pbXBvcnQgdHlwZSB7XG4gIEFJUHJvdmlkZXIsXG4gIEluZmVyQWN0aW9ucyxcbiAgSW5mZXJBSVN0YXRlLFxuICBJbmZlclVJU3RhdGUsXG4gIEludGVybmFsQUlQcm92aWRlclByb3BzLFxuICBWYWx1ZU9yVXBkYXRlcixcbn0gZnJvbSAnLi4vdHlwZXMnO1xuXG5jb25zdCBJbnRlcm5hbFVJU3RhdGVQcm92aWRlciA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8bnVsbCB8IGFueT4obnVsbCk7XG5jb25zdCBJbnRlcm5hbEFJU3RhdGVQcm92aWRlciA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8dW5kZWZpbmVkIHwgYW55Pih1bmRlZmluZWQpO1xuY29uc3QgSW50ZXJuYWxBY3Rpb25Qcm92aWRlciA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8bnVsbCB8IGFueT4obnVsbCk7XG5jb25zdCBJbnRlcm5hbFN5bmNVSVN0YXRlUHJvdmlkZXIgPSBSZWFjdC5jcmVhdGVDb250ZXh0PG51bGwgfCBhbnk+KG51bGwpO1xuXG5leHBvcnQgZnVuY3Rpb24gSW50ZXJuYWxBSVByb3ZpZGVyKHtcbiAgY2hpbGRyZW4sXG4gIGluaXRpYWxVSVN0YXRlLFxuICBpbml0aWFsQUlTdGF0ZSxcbiAgaW5pdGlhbEFJU3RhdGVQYXRjaCxcbiAgd3JhcHBlZEFjdGlvbnMsXG4gIHdyYXBwZWRTeW5jVUlTdGF0ZSxcbn06IEludGVybmFsQUlQcm92aWRlclByb3BzKSB7XG4gIGlmICghKCd1c2UnIGluIFJlYWN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgUmVhY3QgdmVyc2lvbi4nKTtcbiAgfVxuXG4gIGNvbnN0IHVpU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShpbml0aWFsVUlTdGF0ZSk7XG4gIGNvbnN0IHNldFVJU3RhdGUgPSB1aVN0YXRlWzFdO1xuXG4gIGNvbnN0IHJlc29sdmVkSW5pdGlhbEFJU3RhdGVQYXRjaCA9IGluaXRpYWxBSVN0YXRlUGF0Y2hcbiAgICA/IChSZWFjdCBhcyBhbnkpLnVzZShpbml0aWFsQUlTdGF0ZVBhdGNoKVxuICAgIDogdW5kZWZpbmVkO1xuICBpbml0aWFsQUlTdGF0ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChyZXNvbHZlZEluaXRpYWxBSVN0YXRlUGF0Y2gpIHtcbiAgICAgIHJldHVybiBqc29uZGlmZnBhdGNoLnBhdGNoKFxuICAgICAgICBqc29uZGlmZnBhdGNoLmNsb25lKGluaXRpYWxBSVN0YXRlKSxcbiAgICAgICAgcmVzb2x2ZWRJbml0aWFsQUlTdGF0ZVBhdGNoLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGluaXRpYWxBSVN0YXRlO1xuICB9LCBbaW5pdGlhbEFJU3RhdGUsIHJlc29sdmVkSW5pdGlhbEFJU3RhdGVQYXRjaF0pO1xuXG4gIGNvbnN0IGFpU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShpbml0aWFsQUlTdGF0ZSk7XG4gIGNvbnN0IHNldEFJU3RhdGUgPSBhaVN0YXRlWzFdO1xuICBjb25zdCBhaVN0YXRlUmVmID0gUmVhY3QudXNlUmVmKGFpU3RhdGVbMF0pO1xuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgYWlTdGF0ZVJlZi5jdXJyZW50ID0gYWlTdGF0ZVswXTtcbiAgfSwgW2FpU3RhdGVbMF1dKTtcblxuICBjb25zdCBjbGllbnRXcmFwcGVkQWN0aW9ucyA9IFJlYWN0LnVzZU1lbW8oXG4gICAgKCkgPT5cbiAgICAgIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgT2JqZWN0LmVudHJpZXMod3JhcHBlZEFjdGlvbnMpLm1hcCgoW2tleSwgYWN0aW9uXSkgPT4gW1xuICAgICAgICAgIGtleSxcbiAgICAgICAgICBhc3luYyAoLi4uYXJnczogYW55KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhaVN0YXRlU25hcHNob3QgPSBhaVN0YXRlUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBjb25zdCBbYWlTdGF0ZURlbHRhLCByZXN1bHRdID0gYXdhaXQgYWN0aW9uKFxuICAgICAgICAgICAgICBhaVN0YXRlU25hcHNob3QsXG4gICAgICAgICAgICAgIC4uLmFyZ3MsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBhd2FpdCBhaVN0YXRlRGVsdGE7XG4gICAgICAgICAgICAgIGlmIChkZWx0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYWlTdGF0ZVsxXShcbiAgICAgICAgICAgICAgICAgIGpzb25kaWZmcGF0Y2gucGF0Y2goXG4gICAgICAgICAgICAgICAgICAgIGpzb25kaWZmcGF0Y2guY2xvbmUoYWlTdGF0ZVNuYXBzaG90KSxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEsXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH0sXG4gICAgICAgIF0pLFxuICAgICAgKSxcbiAgICBbd3JhcHBlZEFjdGlvbnNdLFxuICApO1xuXG4gIGNvbnN0IGNsaWVudFdyYXBwZWRTeW5jVUlTdGF0ZUFjdGlvbiA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghd3JhcHBlZFN5bmNVSVN0YXRlKSB7XG4gICAgICByZXR1cm4gKCkgPT4ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGFpU3RhdGVTbmFwc2hvdCA9IGFpU3RhdGVSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IFthaVN0YXRlRGVsdGEsIHVpU3RhdGVdID0gYXdhaXQgd3JhcHBlZFN5bmNVSVN0YXRlIShcbiAgICAgICAgYWlTdGF0ZVNuYXBzaG90LFxuICAgICAgKTtcblxuICAgICAgaWYgKHVpU3RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXRVSVN0YXRlKHVpU3RhdGUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkZWx0YSA9IGF3YWl0IGFpU3RhdGVEZWx0YTtcbiAgICAgIGlmIChkZWx0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHBhdGNoZWRBaVN0YXRlID0ganNvbmRpZmZwYXRjaC5wYXRjaChcbiAgICAgICAgICBqc29uZGlmZnBhdGNoLmNsb25lKGFpU3RhdGVTbmFwc2hvdCksXG4gICAgICAgICAgZGVsdGEsXG4gICAgICAgICk7XG4gICAgICAgIHNldEFJU3RhdGUocGF0Y2hlZEFpU3RhdGUpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFt3cmFwcGVkU3luY1VJU3RhdGVdKTtcblxuICByZXR1cm4gKFxuICAgIDxJbnRlcm5hbEFJU3RhdGVQcm92aWRlci5Qcm92aWRlciB2YWx1ZT17YWlTdGF0ZX0+XG4gICAgICA8SW50ZXJuYWxVSVN0YXRlUHJvdmlkZXIuUHJvdmlkZXIgdmFsdWU9e3VpU3RhdGV9PlxuICAgICAgICA8SW50ZXJuYWxBY3Rpb25Qcm92aWRlci5Qcm92aWRlciB2YWx1ZT17Y2xpZW50V3JhcHBlZEFjdGlvbnN9PlxuICAgICAgICAgIDxJbnRlcm5hbFN5bmNVSVN0YXRlUHJvdmlkZXIuUHJvdmlkZXJcbiAgICAgICAgICAgIHZhbHVlPXtjbGllbnRXcmFwcGVkU3luY1VJU3RhdGVBY3Rpb259XG4gICAgICAgICAgPlxuICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgIDwvSW50ZXJuYWxTeW5jVUlTdGF0ZVByb3ZpZGVyLlByb3ZpZGVyPlxuICAgICAgICA8L0ludGVybmFsQWN0aW9uUHJvdmlkZXIuUHJvdmlkZXI+XG4gICAgICA8L0ludGVybmFsVUlTdGF0ZVByb3ZpZGVyLlByb3ZpZGVyPlxuICAgIDwvSW50ZXJuYWxBSVN0YXRlUHJvdmlkZXIuUHJvdmlkZXI+XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VVSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oKSB7XG4gIHR5cGUgVCA9IEluZmVyVUlTdGF0ZTxBSSwgYW55PjtcblxuICBjb25zdCBzdGF0ZSA9IFJlYWN0LnVzZUNvbnRleHQ8XG4gICAgW1QsICh2OiBUIHwgKCh2XzogVCkgPT4gVCkpID0+IHZvaWRdIHwgbnVsbCB8IHVuZGVmaW5lZFxuICA+KEludGVybmFsVUlTdGF0ZVByb3ZpZGVyKTtcbiAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgdXNlVUlTdGF0ZWAgbXVzdCBiZSB1c2VkIGluc2lkZSBhbiA8QUk+IHByb3ZpZGVyLicpO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShzdGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUnKTtcbiAgfVxuICBpZiAoc3RhdGVbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdgaW5pdGlhbFVJU3RhdGVgIG11c3QgYmUgcHJvdmlkZWQgdG8gYGNyZWF0ZUFJYCBvciBgPEFJPmAnLFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vLyBUT0RPOiBIb3cgZG8gd2UgYXZvaWQgY2F1c2luZyBhIHJlLXJlbmRlciB3aGVuIHRoZSBBSSBzdGF0ZSBjaGFuZ2VzIGJ1dCB5b3Vcbi8vIGFyZSBvbmx5IGxpc3RlbmluZyB0byBhIHNwZWNpZmljIGtleT8gV2UgbmVlZCB1c2VTRVMgcGVyaGFwcz9cbmZ1bmN0aW9uIHVzZUFJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PigpOiBbXG4gIEluZmVyQUlTdGF0ZTxBSSwgYW55PixcbiAgKG5ld1N0YXRlOiBWYWx1ZU9yVXBkYXRlcjxJbmZlckFJU3RhdGU8QUksIGFueT4+KSA9PiB2b2lkLFxuXTtcbmZ1bmN0aW9uIHVzZUFJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PihcbiAga2V5OiBrZXlvZiBJbmZlckFJU3RhdGU8QUksIGFueT4sXG4pOiBbXG4gIEluZmVyQUlTdGF0ZTxBSSwgYW55Plt0eXBlb2Yga2V5XSxcbiAgKG5ld1N0YXRlOiBWYWx1ZU9yVXBkYXRlcjxJbmZlckFJU3RhdGU8QUksIGFueT5bdHlwZW9mIGtleV0+KSA9PiB2b2lkLFxuXTtcbmZ1bmN0aW9uIHVzZUFJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PihcbiAgLi4uYXJnczogW10gfCBba2V5b2YgSW5mZXJBSVN0YXRlPEFJLCBhbnk+XVxuKSB7XG4gIHR5cGUgVCA9IEluZmVyQUlTdGF0ZTxBSSwgYW55PjtcblxuICBjb25zdCBzdGF0ZSA9IFJlYWN0LnVzZUNvbnRleHQ8XG4gICAgW1QsIChuZXdTdGF0ZTogVmFsdWVPclVwZGF0ZXI8VD4pID0+IHZvaWRdIHwgbnVsbCB8IHVuZGVmaW5lZFxuICA+KEludGVybmFsQUlTdGF0ZVByb3ZpZGVyKTtcbiAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgdXNlQUlTdGF0ZWAgbXVzdCBiZSB1c2VkIGluc2lkZSBhbiA8QUk+IHByb3ZpZGVyLicpO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShzdGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUnKTtcbiAgfVxuICBpZiAoc3RhdGVbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdgaW5pdGlhbEFJU3RhdGVgIG11c3QgYmUgcHJvdmlkZWQgdG8gYGNyZWF0ZUFJYCBvciBgPEFJPmAnLFxuICAgICk7XG4gIH1cbiAgaWYgKGFyZ3MubGVuZ3RoID49IDEgJiYgdHlwZW9mIHN0YXRlWzBdICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdXaGVuIHVzaW5nIGB1c2VBSVN0YXRlYCB3aXRoIGEga2V5LCB0aGUgQUkgc3RhdGUgbXVzdCBiZSBhbiBvYmplY3QuJyxcbiAgICApO1xuICB9XG5cbiAgY29uc3Qga2V5ID0gYXJnc1swXTtcbiAgY29uc3Qgc2V0dGVyID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgdHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgID8gc3RhdGVbMV1cbiAgICAgIDogKG5ld1N0YXRlOiBWYWx1ZU9yVXBkYXRlcjxUPikgPT4ge1xuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKG5ld1N0YXRlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlWzFdKHMgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4geyAuLi5zLCBba2V5XTogbmV3U3RhdGUoc1trZXldKSB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZVsxXSh7IC4uLnN0YXRlWzBdLCBba2V5XTogbmV3U3RhdGUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIFtrZXldLFxuICApO1xuXG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW3N0YXRlWzBdW2FyZ3NbMF1dLCBzZXR0ZXJdO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VBY3Rpb25zPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oKSB7XG4gIHR5cGUgVCA9IEluZmVyQWN0aW9uczxBSSwgYW55PjtcblxuICBjb25zdCBhY3Rpb25zID0gUmVhY3QudXNlQ29udGV4dDxUPihJbnRlcm5hbEFjdGlvblByb3ZpZGVyKTtcbiAgcmV0dXJuIGFjdGlvbnM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTeW5jVUlTdGF0ZSgpIHtcbiAgY29uc3Qgc3luY1VJU3RhdGUgPSBSZWFjdC51c2VDb250ZXh0PCgpID0+IFByb21pc2U8dm9pZD4+KFxuICAgIEludGVybmFsU3luY1VJU3RhdGVQcm92aWRlcixcbiAgKTtcblxuICBpZiAoc3luY1VJU3RhdGUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2B1c2VTeW5jVUlTdGF0ZWAgbXVzdCBiZSB1c2VkIGluc2lkZSBhbiA8QUk+IHByb3ZpZGVyLicpO1xuICB9XG5cbiAgcmV0dXJuIHN5bmNVSVN0YXRlO1xufVxuXG5leHBvcnQgeyB1c2VBSVN0YXRlIH07XG4iLCIvKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3Vua25vd259IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGlzRnVuY3Rpb24gPSAodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBGdW5jdGlvbiA9PlxuICB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG4iXSwibmFtZXMiOlsidWlTdGF0ZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/rsc/dist/rsc-shared.mjs\n");

/***/ })

};
;